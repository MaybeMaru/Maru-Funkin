<!-- This file can be parsed by haxe.rtti.XmlParser -->
<haxe>
	<abstract path="Any" params="" file="C:\HaxeToolkit\haxe\std/Any.hx">
		<from><icast field="__cast"><c path="__cast.T"/></icast></from>
		<this><d/></this>
		<to><icast field="__promote"><c path="__promote.T"/></icast></to>
		<haxe_doc>`Any` is a type that is compatible with any other in both ways.

	This means that a value of any type can be assigned to `Any`, and
	vice-versa, a value of `Any` type can be assigned to any other type.

	It's a more type-safe alternative to `Dynamic`, because it doesn't
	support field access or operators and it's bound to monomorphs. So,
	to work with the actual value, it needs to be explicitly promoted
	to another type.</haxe_doc>
		<meta><m n=":forward.variance"/></meta>
		<impl><class path="_Any.Any_Impl_" params="" file="C:\HaxeToolkit\haxe\std/Any.hx" private="1" module="Any" final="1">
	<__promote params="T" get="inline" set="null" line="37" static="1">
		<f a="this">
			<d/>
			<c path="__promote.T"/>
		</f>
		<meta>
			<m n=":noCompletion"/>
			<m n=":to"/>
		</meta>
	</__promote>
	<__cast params="T" get="inline" set="null" line="40" static="1">
		<f a="value">
			<c path="__cast.T"/>
			<x path="Any"/>
		</f>
		<meta>
			<m n=":noCompletion"/>
			<m n=":from"/>
		</meta>
	</__cast>
	<toString get="inline" set="null" line="43" static="1">
		<f a="this">
			<d/>
			<c path="String"/>
		</f>
		<meta><m n=":noCompletion"/></meta>
	</toString>
	<meta><m n=":keep"/></meta>
</class></impl>
	</abstract>
	<class path="_Any.Any_Impl_" params="" file="C:\HaxeToolkit\haxe\std/Any.hx" private="1" module="Any" final="1">
		<__promote params="T" get="inline" set="null" line="37" static="1">
			<f a="this">
				<d/>
				<c path="__promote.T"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":to"/>
			</meta>
		</__promote>
		<__cast params="T" get="inline" set="null" line="40" static="1">
			<f a="value">
				<c path="__cast.T"/>
				<x path="Any"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":from"/>
			</meta>
		</__cast>
		<toString get="inline" set="null" line="43" static="1">
			<f a="this">
				<d/>
				<c path="String"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</toString>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="Array" params="T" file="C:\HaxeToolkit\haxe\std/Array.hx" extern="1">
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` Array.</haxe_doc>
		</length>
		<concat public="1" set="method">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns a new Array by appending the elements of `a` to the elements of
		`this` Array.

		This operation does not modify `this` Array.

		If `a` is the empty Array `[]`, a copy of `this` Array is returned.

		The length of the returned Array is equal to the sum of `this.length`
		and `a.length`.

		If `a` is `null`, the result is unspecified.</haxe_doc>
		</concat>
		<join public="1" set="method">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representation of `this` Array, with `sep` separating
		each element.

		The result of this operation is equal to `Std.string(this[0]) + sep +
		Std.string(this[1]) + sep + ... + sep + Std.string(this[this.length-1])`

		If `this` is the empty Array `[]`, the result is the empty String `""`.
		If `this` has exactly one element, the result is equal to a call to
		`Std.string(this[0])`.

		If `sep` is null, the result is unspecified.</haxe_doc>
		</join>
		<pop public="1" set="method">
			<f a=""><x path="Null"><c path="Array.T"/></x></f>
			<haxe_doc>Removes the last element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this.length` will decrease by 1.

		If `this` is the empty Array `[]`, null is returned and the length
		remains 0.</haxe_doc>
		</pop>
		<push public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Adds the element `x` at the end of `this` Array and returns the new
		length of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` increases by 1.</haxe_doc>
		</push>
		<reverse public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[Reverse the order of elements of `this` Array.

		This operation modifies `this` Array in place.

		If `this.length < 2`, `this` remains unchanged.]]></haxe_doc>
		</reverse>
		<shift public="1" set="method">
			<f a=""><x path="Null"><c path="Array.T"/></x></f>
			<haxe_doc>Removes the first element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this`.length and the index of each
		remaining element is decreased by 1.

		If `this` is the empty Array `[]`, `null` is returned and the length
		remains 0.</haxe_doc>
		</shift>
		<slice public="1" set="method">
			<f a="pos:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Creates a shallow copy of the range of `this` Array, starting at and
		including `pos`, up to but not including `end`.

		This operation does not modify `this` Array.

		The elements are not copied and retain their identity.

		If `end` is omitted or exceeds `this.length`, it defaults to the end of
		`this` Array.

		If `pos` or `end` are negative, their offsets are calculated from the
		end of `this` Array by `this.length + pos` and `this.length + end`
		respectively. If this yields a negative value, 0 is used instead.

		If `pos` exceeds `this.length` or if `end` is less than or equals
		`pos`, the result is `[]`.</haxe_doc>
		</slice>
		<sort public="1" set="method">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<x path="Int"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sorts `this` Array according to the comparison function `f`, where
		`f(x,y)` returns 0 if x == y, a positive Int if x > y and a
		negative Int if x < y.

		This operation modifies `this` Array in place.

		The sort operation is not guaranteed to be stable, which means that the
		order of equal elements may not be retained. For a stable Array sorting
		algorithm, `haxe.ds.ArraySort.sort()` can be used instead.

		If `f` is null, the result is unspecified.]]></haxe_doc>
		</sort>
		<splice public="1" set="method">
			<f a="pos:len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc><![CDATA[Removes `len` elements from `this` Array, starting at and including
		`pos`, an returns them.

		This operation modifies `this` Array in place.

		If `len` is < 0 or `pos` exceeds `this`.length, an empty Array [] is
		returned and `this` Array is unchanged.

		If `pos` is negative, its value is calculated from the end	of `this`
		Array by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the sum of the resulting values for `len` and `pos` exceed
		`this.length`, this operation will affect the elements from `pos` to the
		end of `this` Array.

		The length of the returned Array is equal to the new length of `this`
		Array subtracted from the original length of `this` Array. In other
		words, each element of the original `this` Array either remains in
		`this` Array or becomes an element of the returned Array.]]></haxe_doc>
		</splice>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` Array.

		The result will include the individual elements' String representations
		separated by comma. The enclosing [ ] may be missing on some platforms,
		use `Std.string()` to get a String representation that is consistent
		across platforms.</haxe_doc>
		</toString>
		<unshift public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds the element `x` at the start of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` and the index of each Array element increases by 1.</haxe_doc>
		</unshift>
		<insert public="1" set="method">
			<f a="pos:x">
				<x path="Int"/>
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Inserts the element `x` at the position `pos`.

		This operation modifies `this` Array in place.

		The offset is calculated like so:

		- If `pos` exceeds `this.length`, the offset is `this.length`.
		- If `pos` is negative, the offset is calculated from the end of `this`
		  Array, i.e. `this.length + pos`. If this yields a negative value, the
		  offset is 0.
		- Otherwise, the offset is `pos`.

		If the resulting offset does not exceed `this.length`, all elements from
		and including that offset to the end of `this` Array are moved one index
		ahead.</haxe_doc>
		</insert>
		<remove public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the first occurrence of `x` in `this` Array.

		This operation modifies `this` Array in place.

		If `x` is found by checking standard equality, it is removed from `this`
		Array and all following elements are reindexed accordingly. The function
		then returns true.

		If `x` is not found, `this` Array is not changed and the function
		returns false.</haxe_doc>
		</remove>
		<contains public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns whether `this` Array contains `x`.

		If `x` is found by checking standard equality, the function returns `true`, otherwise
		the function returns `false`.</haxe_doc>
		</contains>
		<indexOf public="1" set="method">
			<f a="x:?fromIndex">
				<c path="Array.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns position of the first occurrence of `x` in `this` Array, searching front to back.

		If `x` is found by checking standard equality, the function returns its index.

		If `x` is not found, the function returns -1.

		If `fromIndex` is specified, it will be used as the starting index to search from,
		otherwise search starts with zero index. If it is negative, it will be taken as the
		offset from the end of `this` Array to compute the starting index. If given or computed
		starting index is less than 0, the whole array will be searched, if it is greater than
		or equal to the length of `this` Array, the function returns -1.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="x:?fromIndex">
				<c path="Array.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns position of the last occurrence of `x` in `this` Array, searching back to front.

		If `x` is found by checking standard equality, the function returns its index.

		If `x` is not found, the function returns -1.

		If `fromIndex` is specified, it will be used as the starting index to search from,
		otherwise search starts with the last element index. If it is negative, it will be
		taken as the offset from the end of `this` Array to compute the starting index. If
		given or computed starting index is greater than or equal to the length of `this` Array,
		the whole array will be searched, if it is less than 0, the function returns -1.</haxe_doc>
		</lastIndexOf>
		<copy public="1" set="method">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>Returns a shallow copy of `this` Array.

		The elements are not copied and retain their identity, so
		`a[i] == a.copy()[i]` is true for any valid `i`. However,
		`a == a.copy()` is always false.</haxe_doc>
		</copy>
		<iterator public="1" get="inline" set="null" line="280">
			<f a=""><c path="haxe.iterators.ArrayIterator"><c path="Array.T"/></c></f>
			<meta><m n=":runtime"/></meta>
			<haxe_doc>Returns an iterator of the Array values.</haxe_doc>
		</iterator>
		<keyValueIterator public="1" get="inline" set="null" line="287">
			<f a=""><c path="haxe.iterators.ArrayKeyValueIterator"><c path="Array.T"/></c></f>
			<meta><m n=":runtime"/></meta>
			<haxe_doc>Returns an iterator of the Array indices and values.</haxe_doc>
		</keyValueIterator>
		<map public="1" params="S" get="inline" set="null" line="298">
			<f a="f">
				<f a="">
					<c path="Array.T"/>
					<c path="map.S"/>
				</f>
				<c path="Array"><c path="map.S"/></c>
			</f>
			<meta><m n=":runtime"/></meta>
			<haxe_doc>Creates a new Array by applying function `f` to all elements of `this`.

		The order of elements is preserved.

		If `f` is null, the result is unspecified.</haxe_doc>
		</map>
		<filter public="1" get="inline" set="null" line="316">
			<f a="f">
				<f a="">
					<c path="Array.T"/>
					<x path="Bool"/>
				</f>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<meta><m n=":runtime"/></meta>
			<haxe_doc>Returns an Array containing those elements of `this` for which `f`
		returned true.

		The individual elements are not duplicated and retain their identity.

		If `f` is null, the result is unspecified.</haxe_doc>
		</filter>
		<resize public="1" set="method">
			<f a="len">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the length of the Array.

		If `len` is shorter than the array's current size, the last
		`length - len` elements will be removed. If `len` is longer, the Array
		will be extended, with new elements set to a target-specific default
		value:

		- always null on dynamic targets
		- 0, 0.0 or false for Int, Float and Bool respectively on static targets
		- null for other types on static targets</haxe_doc>
		</resize>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Array.</haxe_doc>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="Class" params="T" file="C:\HaxeToolkit\haxe\std/Class.hx">
		<this><x path="Class"><c path="Class.T"/></x></this>
		<haxe_doc>An abstract type that represents a Class.

	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-class-instance.html</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<class path="Date" params="" file="C:\HaxeToolkit\haxe\std/Date.hx" extern="1">
		<now public="1" set="method" static="1">
			<f a=""><c path="Date"/></f>
			<haxe_doc>Returns a Date representing the current local time.</haxe_doc>
		</now>
		<fromTime public="1" set="method" static="1">
			<f a="t">
				<x path="Float"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Creates a Date from the timestamp (in milliseconds) `t`.</haxe_doc>
		</fromTime>
		<fromString public="1" set="method" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Creates a Date from the formatted string `s`. The following formats are
		accepted by the function:

		- `"YYYY-MM-DD hh:mm:ss"`
		- `"YYYY-MM-DD"`
		- `"hh:mm:ss"`

		The first two formats expressed a date in local time. The third is a time
		relative to the UTC epoch.</haxe_doc>
		</fromString>
		<getTime public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the timestamp (in milliseconds) of `this` date.
		On cpp and neko, this function only has a second resolution, so the
		result will always be a multiple of `1000.0`, e.g. `1454698271000.0`.
		To obtain the current timestamp with better precision on cpp and neko,
		see the `Sys.time` API.

		For measuring time differences with millisecond accuracy on
		all platforms, see `haxe.Timer.stamp`.</haxe_doc>
		</getTime>
		<getHours public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the hours of `this` Date (0-23 range) in the local timezone.</haxe_doc>
		</getHours>
		<getMinutes public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the minutes of `this` Date (0-59 range) in the local timezone.</haxe_doc>
		</getMinutes>
		<getSeconds public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the seconds of `this` Date (0-59 range) in the local timezone.</haxe_doc>
		</getSeconds>
		<getFullYear public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the full year of `this` Date (4 digits) in the local timezone.</haxe_doc>
		</getFullYear>
		<getMonth public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the month of `this` Date (0-11 range) in the local timezone.
		Note that the month number is zero-based.</haxe_doc>
		</getMonth>
		<getDate public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of `this` Date (1-31 range) in the local timezone.</haxe_doc>
		</getDate>
		<getDay public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of the week of `this` Date (0-6 range, where `0` is Sunday)
		in the local timezone.</haxe_doc>
		</getDay>
		<getUTCHours public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the hours of `this` Date (0-23 range) in UTC.</haxe_doc>
		</getUTCHours>
		<getUTCMinutes public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the minutes of `this` Date (0-59 range) in UTC.</haxe_doc>
		</getUTCMinutes>
		<getUTCSeconds public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the seconds of `this` Date (0-59 range) in UTC.</haxe_doc>
		</getUTCSeconds>
		<getUTCFullYear public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the full year of `this` Date (4 digits) in UTC.</haxe_doc>
		</getUTCFullYear>
		<getUTCMonth public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the month of `this` Date (0-11 range) in UTC.
		Note that the month number is zero-based.</haxe_doc>
		</getUTCMonth>
		<getUTCDate public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of `this` Date (1-31 range) in UTC.</haxe_doc>
		</getUTCDate>
		<getUTCDay public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of the week of `this` Date (0-6 range, where `0` is Sunday)
		in UTC.</haxe_doc>
		</getUTCDay>
		<getTimezoneOffset public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the time zone difference of `this` Date in the current locale
		to UTC, in minutes.

		Assuming the function is executed on a machine in a UTC+2 timezone,
		`Date.now().getTimezoneOffset()` will return `-120`.</haxe_doc>
		</getTimezoneOffset>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` Date in the local timezone
		using the standard format `YYYY-MM-DD HH:MM:SS`. See `DateTools.format` for
		other formatting rules.</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="year:month:day:hour:min:sec">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new date object from the given arguments.

		The behaviour of a Date instance is only consistent across platforms if
		the the arguments describe a valid date.

		- month: 0 to 11 (note that this is zero-based)
		- day: 1 to 31
		- hour: 0 to 23
		- min: 0 to 59
		- sec: 0 to 59</haxe_doc>
		</new>
		<haxe_doc>The Date class provides a basic structure for date and time related
	information. Date instances can be created by

	- `new Date()` for a specific date,
	- `Date.now()` to obtain information about the current time,
	- `Date.fromTime()` with a given timestamp or
	- `Date.fromString()` by parsing from a String.

	There are some extra functions available in the `DateTools` class.

	In the context of Haxe dates, a timestamp is defined as the number of
	milliseconds elapsed since 1st January 1970 UTC.

	## Supported range

	Due to platform limitations, only dates in the range 1970 through 2038 are
	supported consistently. Some targets may support dates outside this range,
	depending on the OS at runtime. The `Date.fromTime` method will not work with
	timestamps outside the range on any target.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flash.utils.RegExp" params="" file="C:\HaxeToolkit\haxe\std/flash/utils/RegExp.hx" extern="1">
		<dotall public="1" get="accessor" set="null">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</dotall>
		<extended public="1" get="accessor" set="null">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</extended>
		<global public="1" get="accessor" set="null">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</global>
		<ignoreCase public="1" get="accessor" set="null">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</ignoreCase>
		<lastIndex public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</lastIndex>
		<multiline public="1" get="accessor" set="null">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</multiline>
		<source public="1" get="accessor" set="null">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</source>
		<exec public="1" set="method">
			<f a="?s">
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":ns"><e>"http://adobe.com/AS3/2006/builtin"</e></m></meta>
		</exec>
		<get_dotall set="method"><f a=""><x path="Bool"/></f></get_dotall>
		<get_extended set="method"><f a=""><x path="Bool"/></f></get_extended>
		<get_global set="method"><f a=""><x path="Bool"/></f></get_global>
		<get_ignoreCase set="method"><f a=""><x path="Bool"/></f></get_ignoreCase>
		<get_lastIndex set="method"><f a=""><x path="Int"/></f></get_lastIndex>
		<get_multiline set="method"><f a=""><x path="Bool"/></f></get_multiline>
		<get_source set="method"><f a=""><c path="String"/></f></get_source>
		<set_lastIndex set="method"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_lastIndex>
		<test public="1" set="method">
			<f a="?s">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":ns"><e>"http://adobe.com/AS3/2006/builtin"</e></m></meta>
		</test>
		<new public="1" set="method"><f a="?pattern:?options">
	<d/>
	<d/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"RegExp"</e></m></meta>
	</class>
	<abstract path="Enum" params="T" file="C:\HaxeToolkit\haxe\std/Enum.hx">
		<this><x path="Enum"><c path="Enum.T"/></x></this>
		<haxe_doc>An abstract type that represents an Enum type.

	The corresponding enum instance type is `EnumValue`.

	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-enum-instance.html</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="EnumValue" params="" file="C:\HaxeToolkit\haxe\std/EnumValue.hx">
		<this><x path="EnumValue"/></this>
		<haxe_doc>An abstract type that represents any enum value.
	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-enum-instance.html</haxe_doc>
		<meta><m n=":coreType"/></meta>
		<impl><class path="_EnumValue.EnumValue_Impl_" params="" file="C:\HaxeToolkit\haxe\std/EnumValue.hx" private="1" module="EnumValue" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="Math" params="" file="C:\HaxeToolkit\haxe\std/Math.hx" extern="1">
		<PI public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>Represents the ratio of the circumference of a circle to its diameter,
		specified by the constant, Ï€. `PI` is approximately `3.141592653589793`.</haxe_doc>
		</PI>
		<NEGATIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special `Float` constant which denotes negative infinity.

		For example, this is the result of `-1.0 / 0.0`.

		Operations with `NEGATIVE_INFINITY` as an operand may result in
		`NEGATIVE_INFINITY`, `POSITIVE_INFINITY` or `NaN`.

		If this constant is converted to an `Int`, e.g. through `Std.int()`, the
		result is unspecified.</haxe_doc>
		</NEGATIVE_INFINITY>
		<POSITIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special `Float` constant which denotes positive infinity.

		For example, this is the result of `1.0 / 0.0`.

		Operations with `POSITIVE_INFINITY` as an operand may result in
		`NEGATIVE_INFINITY`, `POSITIVE_INFINITY` or `NaN`.

		If this constant is converted to an `Int`, e.g. through `Std.int()`, the
		result is unspecified.</haxe_doc>
		</POSITIVE_INFINITY>
		<NaN public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special `Float` constant which denotes an invalid number.

		`NaN` stands for "Not a Number". It occurs when a mathematically incorrect
		operation is executed, such as taking the square root of a negative
		number: `Math.sqrt(-1)`.

		All further operations with `NaN` as an operand will result in `NaN`.

		If this constant is converted to an `Int`, e.g. through `Std.int()`, the
		result is unspecified.

		In order to test if a value is `NaN`, you should use `Math.isNaN()` function.</haxe_doc>
		</NaN>
		<abs public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the absolute value of `v`.

		- If `v` is positive or `0`, the result is unchanged. Otherwise the result is `-v`.
		- If `v` is `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		- If `v` is `NaN`, the result is `NaN`.</haxe_doc>
		</abs>
		<min public="1" set="method" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the smaller of values `a` and `b`.

		- If `a` or `b` are `NaN`, the result is `NaN`.
		- If `a` or `b` are `NEGATIVE_INFINITY`, the result is `NEGATIVE_INFINITY`.
		- If `a` and `b` are `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.</haxe_doc>
		</min>
		<max public="1" set="method" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the greater of values `a` and `b`.

		- If `a` or `b` are `NaN`, the result is `NaN`.
		- If `a` or `b` are `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		- If `a` and `b` are `NEGATIVE_INFINITY`, the result is `NEGATIVE_INFINITY`.</haxe_doc>
		</max>
		<sin public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric sine of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</sin>
		<cos public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric cosine of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</cos>
		<tan public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric tangent of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</tan>
		<asin public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</asin>
		<acos public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc cosine of the specified angle `v`,
		in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</acos>
		<atan public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc tangent of the specified angle `v`,
		in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</atan>
		<atan2 public="1" set="method" static="1">
			<f a="y:x">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc tangent whose tangent is the quotient of
		two specified numbers, in radians.

		If parameter `x` or `y`  is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`,
		the result is `NaN`.</haxe_doc>
		</atan2>
		<exp public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns Euler's number, raised to the power of `v`.

		`exp(1.0)` is approximately `2.718281828459`.

		- If `v` is `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		- If `v` is `NEGATIVE_INFINITY`, the result is `0.0`.
		- If `v` is `NaN`, the result is `NaN`.</haxe_doc>
		</exp>
		<log public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the natural logarithm of `v`.

		This is the mathematical inverse operation of exp,
		i.e. `log(exp(v)) == v` always holds.

		- If `v` is negative (including `NEGATIVE_INFINITY`) or `NaN`, the result is `NaN`.
		- If `v` is `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		- If `v` is `0.0`, the result is `NEGATIVE_INFINITY`.</haxe_doc>
		</log>
		<pow public="1" set="method" static="1">
			<f a="v:exp">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns a specified base `v` raised to the specified power `exp`.</haxe_doc>
		</pow>
		<sqrt public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the square root of `v`.

		- If `v` is negative (including `NEGATIVE_INFINITY`) or `NaN`, the result is `NaN`.
		- If `v` is `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		- If `v` is `0.0`, the result is `0.0`.</haxe_doc>
		</sqrt>
		<round public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Rounds `v` to the nearest integer value.

		Ties are rounded up, so that `0.5` becomes `1` and `-0.5` becomes `0`.

		If `v` is outside of the signed `Int32` range, or is `NaN`, `NEGATIVE_INFINITY`
		or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</round>
		<floor public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the largest integer value that is not greater than `v`.

		If `v` is outside of the signed `Int32` range, or is `NaN`, `NEGATIVE_INFINITY`
		or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</floor>
		<ceil public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the smallest integer value that is not less than `v`.

		If `v` is outside of the signed `Int32` range, or is `NaN`, `NEGATIVE_INFINITY`
		or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</ceil>
		<random public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns a pseudo-random number which is greater than or equal to `0.0`,
		and less than `1.0`.</haxe_doc>
		</random>
		<ffloor public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the largest integer value that is not greater than `v`, as a `Float`.

		If `v` is is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`,
		the result is unspecified.</haxe_doc>
		</ffloor>
		<fceil public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the smallest integer value that is not less than `v`, as a `Float`.

		If `v` is is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`,
		the result is unspecified.</haxe_doc>
		</fceil>
		<fround public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Rounds `v` to the nearest integer value, as a Float.

		Ties are rounded up, so that `0.5` becomes `1` and `-0.5` becomes `0`.

		If `v` is is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`,
		the result is unspecified.</haxe_doc>
		</fround>
		<isFinite public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is a finite number.

		If `f` is `POSITIVE_INFINITY`, `NEGATIVE_INFINITY` or `NaN`, the result
		is `false`, otherwise the result is `true`.</haxe_doc>
		</isFinite>
		<isNaN public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is not a valid number.

		If `f` is `NaN`, the result is `true`, otherwise the result is `false`.
		In particular, both `POSITIVE_INFINITY` and `NEGATIVE_INFINITY` are
		not considered `NaN`.</haxe_doc>
		</isNaN>
		<haxe_doc>This class defines mathematical functions and constants.

	@see https://haxe.org/manual/std-math.html</haxe_doc>
	</class>
	<class path="Std" params="" file="C:\HaxeToolkit\haxe\std/flash/_std/Std.hx">
		<isOfType public="1" set="method" line="31" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if a value `v` is of the type `t`. Returns `false` if `v` or `t` are null.

		If `t` is a class or interface with `@:generic` meta, the result is `false`.</haxe_doc>
		</isOfType>
		<string public="1" set="method" line="44" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Converts any value to a String.

		If `s` is of `String`, `Int`, `Float` or `Bool`, its value is returned.

		If `s` is an instance of a class and that class or one of its parent classes has
		a `toString` method, that method is called. If no such method is present, the result
		is unspecified.

		If `s` is an enum constructor without argument, the constructor's name is returned. If
		arguments exists, the constructor's name followed by the String representations of
		the arguments is returned.

		If `s` is a structure, the field names along with their values are returned. The field order
		and the operator separating field names and values are unspecified.

		If s is null, "null" is returned.</haxe_doc>
		</string>
		<haxe_doc>The Std class provides standard methods for manipulating basic types.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Void" params="" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Void"/></this>
		<haxe_doc>The standard `Void` type. Only `null` values can be of the type `Void`.

	@see https://haxe.org/manual/types-void.html</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<abstract path="Float" params="" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Float"/></this>
		<haxe_doc><![CDATA[The standard `Float` type, this is a double-precision IEEE 64bit float.

	On static targets, `null` cannot be assigned to Float. If this is necessary,
	`Null<Float>` can be used instead.

	`Std.int` converts a `Float` to an `Int`, rounded towards 0.
	`Std.parseFloat` converts a `String` to a `Float`.

	@see https://haxe.org/manual/types-basic-types.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Int" params="" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Int"/></this>
		<to><icast><x path="Float"/></icast></to>
		<haxe_doc><![CDATA[The standard `Int` type. Its precision depends on the platform.

	On static targets, `null` cannot be assigned to `Int`. If this is necessary,
	`Null<Int>` can be used instead.

	`Std.int` converts a `Float` to an `Int`, rounded towards 0.
	`Std.parseInt` converts a `String` to an `Int`.

	@see https://haxe.org/manual/types-basic-types.html
	@see https://haxe.org/manual/std-math-integer-math.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Null" params="T" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<from><icast><c path="Null.T"/></icast></from>
		<this><x path="Null"><c path="Null.T"/></x></this>
		<to><icast><c path="Null.T"/></icast></to>
		<haxe_doc><![CDATA[`Null<T>` is a wrapper that can be used to make the basic types `Int`,
	`Float` and `Bool` nullable on static targets.

	If null safety is enabled, only types wrapped in `Null<T>` are nullable.

	Otherwise, it has no effect on non-basic-types, but it can be useful as a way to document
	that `null` is an acceptable value for a method argument, return value or variable.

	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":forward"/>
			<m n=":coreType"/>
		</meta>
	</abstract>
	<abstract path="Bool" params="" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Bool"/></this>
		<haxe_doc><![CDATA[The standard Boolean type, which can either be `true` or `false`.

	On static targets, `null` cannot be assigned to `Bool`. If this is necessary,
	`Null<Bool>` can be used instead.

	@see https://haxe.org/manual/types-bool.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Dynamic" params="T" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Dynamic"><c path="Dynamic.T"/></x></this>
		<haxe_doc>`Dynamic` is a special type which is compatible with all other types.

	Use of `Dynamic` should be minimized as it prevents several compiler
	checks and optimizations. See `Any` type for a safer alternative for
	representing values of any type.

	@see https://haxe.org/manual/types-dynamic.html</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Iterator" params="T" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method">
				<f a=""><c path="Iterator.T"/></f>
				<haxe_doc>Returns the current item of the `Iterator` and advances to the next one.

		This method is not required to check `hasNext()` first. A call to this
		method while `hasNext()` is `false` yields unspecified behavior.

		On the other hand, iterators should not require a call to `hasNext()`
		before the first call to `next()` if an element is available.</haxe_doc>
			</next>
			<hasNext set="method">
				<f a=""><x path="Bool"/></f>
				<haxe_doc>Returns `false` if the iteration is complete, `true` otherwise.

		Usually iteration is considered to be complete if all elements of the
		underlying data structure were handled through calls to `next()`. However,
		in custom iterators any logic may be used to determine the completion
		state.</haxe_doc>
			</hasNext>
		</a>
		<haxe_doc>An `Iterator` is a structure that permits iteration over elements of type `T`.

	Any class with matching `hasNext()` and `next()` fields is considered an `Iterator`
	and can then be used e.g. in `for`-loops. This makes it easy to implement
	custom iterators.

	@see https://haxe.org/manual/lf-iterators.html</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>An `Iterable` is a data structure which has an `iterator()` method.
	See `Lambda` for generic functions on iterable structures.

	@see https://haxe.org/manual/lf-iterators.html</haxe_doc>
	</typedef>
	<typedef path="KeyValueIterator" params="K:V" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<t path="Iterator"><a>
	<value><c path="KeyValueIterator.V"/></value>
	<key><c path="KeyValueIterator.K"/></key>
</a></t>
		<haxe_doc>A `KeyValueIterator` is an `Iterator` that has a key and a value.</haxe_doc>
	</typedef>
	<typedef path="KeyValueIterable" params="K:V" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<a><keyValueIterator set="method"><f a=""><t path="KeyValueIterator">
	<c path="KeyValueIterable.K"/>
	<c path="KeyValueIterable.V"/>
</t></f></keyValueIterator></a>
		<haxe_doc>A `KeyValueIterable` is a data structure which has a `keyValueIterator()`
	method to iterate over key-value-pairs.</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>`ArrayAccess` is used to indicate a class that can be accessed using brackets.
	The type parameter represents the type of the elements stored.

	This interface should be used for externs only. Haxe does not support custom
	array access on classes. However, array access can be implemented for
	abstract types.

	@see https://haxe.org/manual/types-abstract-array-access.html</haxe_doc></class>
	<class path="String" params="" file="C:\HaxeToolkit\haxe\std/flash/_std/String.hx" extern="1">
		<fromCharCode public="1" get="inline" set="null" line="38" static="1">
			<f a="code">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the String corresponding to the character code `code`.

		If `code` is negative or has another invalid value, the result is
		unspecified.</haxe_doc>
		</fromCharCode>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The number of characters in `this` String.</haxe_doc>
		</length>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are upper case.</haxe_doc>
		</toUpperCase>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are lower case.</haxe_doc>
		</toLowerCase>
		<charAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the character at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, the empty String `""`
		is returned.</haxe_doc>
		</charAt>
		<charCodeAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<haxe_doc>Returns the character code at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, `null` is returned.

		To obtain the character code of a single character, `"x".code` can be
		used instead to inline the character code at compile time. Note that
		this only works on String literals of length 1.</haxe_doc>
		</charCodeAt>
		<indexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the leftmost occurrence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String starting from `startIndex`.

		If `startIndex` exceeds `this.length`, -1 is returned.

		If `startIndex` is negative, the result is unspecifed.

		Otherwise the search is performed within `this` String. In either case,
		the returned position is relative to the beginning of `this` String.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the rightmost occurrence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String from 0 to `startIndex + str.length`. Otherwise the search
		is performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.

		If `startIndex` is negative, the result is unspecifed.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</lastIndexOf>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Splits `this` String at each occurrence of `delimiter`.

		If `this` String is the empty String `""`, the result is not consistent
		across targets and may either be `[]` (on Js, Cpp) or `[""]`.

		If `delimiter` is the empty String `""`, `this` String is split into an
		Array of `this.length` elements, where the elements correspond to the
		characters of `this` String.

		If `delimiter` is not found within `this` String, the result is an Array
		with one element, which equals `this` String.

		If `delimiter` is null, the result is unspecified.

		Otherwise, `this` String is split into parts at each occurrence of
		`delimiter`. If `this` String starts (or ends) with `delimiter`, the
		result `Array` contains a leading (or trailing) empty String `""` element.
		Two subsequent delimiters also result in an empty String `""` element.</haxe_doc>
		</split>
		<substr public="1" set="method">
			<f a="pos:?len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns `len` characters of `this` String, starting at position `pos`.

		If `len` is omitted, all characters from position `pos` to the end of
		`this` String are included.

		If `pos` is negative, its value is calculated from the end of `this`
		String by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the calculated position + `len` exceeds `this.length`, the characters
		from that position to the end of `this` String are returned.

		If `len` is negative, the result is unspecified.</haxe_doc>
		</substr>
		<substring public="1" set="method">
			<f a="startIndex:?endIndex">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the part of `this` String from `startIndex` to but not including `endIndex`.

		If `startIndex` or `endIndex` are negative, 0 is used instead.

		If `startIndex` exceeds `endIndex`, they are swapped.

		If the (possibly swapped) `endIndex` is omitted or exceeds
		`this.length`, `this.length` is used instead.

		If the (possibly swapped) `startIndex` exceeds `this.length`, the empty
		String `""` is returned.</haxe_doc>
		</substring>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the String itself.</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a copy from a given String.</haxe_doc>
		</new>
		<haxe_doc>The basic String class.

	A Haxe String is immutable, it is not possible to modify individual
	characters. No method of this class changes the state of `this` String.

	Strings can be constructed using the String literal syntax `"string value"`.

	String can be concatenated by using the `+` operator. If an operand is not a
	String, it is passed through `Std.string()` first.

	@see https://haxe.org/manual/std-String.html</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="Type" params="" file="C:\HaxeToolkit\haxe\std/flash/_std/Type.hx">
		<enumIndex public="1" get="inline" set="null" line="294" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the index of enum instance `e`.

		This corresponds to the original syntactic position of `e`. The index of
		the first declared constructor is 0, the next one is 1 etc.

		If `e` is null, the result is unspecified.</haxe_doc>
		</enumIndex>
		<haxe_doc>The Haxe Reflection API allows retrieval of type information at runtime.

	This class complements the more lightweight Reflect class, with a focus on
	class and enum instances.

	@see https://haxe.org/manual/types.html
	@see https://haxe.org/manual/std-reflection.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="UInt" params="" file="C:\HaxeToolkit\haxe\std/UInt.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="Int"/></icast>
			<icast field="toFloat"><x path="Float"/></icast>
		</to>
		<haxe_doc>The unsigned `Int` type is only defined for Flash and C#.
	Simulate it for other platforms.

	@see https://haxe.org/manual/types-basic-types.html</haxe_doc>
		<meta><m n=":transitive"/></meta>
		<impl><class path="_UInt.UInt_Impl_" params="" file="C:\HaxeToolkit\haxe\std/UInt.hx" private="1" module="UInt" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="flash.events.IEventDispatcher" params="" file="C:\HaxeToolkit\haxe\std/flash/events/IEventDispatcher.hx" extern="1" interface="1">
		<addEventListener public="1" set="method">
			<f a="type:listener:?useCapture:?priority:?useWeakReference" v="::false:0:false">
				<c path="String"/>
				<f a="">
					<d/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ useWeakReference : false, priority : 0, useCapture : false }</e></m></meta>
		</addEventListener>
		<dispatchEvent public="1" set="method"><f a="event">
	<c path="flash.events.Event"/>
	<x path="Bool"/>
</f></dispatchEvent>
		<hasEventListener public="1" set="method"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></hasEventListener>
		<removeEventListener public="1" set="method">
			<f a="type:listener:?useCapture" v="::false">
				<c path="String"/>
				<f a="">
					<d/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ useCapture : false }</e></m></meta>
		</removeEventListener>
		<willTrigger public="1" set="method"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></willTrigger>
	</class>
	<class path="flash.events.EventDispatcher" params="" file="C:\HaxeToolkit\haxe\std/flash/events/EventDispatcher.hx" extern="1">
		<implements path="flash.events.IEventDispatcher"/>
		<addEventListener public="1" set="method">
			<f a="type:listener:?useCapture:?priority:?useWeakReference" v="::false:0:false">
				<c path="String"/>
				<f a="">
					<d/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ useWeakReference : false, priority : 0, useCapture : false }</e></m></meta>
		</addEventListener>
		<dispatchEvent public="1" set="method"><f a="event">
	<c path="flash.events.Event"/>
	<x path="Bool"/>
</f></dispatchEvent>
		<hasEventListener public="1" set="method"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></hasEventListener>
		<removeEventListener public="1" set="method">
			<f a="type:listener:?useCapture" v="::false">
				<c path="String"/>
				<f a="">
					<d/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ useCapture : false }</e></m></meta>
		</removeEventListener>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<willTrigger public="1" set="method"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></willTrigger>
		<new public="1" set="method"><f a="?target">
	<c path="flash.events.IEventDispatcher"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.display.IBitmapDrawable" params="" file="C:\HaxeToolkit\haxe\std/flash/display/IBitmapDrawable.hx" extern="1" interface="1"/>
	<class path="flash.display.DisplayObject" params="" file="C:\HaxeToolkit\haxe\std/flash/display/DisplayObject.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<implements path="flash.display.IBitmapDrawable"/>
		<accessibilityProperties public="1" get="accessor" set="accessor">
			<c path="flash.accessibility.AccessibilityProperties"/>
			<meta><m n=":flash.property"/></meta>
		</accessibilityProperties>
		<alpha public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</alpha>
		<blendMode public="1" get="accessor" set="accessor">
			<x path="flash.display.BlendMode"/>
			<meta><m n=":flash.property"/></meta>
		</blendMode>
		<blendShader public="1" get="null" set="accessor">
			<c path="flash.display.Shader"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</blendShader>
		<cacheAsBitmap public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</cacheAsBitmap>
		<filters public="1" get="accessor" set="accessor">
			<c path="Array"><c path="flash.filters.BitmapFilter"/></c>
			<meta><m n=":flash.property"/></meta>
		</filters>
		<height public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</height>
		<loaderInfo public="1" get="accessor" set="null">
			<c path="flash.display.LoaderInfo"/>
			<meta><m n=":flash.property"/></meta>
		</loaderInfo>
		<mask public="1" get="accessor" set="accessor">
			<c path="flash.display.DisplayObject"/>
			<meta><m n=":flash.property"/></meta>
		</mask>
		<mouseX public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</mouseX>
		<mouseY public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</mouseY>
		<name public="1" get="accessor" set="accessor">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</name>
		<opaqueBackground public="1" get="accessor" set="accessor">
			<x path="Null"><x path="UInt"/></x>
			<meta><m n=":flash.property"/></meta>
		</opaqueBackground>
		<parent public="1" get="accessor" set="null">
			<c path="flash.display.DisplayObjectContainer"/>
			<meta><m n=":flash.property"/></meta>
		</parent>
		<root public="1" get="accessor" set="null">
			<c path="flash.display.DisplayObject"/>
			<meta><m n=":flash.property"/></meta>
		</root>
		<rotation public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</rotation>
		<rotationX public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</rotationX>
		<rotationY public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</rotationY>
		<rotationZ public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</rotationZ>
		<scale9Grid public="1" get="accessor" set="accessor">
			<c path="flash.geom.Rectangle"/>
			<meta><m n=":flash.property"/></meta>
		</scale9Grid>
		<scaleX public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</scaleX>
		<scaleY public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</scaleY>
		<scaleZ public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</scaleZ>
		<scrollRect public="1" get="accessor" set="accessor">
			<c path="flash.geom.Rectangle"/>
			<meta><m n=":flash.property"/></meta>
		</scrollRect>
		<stage public="1" get="accessor" set="null">
			<c path="flash.display.Stage"/>
			<meta><m n=":flash.property"/></meta>
		</stage>
		<transform public="1" get="accessor" set="accessor">
			<c path="flash.geom.Transform"/>
			<meta><m n=":flash.property"/></meta>
		</transform>
		<visible public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</visible>
		<width public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</width>
		<x public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</x>
		<y public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</y>
		<z public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</z>
		<getBounds public="1" set="method"><f a="targetCoordinateSpace">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.geom.Rectangle"/>
</f></getBounds>
		<getRect public="1" set="method"><f a="targetCoordinateSpace">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.geom.Rectangle"/>
</f></getRect>
		<get_accessibilityProperties set="method"><f a=""><c path="flash.accessibility.AccessibilityProperties"/></f></get_accessibilityProperties>
		<get_alpha set="method"><f a=""><x path="Float"/></f></get_alpha>
		<get_blendMode set="method"><f a=""><x path="flash.display.BlendMode"/></f></get_blendMode>
		<get_cacheAsBitmap set="method"><f a=""><x path="Bool"/></f></get_cacheAsBitmap>
		<get_filters set="method"><f a=""><c path="Array"><c path="flash.filters.BitmapFilter"/></c></f></get_filters>
		<get_height set="method"><f a=""><x path="Float"/></f></get_height>
		<get_loaderInfo set="method"><f a=""><c path="flash.display.LoaderInfo"/></f></get_loaderInfo>
		<get_mask set="method"><f a=""><c path="flash.display.DisplayObject"/></f></get_mask>
		<get_metaData set="method"><f a=""><d/></f></get_metaData>
		<get_mouseX set="method"><f a=""><x path="Float"/></f></get_mouseX>
		<get_mouseY set="method"><f a=""><x path="Float"/></f></get_mouseY>
		<get_name set="method"><f a=""><c path="String"/></f></get_name>
		<get_opaqueBackground set="method"><f a=""><x path="Null"><x path="UInt"/></x></f></get_opaqueBackground>
		<get_parent set="method"><f a=""><c path="flash.display.DisplayObjectContainer"/></f></get_parent>
		<get_root set="method"><f a=""><c path="flash.display.DisplayObject"/></f></get_root>
		<get_rotation set="method"><f a=""><x path="Float"/></f></get_rotation>
		<get_rotationX set="method"><f a=""><x path="Float"/></f></get_rotationX>
		<get_rotationY set="method"><f a=""><x path="Float"/></f></get_rotationY>
		<get_rotationZ set="method"><f a=""><x path="Float"/></f></get_rotationZ>
		<get_scale9Grid set="method"><f a=""><c path="flash.geom.Rectangle"/></f></get_scale9Grid>
		<get_scaleX set="method"><f a=""><x path="Float"/></f></get_scaleX>
		<get_scaleY set="method"><f a=""><x path="Float"/></f></get_scaleY>
		<get_scaleZ set="method"><f a=""><x path="Float"/></f></get_scaleZ>
		<get_scrollRect set="method"><f a=""><c path="flash.geom.Rectangle"/></f></get_scrollRect>
		<get_stage set="method"><f a=""><c path="flash.display.Stage"/></f></get_stage>
		<get_transform set="method"><f a=""><c path="flash.geom.Transform"/></f></get_transform>
		<get_visible set="method"><f a=""><x path="Bool"/></f></get_visible>
		<get_width set="method"><f a=""><x path="Float"/></f></get_width>
		<get_x set="method"><f a=""><x path="Float"/></f></get_x>
		<get_y set="method"><f a=""><x path="Float"/></f></get_y>
		<get_z set="method"><f a=""><x path="Float"/></f></get_z>
		<globalToLocal public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></globalToLocal>
		<globalToLocal3D public="1" set="method">
			<f a="point">
				<c path="flash.geom.Point"/>
				<c path="flash.geom.Vector3D"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</globalToLocal3D>
		<hitTestObject public="1" set="method"><f a="obj">
	<c path="flash.display.DisplayObject"/>
	<x path="Bool"/>
</f></hitTestObject>
		<hitTestPoint public="1" set="method">
			<f a="x:y:?shapeFlag" v="::false">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ shapeFlag : false }</e></m></meta>
		</hitTestPoint>
		<local3DToGlobal public="1" set="method">
			<f a="point3d">
				<c path="flash.geom.Vector3D"/>
				<c path="flash.geom.Point"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</local3DToGlobal>
		<localToGlobal public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></localToGlobal>
		<set_accessibilityProperties set="method"><f a="value">
	<c path="flash.accessibility.AccessibilityProperties"/>
	<c path="flash.accessibility.AccessibilityProperties"/>
</f></set_accessibilityProperties>
		<set_alpha set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_alpha>
		<set_blendMode set="method"><f a="value">
	<x path="flash.display.BlendMode"/>
	<x path="flash.display.BlendMode"/>
</f></set_blendMode>
		<set_blendShader set="method"><f a="value">
	<c path="flash.display.Shader"/>
	<c path="flash.display.Shader"/>
</f></set_blendShader>
		<set_cacheAsBitmap set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_cacheAsBitmap>
		<set_filters set="method"><f a="value">
	<c path="Array"><c path="flash.filters.BitmapFilter"/></c>
	<c path="Array"><c path="flash.filters.BitmapFilter"/></c>
</f></set_filters>
		<set_height set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_height>
		<set_mask set="method"><f a="value">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
</f></set_mask>
		<set_metaData set="method"><f a="value">
	<d/>
	<d/>
</f></set_metaData>
		<set_name set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_name>
		<set_opaqueBackground set="method"><f a="value">
	<x path="Null"><x path="UInt"/></x>
	<x path="Null"><x path="UInt"/></x>
</f></set_opaqueBackground>
		<set_rotation set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_rotation>
		<set_rotationX set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_rotationX>
		<set_rotationY set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_rotationY>
		<set_rotationZ set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_rotationZ>
		<set_scale9Grid set="method"><f a="value">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
</f></set_scale9Grid>
		<set_scaleX set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_scaleX>
		<set_scaleY set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_scaleY>
		<set_scaleZ set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_scaleZ>
		<set_scrollRect set="method"><f a="value">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
</f></set_scrollRect>
		<set_transform set="method"><f a="value">
	<c path="flash.geom.Transform"/>
	<c path="flash.geom.Transform"/>
</f></set_transform>
		<set_visible set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_visible>
		<set_width set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_width>
		<set_x set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<set_y set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<set_z set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_z>
	</class>
	<class path="flash.display.InteractiveObject" params="" file="C:\HaxeToolkit\haxe\std/flash/display/InteractiveObject.hx" extern="1">
		<extends path="flash.display.DisplayObject"/>
		<accessibilityImplementation public="1" get="accessor" set="accessor">
			<c path="flash.accessibility.AccessibilityImplementation"/>
			<meta><m n=":flash.property"/></meta>
		</accessibilityImplementation>
		<contextMenu public="1" get="accessor" set="accessor">
			<c path="flash.ui.ContextMenu"/>
			<meta><m n=":flash.property"/></meta>
		</contextMenu>
		<doubleClickEnabled public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</doubleClickEnabled>
		<focusRect public="1" get="accessor" set="accessor">
			<d/>
			<meta><m n=":flash.property"/></meta>
		</focusRect>
		<mouseEnabled public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</mouseEnabled>
		<needsSoftKeyboard public="1">
			<x path="Bool"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash11</e></m>
			</meta>
		</needsSoftKeyboard>
		<softKeyboardInputAreaOfInterest public="1">
			<c path="flash.geom.Rectangle"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash11</e></m>
			</meta>
		</softKeyboardInputAreaOfInterest>
		<tabEnabled public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</tabEnabled>
		<tabIndex public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</tabIndex>
		<get_accessibilityImplementation set="method"><f a=""><c path="flash.accessibility.AccessibilityImplementation"/></f></get_accessibilityImplementation>
		<get_contextMenu set="method"><f a=""><c path="flash.ui.ContextMenu"/></f></get_contextMenu>
		<get_doubleClickEnabled set="method"><f a=""><x path="Bool"/></f></get_doubleClickEnabled>
		<get_focusRect set="method"><f a=""><d/></f></get_focusRect>
		<get_mouseEnabled set="method"><f a=""><x path="Bool"/></f></get_mouseEnabled>
		<get_needsSoftKeyboard set="method"><f a=""><x path="Bool"/></f></get_needsSoftKeyboard>
		<get_softKeyboardInputAreaOfInterest set="method"><f a=""><c path="flash.geom.Rectangle"/></f></get_softKeyboardInputAreaOfInterest>
		<get_tabEnabled set="method"><f a=""><x path="Bool"/></f></get_tabEnabled>
		<get_tabIndex set="method"><f a=""><x path="Int"/></f></get_tabIndex>
		<requestSoftKeyboard public="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</requestSoftKeyboard>
		<set_accessibilityImplementation set="method"><f a="value">
	<c path="flash.accessibility.AccessibilityImplementation"/>
	<c path="flash.accessibility.AccessibilityImplementation"/>
</f></set_accessibilityImplementation>
		<set_contextMenu set="method"><f a="value">
	<c path="flash.ui.ContextMenu"/>
	<c path="flash.ui.ContextMenu"/>
</f></set_contextMenu>
		<set_doubleClickEnabled set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_doubleClickEnabled>
		<set_focusRect set="method"><f a="value">
	<d/>
	<d/>
</f></set_focusRect>
		<set_mouseEnabled set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_mouseEnabled>
		<set_needsSoftKeyboard set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_needsSoftKeyboard>
		<set_softKeyboardInputAreaOfInterest set="method"><f a="value">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
</f></set_softKeyboardInputAreaOfInterest>
		<set_tabEnabled set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_tabEnabled>
		<set_tabIndex set="method"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_tabIndex>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.display.DisplayObjectContainer" params="" file="C:\HaxeToolkit\haxe\std/flash/display/DisplayObjectContainer.hx" extern="1">
		<extends path="flash.display.InteractiveObject"/>
		<mouseChildren public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</mouseChildren>
		<numChildren public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</numChildren>
		<tabChildren public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</tabChildren>
		<textSnapshot public="1" get="accessor" set="null">
			<c path="flash.text.TextSnapshot"/>
			<meta><m n=":flash.property"/></meta>
		</textSnapshot>
		<addChild public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
</f></addChild>
		<addChildAt public="1" set="method"><f a="child:index">
	<c path="flash.display.DisplayObject"/>
	<x path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></addChildAt>
		<areInaccessibleObjectsUnderPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<x path="Bool"/>
</f></areInaccessibleObjectsUnderPoint>
		<contains public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<x path="Bool"/>
</f></contains>
		<getChildAt public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></getChildAt>
		<getChildByName public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="flash.display.DisplayObject"/>
</f></getChildByName>
		<getChildIndex public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<x path="Int"/>
</f></getChildIndex>
		<getObjectsUnderPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="Array"><c path="flash.display.DisplayObject"/></c>
</f></getObjectsUnderPoint>
		<get_mouseChildren set="method"><f a=""><x path="Bool"/></f></get_mouseChildren>
		<get_numChildren set="method"><f a=""><x path="Int"/></f></get_numChildren>
		<get_tabChildren set="method"><f a=""><x path="Bool"/></f></get_tabChildren>
		<get_textSnapshot set="method"><f a=""><c path="flash.text.TextSnapshot"/></f></get_textSnapshot>
		<removeChild public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
</f></removeChild>
		<removeChildAt public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></removeChildAt>
		<removeChildren public="1" expr="{ endIndex : 2147483647, beginIndex : 0 }">
			<f a="?beginIndex:?endIndex">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ endIndex : 2147483647, beginIndex : 0 }</e></m>
				<m n=":require"><e>flash11</e></m>
			</meta>
		</removeChildren>
		<setChildIndex public="1" set="method"><f a="child:index">
	<c path="flash.display.DisplayObject"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setChildIndex>
		<set_mouseChildren set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_mouseChildren>
		<set_tabChildren set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_tabChildren>
		<stopAllMovieClips public="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":require"><e>flash11_8</e></m></meta>
		</stopAllMovieClips>
		<swapChildren public="1" set="method"><f a="child1:child2">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
	<x path="Void"/>
</f></swapChildren>
		<swapChildrenAt public="1" set="method"><f a="index1:index2">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></swapChildrenAt>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.display.Sprite" params="" file="C:\HaxeToolkit\haxe\std/flash/display/Sprite.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<buttonMode public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</buttonMode>
		<dropTarget public="1" get="accessor" set="null">
			<c path="flash.display.DisplayObject"/>
			<meta><m n=":flash.property"/></meta>
		</dropTarget>
		<graphics public="1" get="accessor" set="null">
			<c path="flash.display.Graphics"/>
			<meta><m n=":flash.property"/></meta>
		</graphics>
		<hitArea public="1" get="accessor" set="accessor">
			<c path="flash.display.Sprite"/>
			<meta><m n=":flash.property"/></meta>
		</hitArea>
		<soundTransform public="1" get="accessor" set="accessor">
			<c path="flash.media.SoundTransform"/>
			<meta><m n=":flash.property"/></meta>
		</soundTransform>
		<useHandCursor public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</useHandCursor>
		<get_buttonMode set="method"><f a=""><x path="Bool"/></f></get_buttonMode>
		<get_dropTarget set="method"><f a=""><c path="flash.display.DisplayObject"/></f></get_dropTarget>
		<get_graphics set="method"><f a=""><c path="flash.display.Graphics"/></f></get_graphics>
		<get_hitArea set="method"><f a=""><c path="flash.display.Sprite"/></f></get_hitArea>
		<get_soundTransform set="method"><f a=""><c path="flash.media.SoundTransform"/></f></get_soundTransform>
		<get_useHandCursor set="method"><f a=""><x path="Bool"/></f></get_useHandCursor>
		<set_buttonMode set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_buttonMode>
		<set_hitArea set="method"><f a="value">
	<c path="flash.display.Sprite"/>
	<c path="flash.display.Sprite"/>
</f></set_hitArea>
		<set_soundTransform set="method"><f a="value">
	<c path="flash.media.SoundTransform"/>
	<c path="flash.media.SoundTransform"/>
</f></set_soundTransform>
		<set_useHandCursor set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_useHandCursor>
		<startDrag public="1" set="method">
			<f a="?lockCenter:?bounds" v="false:">
				<x path="Bool"/>
				<c path="flash.geom.Rectangle"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ lockCenter : false }</e></m></meta>
		</startDrag>
		<startTouchDrag public="1" expr="{ lockCenter : false }">
			<f a="touchPointID:?lockCenter:?bounds">
				<x path="Int"/>
				<x path="Bool"/>
				<c path="flash.geom.Rectangle"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ lockCenter : false }</e></m>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</startTouchDrag>
		<stopDrag public="1" set="method"><f a=""><x path="Void"/></f></stopDrag>
		<stopTouchDrag public="1">
			<f a="touchPointID">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</stopTouchDrag>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.display.MovieClip" params="" file="C:\HaxeToolkit\haxe\std/flash/display/MovieClip.hx" extern="1">
		<extends path="flash.display.Sprite"/>
		<currentFrame public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</currentFrame>
		<currentFrameLabel public="1" get="accessor" set="null">
			<c path="String"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</currentFrameLabel>
		<currentLabel public="1" get="accessor" set="null">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</currentLabel>
		<currentLabels public="1" get="accessor" set="null">
			<c path="Array"><c path="flash.display.FrameLabel"/></c>
			<meta><m n=":flash.property"/></meta>
		</currentLabels>
		<currentScene public="1" get="accessor" set="null">
			<c path="flash.display.Scene"/>
			<meta><m n=":flash.property"/></meta>
		</currentScene>
		<enabled public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</enabled>
		<framesLoaded public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</framesLoaded>
		<isPlaying public="1">
			<x path="Bool"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash11</e></m>
			</meta>
		</isPlaying>
		<scenes public="1" get="accessor" set="null">
			<c path="Array"><c path="flash.display.Scene"/></c>
			<meta><m n=":flash.property"/></meta>
		</scenes>
		<totalFrames public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</totalFrames>
		<trackAsMenu public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</trackAsMenu>
		<addFrameScript public="1" set="method"><f a="restArgs">
	<t path="haxe.extern.Rest"><d/></t>
	<x path="Void"/>
</f></addFrameScript>
		<get_currentFrame set="method"><f a=""><x path="Int"/></f></get_currentFrame>
		<get_currentFrameLabel set="method"><f a=""><c path="String"/></f></get_currentFrameLabel>
		<get_currentLabel set="method"><f a=""><c path="String"/></f></get_currentLabel>
		<get_currentLabels set="method"><f a=""><c path="Array"><c path="flash.display.FrameLabel"/></c></f></get_currentLabels>
		<get_currentScene set="method"><f a=""><c path="flash.display.Scene"/></f></get_currentScene>
		<get_enabled set="method"><f a=""><x path="Bool"/></f></get_enabled>
		<get_framesLoaded set="method"><f a=""><x path="Int"/></f></get_framesLoaded>
		<get_isPlaying set="method"><f a=""><x path="Bool"/></f></get_isPlaying>
		<get_scenes set="method"><f a=""><c path="Array"><c path="flash.display.Scene"/></c></f></get_scenes>
		<get_totalFrames set="method"><f a=""><x path="Int"/></f></get_totalFrames>
		<get_trackAsMenu set="method"><f a=""><x path="Bool"/></f></get_trackAsMenu>
		<gotoAndPlay public="1" set="method"><f a="frame:?scene">
	<x path="flash.utils.Object"/>
	<c path="String"/>
	<x path="Void"/>
</f></gotoAndPlay>
		<gotoAndStop public="1" set="method"><f a="frame:?scene">
	<x path="flash.utils.Object"/>
	<c path="String"/>
	<x path="Void"/>
</f></gotoAndStop>
		<nextFrame public="1" set="method"><f a=""><x path="Void"/></f></nextFrame>
		<nextScene public="1" set="method"><f a=""><x path="Void"/></f></nextScene>
		<play public="1" set="method"><f a=""><x path="Void"/></f></play>
		<prevFrame public="1" set="method"><f a=""><x path="Void"/></f></prevFrame>
		<prevScene public="1" set="method"><f a=""><x path="Void"/></f></prevScene>
		<set_enabled set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_enabled>
		<set_trackAsMenu set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_trackAsMenu>
		<stop public="1" set="method"><f a=""><x path="Void"/></f></stop>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="haxe.iterators.ArrayIterator" params="T" file="C:\HaxeToolkit\haxe\std/haxe/iterators/ArrayIterator.hx">
		<array final="1"><c path="Array"><c path="haxe.iterators.ArrayIterator.T"/></c></array>
		<new public="1" get="inline" set="null" line="36">
			<f a="array">
				<c path="Array"><c path="haxe.iterators.ArrayIterator.T"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>Create a new `ArrayIterator`.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[This iterator is used only when `Array<T>` is passed to `Iterable<T>`]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.iterators.ArrayKeyValueIterator" params="T" file="C:\HaxeToolkit\haxe\std/haxe/iterators/ArrayKeyValueIterator.hx">
		<current expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</current>
		<array><c path="Array"><c path="haxe.iterators.ArrayKeyValueIterator.T"/></c></array>
		<hasNext public="1" get="inline" set="null" line="36"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="41"><f a=""><a>
	<value><c path="haxe.iterators.ArrayKeyValueIterator.T"/></value>
	<key><x path="Int"/></key>
</a></f></next>
		<new public="1" get="inline" set="null" line="30"><f a="array">
	<c path="Array"><c path="haxe.iterators.ArrayKeyValueIterator.T"/></c>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":ifFeature">
				<e>"anon_read.keyValueIterator"</e>
				<e>"dynamic_read.keyValueIterator"</e>
			</m>
		</meta>
	</class>
	<class path="flash.Boot" params="" file="C:\HaxeToolkit\haxe\std/flash/Boot.hx">
		<extends path="flash.display.MovieClip"/>
		<tf static="1"><c path="flash.text.TextField"/></tf>
		<lines static="1"><c path="Array"><c path="String"/></c></lines>
		<lastError static="1"><c path="flash.errors.Error"/></lastError>
		<skip_constructor public="1" expr="false" line="52" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</skip_constructor>
		<IN_E expr="0" line="83" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</IN_E>
		<enum_to_string public="1" set="method" line="85" static="1"><f a="e">
	<a>
		<tag><c path="String"/></tag>
		<params><c path="Array"><d/></c></params>
	</a>
	<c path="String"/>
</f></enum_to_string>
		<__instanceof public="1" set="method" line="100" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</__instanceof>
		<__clear_trace public="1" set="method" line="109" static="1"><f a=""><x path="Void"/></f></__clear_trace>
		<__set_trace_color public="1" set="method" line="117" static="1"><f a="rgb">
	<x path="UInt"/>
	<x path="Void"/>
</f></__set_trace_color>
		<getTrace public="1" set="method" line="123" static="1"><f a=""><c path="flash.text.TextField"/></f></getTrace>
		<__trace public="1" set="method" line="151" static="1"><f a="v:pos">
	<d/>
	<t path="haxe.PosInfos"/>
	<x path="Void"/>
</f></__trace>
		<__string_rec public="1" set="method" line="171" static="1">
			<f a="v:str:?maxRecursion" v="::5">
				<d/>
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":value"><e>{ maxRecursion : 5 }</e></m>
			</meta>
		</__string_rec>
		<fromCodePoint public="1" set="method" line="221" static="1"><f a="code">
	<x path="Int"/>
	<c path="String"/>
</f></fromCodePoint>
		<__unprotect__ set="method" line="230" static="1"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></__unprotect__>
		<mapDynamic public="1" set="method" line="234" static="1">
			<f a="d:f">
				<d/>
				<d/>
				<unknown/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</mapDynamic>
		<filterDynamic public="1" set="method" line="242" static="1">
			<f a="d:f">
				<d/>
				<d/>
				<unknown/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</filterDynamic>
		<start set="method" line="54">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
		</start>
		<doInitDelay set="method" line="74"><f a="_">
	<unknown/>
	<x path="Void"/>
</f></doInitDelay>
		<init set="method" line="79"><f a=""><x path="Void"/></f></init>
		<new public="1" set="method" line="47"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":keep"/>
		</meta>
	</class>
	<class path="flash._Boot.RealBoot" params="" file="C:\HaxeToolkit\haxe\std/flash/Boot.hx" private="1" module="flash.Boot">
		<extends path="flash.Boot"/>
		<new set="method" line="36"><f a=""><x path="Void"/></f></new>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="flash.Lib" params="" file="C:\HaxeToolkit\haxe\std/flash/Lib.hx">
		<current public="1" static="1"><c path="flash.display.MovieClip"/></current>
		<haxe_doc>Platform-specific Flash Library. Provides some platform-specific
	functions for the Flash target.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="flash.Vector" params="T" file="C:\HaxeToolkit\haxe\std/flash/Vector.hx" extern="1">
		<ofArray public="1" params="T" get="inline" set="null" line="56" static="1">
			<f a="v">
				<c path="Array"><c path="ofArray.T"/></c>
				<c path="flash.Vector"><c path="ofArray.T"/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</ofArray>
		<convert public="1" params="T:U" get="inline" set="null" line="60" static="1">
			<f a="v">
				<c path="flash.Vector"><c path="convert.T"/></c>
				<c path="flash.Vector"><c path="convert.U"/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</convert>
		<typeReference public="1" params="T" get="inline" set="null" line="91" static="1">
			<f a=""><x path="Class"><c path="flash.Vector"><c path="typeReference.T"/></c></x></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc><![CDATA[Get a run-time value referencing the `Vector` class with concrete type parameters.

		Normally in Haxe, for most of the types, type parameters are eliminated at run-time,
		so there is no way to check if a value is of a type with specific type parameters.

		However, on the Flash target, the `flash.Vector<T>` values carry type parameter
		information at run-time all the type-checks (such as `Std.isOfType` and `Std.downcast`) on them
		must be done using a `Class<T>` value that also carries the type parameters. However,
		Haxe syntax does not allow creating such values and this function exists to mitigate
		this limitation.

		It should be used as such:
		```haxe
		var specificVectorType:Class<Vector<Int>> = Vector.typeReference();
		trace(Std.isOfType(vec, specificVectorType));
		```
		or using the type-check syntax:
		```haxe
		trace(Std.isOfType(vec, (Vector.typeReference() : Class<Vector<Int>>)));
		```

		It's also helpful when working with native Flash libraries, that receive Class instances:
		```haxe
		new Signal((Vector.typeReference() : Class<Vector<Int>>));
		```]]></haxe_doc>
		</typeReference>
		<length public="1"><x path="Int"/></length>
		<fixed public="1"><x path="Bool"/></fixed>
		<concat public="1" set="method"><f a="?a">
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
</f></concat>
		<join public="1" set="method"><f a="sep">
	<c path="String"/>
	<c path="String"/>
</f></join>
		<pop public="1" set="method"><f a=""><x path="Null"><c path="flash.Vector.T"/></x></f></pop>
		<push public="1" set="method"><f a="x">
	<c path="flash.Vector.T"/>
	<x path="Int"/>
</f></push>
		<reverse public="1" set="method"><f a=""><x path="Void"/></f></reverse>
		<shift public="1" set="method"><f a=""><x path="Null"><c path="flash.Vector.T"/></x></f></shift>
		<unshift public="1" set="method"><f a="x">
	<c path="flash.Vector.T"/>
	<x path="Void"/>
</f></unshift>
		<slice public="1" set="method"><f a="?pos:?end">
	<x path="Int"/>
	<x path="Int"/>
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
</f></slice>
		<sort public="1" set="method"><f a="f">
	<f a=":">
		<c path="flash.Vector.T"/>
		<c path="flash.Vector.T"/>
		<x path="Int"/>
	</f>
	<x path="Void"/>
</f></sort>
		<splice public="1" set="method"><f a="pos:len">
	<x path="Int"/>
	<x path="Int"/>
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
</f></splice>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<indexOf public="1" set="method"><f a="x:?from">
	<c path="flash.Vector.T"/>
	<x path="Int"/>
	<x path="Int"/>
</f></indexOf>
		<lastIndexOf public="1" set="method"><f a="x:?from">
	<c path="flash.Vector.T"/>
	<x path="Int"/>
	<x path="Int"/>
</f></lastIndexOf>
		<insertAt public="1" get="inline" set="null" line="50"><f a="index:element">
	<x path="Int"/>
	<c path="flash.Vector.T"/>
	<x path="Void"/>
</f></insertAt>
		<removeAt public="1">
			<f a="index">
				<x path="Int"/>
				<c path="flash.Vector.T"/>
			</f>
			<meta><m n=":require"><e>flash19</e></m></meta>
		</removeAt>
		<new public="1" set="method"><f a="?length:?fixed">
	<x path="UInt"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>The Vector class is very similar to Array but is only supported by the Flash Player 10+</haxe_doc>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<class path="flash.accessibility.AccessibilityImplementation" params="" file="C:\HaxeToolkit\haxe\std/flash/accessibility/AccessibilityImplementation.hx" extern="1">
		<errno public="1"><x path="UInt"/></errno>
		<stub public="1"><x path="Bool"/></stub>
		<accDoDefaultAction public="1" set="method"><f a="childID">
	<x path="UInt"/>
	<x path="Void"/>
</f></accDoDefaultAction>
		<accLocation public="1" set="method"><f a="childID">
	<x path="UInt"/>
	<d/>
</f></accLocation>
		<accSelect public="1" set="method"><f a="operation:childID">
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></accSelect>
		<getChildIDArray public="1" set="method"><f a=""><c path="Array"><d/></c></f></getChildIDArray>
		<get_accDefaultAction public="1" set="method"><f a="childID">
	<x path="UInt"/>
	<c path="String"/>
</f></get_accDefaultAction>
		<get_accFocus public="1" set="method"><f a=""><x path="UInt"/></f></get_accFocus>
		<get_accName public="1" set="method"><f a="childID">
	<x path="UInt"/>
	<c path="String"/>
</f></get_accName>
		<get_accRole public="1" set="method"><f a="childID">
	<x path="UInt"/>
	<x path="UInt"/>
</f></get_accRole>
		<get_accSelection public="1" set="method"><f a=""><c path="Array"><d/></c></f></get_accSelection>
		<get_accState public="1" set="method"><f a="childID">
	<x path="UInt"/>
	<x path="UInt"/>
</f></get_accState>
		<get_accValue public="1" set="method"><f a="childID">
	<x path="UInt"/>
	<c path="String"/>
</f></get_accValue>
		<get_selectionActiveIndex public="1" set="method"><f a=""><d/></f></get_selectionActiveIndex>
		<get_selectionAnchorIndex public="1" set="method"><f a=""><d/></f></get_selectionAnchorIndex>
		<isLabeledBy public="1" set="method"><f a="labelBounds">
	<c path="flash.geom.Rectangle"/>
	<x path="Bool"/>
</f></isLabeledBy>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.accessibility.AccessibilityProperties" params="" file="C:\HaxeToolkit\haxe\std/flash/accessibility/AccessibilityProperties.hx" extern="1">
		<description public="1"><c path="String"/></description>
		<forceSimple public="1"><x path="Bool"/></forceSimple>
		<name public="1"><c path="String"/></name>
		<noAutoLabeling public="1"><x path="Bool"/></noAutoLabeling>
		<shortcut public="1"><c path="String"/></shortcut>
		<silent public="1"><x path="Bool"/></silent>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<abstract path="flash.display.ActionScriptVersion" params="" file="C:\HaxeToolkit\haxe\std/flash/display/ActionScriptVersion.hx">
		<this><x path="UInt"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display.ActionScriptVersion"</e></m>
		</meta>
		<impl><class path="flash.display._ActionScriptVersion.ActionScriptVersion_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/display/ActionScriptVersion.hx" private="1" module="flash.display.ActionScriptVersion" extern="1" final="1">
	<ACTIONSCRIPT2 public="1" set="null" static="1">
		<x path="flash.display.ActionScriptVersion"/>
		<meta><m n=":enum"/></meta>
	</ACTIONSCRIPT2>
	<ACTIONSCRIPT3 public="1" set="null" static="1">
		<x path="flash.display.ActionScriptVersion"/>
		<meta><m n=":enum"/></meta>
	</ACTIONSCRIPT3>
	<meta>
		<m n=":native"><e>"flash.display.ActionScriptVersion"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display._ActionScriptVersion.ActionScriptVersion_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/display/ActionScriptVersion.hx" private="1" module="flash.display.ActionScriptVersion" extern="1" final="1">
		<ACTIONSCRIPT2 public="1" set="null" static="1">
			<x path="flash.display.ActionScriptVersion"/>
			<meta><m n=":enum"/></meta>
		</ACTIONSCRIPT2>
		<ACTIONSCRIPT3 public="1" set="null" static="1">
			<x path="flash.display.ActionScriptVersion"/>
			<meta><m n=":enum"/></meta>
		</ACTIONSCRIPT3>
		<meta>
			<m n=":native"><e>"flash.display.ActionScriptVersion"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="flash.display.BitmapData" params="" file="C:\HaxeToolkit\haxe\std/flash/display/BitmapData.hx" extern="1">
		<implements path="flash.display.IBitmapDrawable"/>
		<height public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</height>
		<rect public="1" get="accessor" set="null">
			<c path="flash.geom.Rectangle"/>
			<meta><m n=":flash.property"/></meta>
		</rect>
		<transparent public="1" get="accessor" set="null">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</transparent>
		<width public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</width>
		<applyFilter public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:filter">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="flash.filters.BitmapFilter"/>
	<x path="Void"/>
</f></applyFilter>
		<clone public="1" set="method"><f a=""><c path="flash.display.BitmapData"/></f></clone>
		<colorTransform public="1" set="method"><f a="rect:colorTransform">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.ColorTransform"/>
	<x path="Void"/>
</f></colorTransform>
		<compare public="1" set="method"><f a="otherBitmapData">
	<c path="flash.display.BitmapData"/>
	<x path="flash.utils.Object"/>
</f></compare>
		<copyChannel public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:sourceChannel:destChannel">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></copyChannel>
		<copyPixels public="1" set="method">
			<f a="sourceBitmapData:sourceRect:destPoint:?alphaBitmapData:?alphaPoint:?mergeAlpha" v=":::::false">
				<c path="flash.display.BitmapData"/>
				<c path="flash.geom.Rectangle"/>
				<c path="flash.geom.Point"/>
				<c path="flash.display.BitmapData"/>
				<c path="flash.geom.Point"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ mergeAlpha : false }</e></m></meta>
		</copyPixels>
		<copyPixelsToByteArray public="1">
			<f a="rect:data">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.utils.ByteArray"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11_4</e></m></meta>
		</copyPixelsToByteArray>
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<draw public="1" set="method">
			<f a="source:?matrix:?colorTransform:?blendMode:?clipRect:?smoothing" v=":::::false">
				<c path="flash.display.IBitmapDrawable"/>
				<c path="flash.geom.Matrix"/>
				<c path="flash.geom.ColorTransform"/>
				<x path="flash.display.BlendMode"/>
				<c path="flash.geom.Rectangle"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ smoothing : false }</e></m></meta>
		</draw>
		<drawWithQuality public="1" expr="{ smoothing : false }">
			<f a="source:?matrix:?colorTransform:?blendMode:?clipRect:?smoothing:?quality">
				<c path="flash.display.IBitmapDrawable"/>
				<c path="flash.geom.Matrix"/>
				<c path="flash.geom.ColorTransform"/>
				<x path="flash.display.BlendMode"/>
				<c path="flash.geom.Rectangle"/>
				<x path="Bool"/>
				<x path="flash.display.StageQuality"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ smoothing : false }</e></m>
				<m n=":require"><e>flash11_3</e></m>
			</meta>
		</drawWithQuality>
		<encode public="1">
			<f a="rect:compressor:?byteArray">
				<c path="flash.geom.Rectangle"/>
				<x path="flash.utils.Object"/>
				<c path="flash.utils.ByteArray"/>
				<c path="flash.utils.ByteArray"/>
			</f>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</encode>
		<fillRect public="1" set="method"><f a="rect:color">
	<c path="flash.geom.Rectangle"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></fillRect>
		<floodFill public="1" set="method"><f a="x:y:color">
	<x path="Int"/>
	<x path="Int"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></floodFill>
		<generateFilterRect public="1" set="method"><f a="sourceRect:filter">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.filters.BitmapFilter"/>
	<c path="flash.geom.Rectangle"/>
</f></generateFilterRect>
		<getColorBoundsRect public="1" set="method">
			<f a="mask:color:?findColor" v="::true">
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Bool"/>
				<c path="flash.geom.Rectangle"/>
			</f>
			<meta><m n=":value"><e>{ findColor : true }</e></m></meta>
		</getColorBoundsRect>
		<getPixel public="1" set="method"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="UInt"/>
</f></getPixel>
		<getPixel32 public="1" set="method"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="UInt"/>
</f></getPixel32>
		<getPixels public="1" set="method"><f a="rect">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.utils.ByteArray"/>
</f></getPixels>
		<getVector public="1" set="method">
			<f a="rect">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.Vector"><x path="UInt"/></c>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</getVector>
		<get_height set="method"><f a=""><x path="Int"/></f></get_height>
		<get_rect set="method"><f a=""><c path="flash.geom.Rectangle"/></f></get_rect>
		<get_transparent set="method"><f a=""><x path="Bool"/></f></get_transparent>
		<get_width set="method"><f a=""><x path="Int"/></f></get_width>
		<histogram public="1" set="method">
			<f a="?hRect">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.Vector"><c path="flash.Vector"><x path="Float"/></c></c>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</histogram>
		<hitTest public="1" set="method">
			<f a="firstPoint:firstAlphaThreshold:secondObject:?secondBitmapDataPoint:?secondAlphaThreshold" v="::::1">
				<c path="flash.geom.Point"/>
				<x path="UInt"/>
				<x path="flash.utils.Object"/>
				<c path="flash.geom.Point"/>
				<x path="UInt"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ secondAlphaThreshold : 1 }</e></m></meta>
		</hitTest>
		<lock public="1" set="method"><f a=""><x path="Void"/></f></lock>
		<merge public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:redMultiplier:greenMultiplier:blueMultiplier:alphaMultiplier">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></merge>
		<noise public="1" set="method">
			<f a="randomSeed:?low:?high:?channelOptions:?grayScale" v=":0:255:7:false">
				<x path="Int"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ grayScale : false, channelOptions : 7, high : 255, low : 0 }</e></m></meta>
		</noise>
		<paletteMap public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:?redArray:?greenArray:?blueArray:?alphaArray">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></paletteMap>
		<perlinNoise public="1" set="method">
			<f a="baseX:baseY:numOctaves:randomSeed:stitch:fractalNoise:?channelOptions:?grayScale:?offsets" v="::::::7:false:">
				<x path="Float"/>
				<x path="Float"/>
				<x path="UInt"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="UInt"/>
				<x path="Bool"/>
				<c path="Array"><c path="flash.geom.Point"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ grayScale : false, channelOptions : 7 }</e></m></meta>
		</perlinNoise>
		<pixelDissolve public="1" set="method">
			<f a="sourceBitmapData:sourceRect:destPoint:?randomSeed:?numPixels:?fillColor" v=":::0:0:0">
				<c path="flash.display.BitmapData"/>
				<c path="flash.geom.Rectangle"/>
				<c path="flash.geom.Point"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="UInt"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ fillColor : 0, numPixels : 0, randomSeed : 0 }</e></m></meta>
		</pixelDissolve>
		<scroll public="1" set="method"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></scroll>
		<setPixel public="1" set="method"><f a="x:y:color">
	<x path="Int"/>
	<x path="Int"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></setPixel>
		<setPixel32 public="1" set="method"><f a="x:y:color">
	<x path="Int"/>
	<x path="Int"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></setPixel32>
		<setPixels public="1" set="method"><f a="rect:inputByteArray">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.utils.ByteArray"/>
	<x path="Void"/>
</f></setPixels>
		<setVector public="1" set="method">
			<f a="rect:inputVector">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.Vector"><x path="UInt"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</setVector>
		<threshold public="1" set="method">
			<f a="sourceBitmapData:sourceRect:destPoint:operation:threshold:?color:?mask:?copySource" v=":::::0:0xFFFFFFFF:false">
				<c path="flash.display.BitmapData"/>
				<c path="flash.geom.Rectangle"/>
				<c path="flash.geom.Point"/>
				<c path="String"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Bool"/>
				<x path="UInt"/>
			</f>
			<meta><m n=":value"><e>{ copySource : false, mask : 0xFFFFFFFF, color : 0 }</e></m></meta>
		</threshold>
		<unlock public="1" set="method"><f a="?changeRect">
	<c path="flash.geom.Rectangle"/>
	<x path="Void"/>
</f></unlock>
		<new public="1" set="method">
			<f a="width:height:?transparent:?fillColor" v="::true:0xFFFFFFFF">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ fillColor : 0xFFFFFFFF, transparent : true }</e></m></meta>
		</new>
	</class>
	<abstract path="flash.display.BlendMode" params="" file="C:\HaxeToolkit\haxe\std/flash/display/BlendMode.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display.BlendMode"</e></m>
		</meta>
		<impl><class path="flash.display._BlendMode.BlendMode_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/display/BlendMode.hx" private="1" module="flash.display.BlendMode" extern="1" final="1">
	<ADD public="1" set="null" static="1">
		<x path="flash.display.BlendMode"/>
		<meta><m n=":enum"/></meta>
	</ADD>
	<ALPHA public="1" set="null" static="1">
		<x path="flash.display.BlendMode"/>
		<meta><m n=":enum"/></meta>
	</ALPHA>
	<DARKEN public="1" set="null" static="1">
		<x path="flash.display.BlendMode"/>
		<meta><m n=":enum"/></meta>
	</DARKEN>
	<DIFFERENCE public="1" set="null" static="1">
		<x path="flash.display.BlendMode"/>
		<meta><m n=":enum"/></meta>
	</DIFFERENCE>
	<ERASE public="1" set="null" static="1">
		<x path="flash.display.BlendMode"/>
		<meta><m n=":enum"/></meta>
	</ERASE>
	<HARDLIGHT public="1" set="null" static="1">
		<x path="flash.display.BlendMode"/>
		<meta><m n=":enum"/></meta>
	</HARDLIGHT>
	<INVERT public="1" set="null" static="1">
		<x path="flash.display.BlendMode"/>
		<meta><m n=":enum"/></meta>
	</INVERT>
	<LAYER public="1" set="null" static="1">
		<x path="flash.display.BlendMode"/>
		<meta><m n=":enum"/></meta>
	</LAYER>
	<LIGHTEN public="1" set="null" static="1">
		<x path="flash.display.BlendMode"/>
		<meta><m n=":enum"/></meta>
	</LIGHTEN>
	<MULTIPLY public="1" set="null" static="1">
		<x path="flash.display.BlendMode"/>
		<meta><m n=":enum"/></meta>
	</MULTIPLY>
	<NORMAL public="1" set="null" static="1">
		<x path="flash.display.BlendMode"/>
		<meta><m n=":enum"/></meta>
	</NORMAL>
	<OVERLAY public="1" set="null" static="1">
		<x path="flash.display.BlendMode"/>
		<meta><m n=":enum"/></meta>
	</OVERLAY>
	<SCREEN public="1" set="null" static="1">
		<x path="flash.display.BlendMode"/>
		<meta><m n=":enum"/></meta>
	</SCREEN>
	<SHADER public="1" set="null" static="1">
		<x path="flash.display.BlendMode"/>
		<meta><m n=":enum"/></meta>
	</SHADER>
	<SUBTRACT public="1" set="null" static="1">
		<x path="flash.display.BlendMode"/>
		<meta><m n=":enum"/></meta>
	</SUBTRACT>
	<meta>
		<m n=":native"><e>"flash.display.BlendMode"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display._BlendMode.BlendMode_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/display/BlendMode.hx" private="1" module="flash.display.BlendMode" extern="1" final="1">
		<ADD public="1" set="null" static="1">
			<x path="flash.display.BlendMode"/>
			<meta><m n=":enum"/></meta>
		</ADD>
		<ALPHA public="1" set="null" static="1">
			<x path="flash.display.BlendMode"/>
			<meta><m n=":enum"/></meta>
		</ALPHA>
		<DARKEN public="1" set="null" static="1">
			<x path="flash.display.BlendMode"/>
			<meta><m n=":enum"/></meta>
		</DARKEN>
		<DIFFERENCE public="1" set="null" static="1">
			<x path="flash.display.BlendMode"/>
			<meta><m n=":enum"/></meta>
		</DIFFERENCE>
		<ERASE public="1" set="null" static="1">
			<x path="flash.display.BlendMode"/>
			<meta><m n=":enum"/></meta>
		</ERASE>
		<HARDLIGHT public="1" set="null" static="1">
			<x path="flash.display.BlendMode"/>
			<meta><m n=":enum"/></meta>
		</HARDLIGHT>
		<INVERT public="1" set="null" static="1">
			<x path="flash.display.BlendMode"/>
			<meta><m n=":enum"/></meta>
		</INVERT>
		<LAYER public="1" set="null" static="1">
			<x path="flash.display.BlendMode"/>
			<meta><m n=":enum"/></meta>
		</LAYER>
		<LIGHTEN public="1" set="null" static="1">
			<x path="flash.display.BlendMode"/>
			<meta><m n=":enum"/></meta>
		</LIGHTEN>
		<MULTIPLY public="1" set="null" static="1">
			<x path="flash.display.BlendMode"/>
			<meta><m n=":enum"/></meta>
		</MULTIPLY>
		<NORMAL public="1" set="null" static="1">
			<x path="flash.display.BlendMode"/>
			<meta><m n=":enum"/></meta>
		</NORMAL>
		<OVERLAY public="1" set="null" static="1">
			<x path="flash.display.BlendMode"/>
			<meta><m n=":enum"/></meta>
		</OVERLAY>
		<SCREEN public="1" set="null" static="1">
			<x path="flash.display.BlendMode"/>
			<meta><m n=":enum"/></meta>
		</SCREEN>
		<SHADER public="1" set="null" static="1">
			<x path="flash.display.BlendMode"/>
			<meta><m n=":enum"/></meta>
		</SHADER>
		<SUBTRACT public="1" set="null" static="1">
			<x path="flash.display.BlendMode"/>
			<meta><m n=":enum"/></meta>
		</SUBTRACT>
		<meta>
			<m n=":native"><e>"flash.display.BlendMode"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="flash.display.CapsStyle" params="" file="C:\HaxeToolkit\haxe\std/flash/display/CapsStyle.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display.CapsStyle"</e></m>
		</meta>
		<impl><class path="flash.display._CapsStyle.CapsStyle_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/display/CapsStyle.hx" private="1" module="flash.display.CapsStyle" extern="1" final="1">
	<NONE public="1" set="null" static="1">
		<x path="flash.display.CapsStyle"/>
		<meta><m n=":enum"/></meta>
	</NONE>
	<ROUND public="1" set="null" static="1">
		<x path="flash.display.CapsStyle"/>
		<meta><m n=":enum"/></meta>
	</ROUND>
	<SQUARE public="1" set="null" static="1">
		<x path="flash.display.CapsStyle"/>
		<meta><m n=":enum"/></meta>
	</SQUARE>
	<meta>
		<m n=":native"><e>"flash.display.CapsStyle"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display._CapsStyle.CapsStyle_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/display/CapsStyle.hx" private="1" module="flash.display.CapsStyle" extern="1" final="1">
		<NONE public="1" set="null" static="1">
			<x path="flash.display.CapsStyle"/>
			<meta><m n=":enum"/></meta>
		</NONE>
		<ROUND public="1" set="null" static="1">
			<x path="flash.display.CapsStyle"/>
			<meta><m n=":enum"/></meta>
		</ROUND>
		<SQUARE public="1" set="null" static="1">
			<x path="flash.display.CapsStyle"/>
			<meta><m n=":enum"/></meta>
		</SQUARE>
		<meta>
			<m n=":native"><e>"flash.display.CapsStyle"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="flash.display.ColorCorrection" params="" file="C:\HaxeToolkit\haxe\std/flash/display/ColorCorrection.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display.ColorCorrection"</e></m>
			<m n=":require"><e>flash10_1</e></m>
		</meta>
		<impl><class path="flash.display._ColorCorrection.ColorCorrection_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/display/ColorCorrection.hx" private="1" module="flash.display.ColorCorrection" extern="1" final="1">
	<DEFAULT public="1" set="null" static="1">
		<x path="flash.display.ColorCorrection"/>
		<meta><m n=":enum"/></meta>
	</DEFAULT>
	<OFF public="1" set="null" static="1">
		<x path="flash.display.ColorCorrection"/>
		<meta><m n=":enum"/></meta>
	</OFF>
	<ON public="1" set="null" static="1">
		<x path="flash.display.ColorCorrection"/>
		<meta><m n=":enum"/></meta>
	</ON>
	<meta>
		<m n=":native"><e>"flash.display.ColorCorrection"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display._ColorCorrection.ColorCorrection_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/display/ColorCorrection.hx" private="1" module="flash.display.ColorCorrection" extern="1" final="1">
		<DEFAULT public="1" set="null" static="1">
			<x path="flash.display.ColorCorrection"/>
			<meta><m n=":enum"/></meta>
		</DEFAULT>
		<OFF public="1" set="null" static="1">
			<x path="flash.display.ColorCorrection"/>
			<meta><m n=":enum"/></meta>
		</OFF>
		<ON public="1" set="null" static="1">
			<x path="flash.display.ColorCorrection"/>
			<meta><m n=":enum"/></meta>
		</ON>
		<meta>
			<m n=":native"><e>"flash.display.ColorCorrection"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="flash.display.ColorCorrectionSupport" params="" file="C:\HaxeToolkit\haxe\std/flash/display/ColorCorrectionSupport.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display.ColorCorrectionSupport"</e></m>
			<m n=":require"><e>flash10_1</e></m>
		</meta>
		<impl><class path="flash.display._ColorCorrectionSupport.ColorCorrectionSupport_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/display/ColorCorrectionSupport.hx" private="1" module="flash.display.ColorCorrectionSupport" extern="1" final="1">
	<DEFAULT_OFF public="1" set="null" static="1">
		<x path="flash.display.ColorCorrectionSupport"/>
		<meta><m n=":enum"/></meta>
	</DEFAULT_OFF>
	<DEFAULT_ON public="1" set="null" static="1">
		<x path="flash.display.ColorCorrectionSupport"/>
		<meta><m n=":enum"/></meta>
	</DEFAULT_ON>
	<UNSUPPORTED public="1" set="null" static="1">
		<x path="flash.display.ColorCorrectionSupport"/>
		<meta><m n=":enum"/></meta>
	</UNSUPPORTED>
	<meta>
		<m n=":native"><e>"flash.display.ColorCorrectionSupport"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display._ColorCorrectionSupport.ColorCorrectionSupport_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/display/ColorCorrectionSupport.hx" private="1" module="flash.display.ColorCorrectionSupport" extern="1" final="1">
		<DEFAULT_OFF public="1" set="null" static="1">
			<x path="flash.display.ColorCorrectionSupport"/>
			<meta><m n=":enum"/></meta>
		</DEFAULT_OFF>
		<DEFAULT_ON public="1" set="null" static="1">
			<x path="flash.display.ColorCorrectionSupport"/>
			<meta><m n=":enum"/></meta>
		</DEFAULT_ON>
		<UNSUPPORTED public="1" set="null" static="1">
			<x path="flash.display.ColorCorrectionSupport"/>
			<meta><m n=":enum"/></meta>
		</UNSUPPORTED>
		<meta>
			<m n=":native"><e>"flash.display.ColorCorrectionSupport"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="flash.display.FrameLabel" params="" file="C:\HaxeToolkit\haxe\std/flash/display/FrameLabel.hx" extern="1" final="1">
		<extends path="flash.events.EventDispatcher"/>
		<frame public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</frame>
		<name public="1" get="accessor" set="null">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</name>
		<get_frame set="method"><f a=""><x path="Int"/></f></get_frame>
		<get_name set="method"><f a=""><c path="String"/></f></get_name>
		<new public="1" set="method"><f a="name:frame">
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<abstract path="flash.display.GradientType" params="" file="C:\HaxeToolkit\haxe\std/flash/display/GradientType.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display.GradientType"</e></m>
		</meta>
		<impl><class path="flash.display._GradientType.GradientType_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/display/GradientType.hx" private="1" module="flash.display.GradientType" extern="1" final="1">
	<LINEAR public="1" set="null" static="1">
		<x path="flash.display.GradientType"/>
		<meta><m n=":enum"/></meta>
	</LINEAR>
	<RADIAL public="1" set="null" static="1">
		<x path="flash.display.GradientType"/>
		<meta><m n=":enum"/></meta>
	</RADIAL>
	<meta>
		<m n=":native"><e>"flash.display.GradientType"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display._GradientType.GradientType_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/display/GradientType.hx" private="1" module="flash.display.GradientType" extern="1" final="1">
		<LINEAR public="1" set="null" static="1">
			<x path="flash.display.GradientType"/>
			<meta><m n=":enum"/></meta>
		</LINEAR>
		<RADIAL public="1" set="null" static="1">
			<x path="flash.display.GradientType"/>
			<meta><m n=":enum"/></meta>
		</RADIAL>
		<meta>
			<m n=":native"><e>"flash.display.GradientType"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="flash.display.Graphics" params="" file="C:\HaxeToolkit\haxe\std/flash/display/Graphics.hx" extern="1" final="1">
		<beginBitmapFill public="1" set="method">
			<f a="bitmap:?matrix:?repeat:?smooth" v="::true:false">
				<c path="flash.display.BitmapData"/>
				<c path="flash.geom.Matrix"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ smooth : false, repeat : true }</e></m></meta>
		</beginBitmapFill>
		<beginFill public="1" set="method">
			<f a="color:?alpha" v=":1">
				<x path="UInt"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ alpha : 1 }</e></m></meta>
		</beginFill>
		<beginGradientFill public="1" set="method">
			<f a="type:colors:alphas:ratios:?matrix:?spreadMethod:?interpolationMethod:?focalPointRatio" v=":::::::0">
				<x path="flash.display.GradientType"/>
				<c path="Array"><x path="UInt"/></c>
				<c path="Array"><d/></c>
				<c path="Array"><d/></c>
				<c path="flash.geom.Matrix"/>
				<x path="flash.display.SpreadMethod"/>
				<x path="flash.display.InterpolationMethod"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ focalPointRatio : 0 }</e></m></meta>
		</beginGradientFill>
		<beginShaderFill public="1" set="method">
			<f a="shader:?matrix">
				<c path="flash.display.Shader"/>
				<c path="flash.geom.Matrix"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</beginShaderFill>
		<clear public="1" set="method"><f a=""><x path="Void"/></f></clear>
		<copyFrom public="1" set="method">
			<f a="sourceGraphics">
				<c path="flash.display.Graphics"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</copyFrom>
		<cubicCurveTo public="1">
			<f a="controlX1:controlY1:controlX2:controlY2:anchorX:anchorY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</cubicCurveTo>
		<curveTo public="1" set="method"><f a="controlX:controlY:anchorX:anchorY">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></curveTo>
		<drawCircle public="1" set="method"><f a="x:y:radius">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawCircle>
		<drawEllipse public="1" set="method"><f a="x:y:width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawEllipse>
		<drawGraphicsData public="1" set="method">
			<f a="graphicsData">
				<c path="flash.Vector"><c path="flash.display.IGraphicsData"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</drawGraphicsData>
		<drawPath public="1" set="method">
			<f a="commands:data:?winding">
				<c path="flash.Vector"><x path="Int"/></c>
				<c path="flash.Vector"><x path="Float"/></c>
				<x path="flash.display.GraphicsPathWinding"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</drawPath>
		<drawRect public="1" set="method"><f a="x:y:width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawRect>
		<drawRoundRect public="1" set="method">
			<f a="x:y:width:height:ellipseWidth:?ellipseHeight" v=":::::0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ ellipseHeight : 0 }</e></m></meta>
		</drawRoundRect>
		<drawRoundRectComplex public="1" set="method"><f a="x:y:width:height:topLeftRadius:topRightRadius:bottomLeftRadius:bottomRightRadius">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawRoundRectComplex>
		<drawTriangles public="1" set="method">
			<f a="vertices:?indices:?uvtData:?culling">
				<c path="flash.Vector"><x path="Float"/></c>
				<c path="flash.Vector"><x path="Int"/></c>
				<c path="flash.Vector"><x path="Float"/></c>
				<x path="flash.display.TriangleCulling"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</drawTriangles>
		<endFill public="1" set="method"><f a=""><x path="Void"/></f></endFill>
		<lineBitmapStyle public="1" set="method">
			<f a="bitmap:?matrix:?repeat:?smooth" v="::true:false">
				<c path="flash.display.BitmapData"/>
				<c path="flash.geom.Matrix"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ smooth : false, repeat : true }</e></m>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</lineBitmapStyle>
		<lineGradientStyle public="1" set="method">
			<f a="type:colors:alphas:ratios:?matrix:?spreadMethod:?interpolationMethod:?focalPointRatio" v=":::::::0">
				<x path="flash.display.GradientType"/>
				<c path="Array"><x path="UInt"/></c>
				<c path="Array"><d/></c>
				<c path="Array"><d/></c>
				<c path="flash.geom.Matrix"/>
				<x path="flash.display.SpreadMethod"/>
				<x path="flash.display.InterpolationMethod"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ focalPointRatio : 0 }</e></m></meta>
		</lineGradientStyle>
		<lineShaderStyle public="1" set="method">
			<f a="shader:?matrix">
				<c path="flash.display.Shader"/>
				<c path="flash.geom.Matrix"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</lineShaderStyle>
		<lineStyle public="1" set="method">
			<f a="?thickness:?color:?alpha:?pixelHinting:?scaleMode:?caps:?joints:?miterLimit" v="0:0:1:false::::3">
				<x path="Float"/>
				<x path="UInt"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="flash.display.LineScaleMode"/>
				<x path="flash.display.CapsStyle"/>
				<x path="flash.display.JointStyle"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ miterLimit : 3, pixelHinting : false, alpha : 1, color : 0, thickness : 0 }</e></m></meta>
		</lineStyle>
		<lineTo public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineTo>
		<moveTo public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></moveTo>
		<readGraphicsData public="1" expr="{ recurse : true }">
			<f a="?recurse">
				<x path="Bool"/>
				<c path="flash.Vector"><c path="flash.display.IGraphicsData"/></c>
			</f>
			<meta>
				<m n=":value"><e>{ recurse : true }</e></m>
				<m n=":require"><e>flash11_6</e></m>
			</meta>
		</readGraphicsData>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<abstract path="flash.display.GraphicsPathWinding" params="" file="C:\HaxeToolkit\haxe\std/flash/display/GraphicsPathWinding.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display.GraphicsPathWinding"</e></m>
		</meta>
		<impl><class path="flash.display._GraphicsPathWinding.GraphicsPathWinding_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/display/GraphicsPathWinding.hx" private="1" module="flash.display.GraphicsPathWinding" extern="1" final="1">
	<EVEN_ODD public="1" set="null" static="1">
		<x path="flash.display.GraphicsPathWinding"/>
		<meta><m n=":enum"/></meta>
	</EVEN_ODD>
	<NON_ZERO public="1" set="null" static="1">
		<x path="flash.display.GraphicsPathWinding"/>
		<meta><m n=":enum"/></meta>
	</NON_ZERO>
	<meta>
		<m n=":native"><e>"flash.display.GraphicsPathWinding"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display._GraphicsPathWinding.GraphicsPathWinding_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/display/GraphicsPathWinding.hx" private="1" module="flash.display.GraphicsPathWinding" extern="1" final="1">
		<EVEN_ODD public="1" set="null" static="1">
			<x path="flash.display.GraphicsPathWinding"/>
			<meta><m n=":enum"/></meta>
		</EVEN_ODD>
		<NON_ZERO public="1" set="null" static="1">
			<x path="flash.display.GraphicsPathWinding"/>
			<meta><m n=":enum"/></meta>
		</NON_ZERO>
		<meta>
			<m n=":native"><e>"flash.display.GraphicsPathWinding"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="flash.display.IGraphicsData" params="" file="C:\HaxeToolkit\haxe\std/flash/display/IGraphicsData.hx" extern="1" interface="1"/>
	<abstract path="flash.display.InterpolationMethod" params="" file="C:\HaxeToolkit\haxe\std/flash/display/InterpolationMethod.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display.InterpolationMethod"</e></m>
		</meta>
		<impl><class path="flash.display._InterpolationMethod.InterpolationMethod_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/display/InterpolationMethod.hx" private="1" module="flash.display.InterpolationMethod" extern="1" final="1">
	<LINEAR_RGB public="1" set="null" static="1">
		<x path="flash.display.InterpolationMethod"/>
		<meta><m n=":enum"/></meta>
	</LINEAR_RGB>
	<RGB public="1" set="null" static="1">
		<x path="flash.display.InterpolationMethod"/>
		<meta><m n=":enum"/></meta>
	</RGB>
	<meta>
		<m n=":native"><e>"flash.display.InterpolationMethod"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display._InterpolationMethod.InterpolationMethod_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/display/InterpolationMethod.hx" private="1" module="flash.display.InterpolationMethod" extern="1" final="1">
		<LINEAR_RGB public="1" set="null" static="1">
			<x path="flash.display.InterpolationMethod"/>
			<meta><m n=":enum"/></meta>
		</LINEAR_RGB>
		<RGB public="1" set="null" static="1">
			<x path="flash.display.InterpolationMethod"/>
			<meta><m n=":enum"/></meta>
		</RGB>
		<meta>
			<m n=":native"><e>"flash.display.InterpolationMethod"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="flash.display.JointStyle" params="" file="C:\HaxeToolkit\haxe\std/flash/display/JointStyle.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display.JointStyle"</e></m>
		</meta>
		<impl><class path="flash.display._JointStyle.JointStyle_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/display/JointStyle.hx" private="1" module="flash.display.JointStyle" extern="1" final="1">
	<BEVEL public="1" set="null" static="1">
		<x path="flash.display.JointStyle"/>
		<meta><m n=":enum"/></meta>
	</BEVEL>
	<MITER public="1" set="null" static="1">
		<x path="flash.display.JointStyle"/>
		<meta><m n=":enum"/></meta>
	</MITER>
	<ROUND public="1" set="null" static="1">
		<x path="flash.display.JointStyle"/>
		<meta><m n=":enum"/></meta>
	</ROUND>
	<meta>
		<m n=":native"><e>"flash.display.JointStyle"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display._JointStyle.JointStyle_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/display/JointStyle.hx" private="1" module="flash.display.JointStyle" extern="1" final="1">
		<BEVEL public="1" set="null" static="1">
			<x path="flash.display.JointStyle"/>
			<meta><m n=":enum"/></meta>
		</BEVEL>
		<MITER public="1" set="null" static="1">
			<x path="flash.display.JointStyle"/>
			<meta><m n=":enum"/></meta>
		</MITER>
		<ROUND public="1" set="null" static="1">
			<x path="flash.display.JointStyle"/>
			<meta><m n=":enum"/></meta>
		</ROUND>
		<meta>
			<m n=":native"><e>"flash.display.JointStyle"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="flash.display.LineScaleMode" params="" file="C:\HaxeToolkit\haxe\std/flash/display/LineScaleMode.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display.LineScaleMode"</e></m>
		</meta>
		<impl><class path="flash.display._LineScaleMode.LineScaleMode_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/display/LineScaleMode.hx" private="1" module="flash.display.LineScaleMode" extern="1" final="1">
	<HORIZONTAL public="1" set="null" static="1">
		<x path="flash.display.LineScaleMode"/>
		<meta><m n=":enum"/></meta>
	</HORIZONTAL>
	<NONE public="1" set="null" static="1">
		<x path="flash.display.LineScaleMode"/>
		<meta><m n=":enum"/></meta>
	</NONE>
	<NORMAL public="1" set="null" static="1">
		<x path="flash.display.LineScaleMode"/>
		<meta><m n=":enum"/></meta>
	</NORMAL>
	<VERTICAL public="1" set="null" static="1">
		<x path="flash.display.LineScaleMode"/>
		<meta><m n=":enum"/></meta>
	</VERTICAL>
	<meta>
		<m n=":native"><e>"flash.display.LineScaleMode"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display._LineScaleMode.LineScaleMode_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/display/LineScaleMode.hx" private="1" module="flash.display.LineScaleMode" extern="1" final="1">
		<HORIZONTAL public="1" set="null" static="1">
			<x path="flash.display.LineScaleMode"/>
			<meta><m n=":enum"/></meta>
		</HORIZONTAL>
		<NONE public="1" set="null" static="1">
			<x path="flash.display.LineScaleMode"/>
			<meta><m n=":enum"/></meta>
		</NONE>
		<NORMAL public="1" set="null" static="1">
			<x path="flash.display.LineScaleMode"/>
			<meta><m n=":enum"/></meta>
		</NORMAL>
		<VERTICAL public="1" set="null" static="1">
			<x path="flash.display.LineScaleMode"/>
			<meta><m n=":enum"/></meta>
		</VERTICAL>
		<meta>
			<m n=":native"><e>"flash.display.LineScaleMode"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="flash.display.Loader" params="" file="C:\HaxeToolkit\haxe\std/flash/display/Loader.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<content public="1" get="accessor" set="null">
			<c path="flash.display.DisplayObject"/>
			<meta><m n=":flash.property"/></meta>
		</content>
		<contentLoaderInfo public="1" get="accessor" set="null">
			<c path="flash.display.LoaderInfo"/>
			<meta><m n=":flash.property"/></meta>
		</contentLoaderInfo>
		<uncaughtErrorEvents public="1">
			<c path="flash.events.UncaughtErrorEvents"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</uncaughtErrorEvents>
		<close public="1" set="method"><f a=""><x path="Void"/></f></close>
		<get_content set="method"><f a=""><c path="flash.display.DisplayObject"/></f></get_content>
		<get_contentLoaderInfo set="method"><f a=""><c path="flash.display.LoaderInfo"/></f></get_contentLoaderInfo>
		<get_uncaughtErrorEvents set="method"><f a=""><c path="flash.events.UncaughtErrorEvents"/></f></get_uncaughtErrorEvents>
		<load public="1" set="method"><f a="request:?context">
	<c path="flash.net.URLRequest"/>
	<c path="flash.system.LoaderContext"/>
	<x path="Void"/>
</f></load>
		<loadBytes public="1" set="method"><f a="bytes:?context">
	<c path="flash.utils.ByteArray"/>
	<c path="flash.system.LoaderContext"/>
	<x path="Void"/>
</f></loadBytes>
		<unload public="1" set="method"><f a=""><x path="Void"/></f></unload>
		<unloadAndStop public="1" set="method">
			<f a="?gc" v="true">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ gc : true }</e></m>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</unloadAndStop>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.display.LoaderInfo" params="" file="C:\HaxeToolkit\haxe\std/flash/display/LoaderInfo.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<getLoaderInfoByDefinition public="1" set="method" static="1"><f a="object">
	<d/>
	<c path="flash.display.LoaderInfo"/>
</f></getLoaderInfoByDefinition>
		<actionScriptVersion public="1" get="accessor" set="null">
			<x path="flash.display.ActionScriptVersion"/>
			<meta><m n=":flash.property"/></meta>
		</actionScriptVersion>
		<applicationDomain public="1" get="accessor" set="null">
			<c path="flash.system.ApplicationDomain"/>
			<meta><m n=":flash.property"/></meta>
		</applicationDomain>
		<bytes public="1" get="accessor" set="null">
			<c path="flash.utils.ByteArray"/>
			<meta><m n=":flash.property"/></meta>
		</bytes>
		<bytesLoaded public="1" get="accessor" set="null">
			<x path="UInt"/>
			<meta><m n=":flash.property"/></meta>
		</bytesLoaded>
		<bytesTotal public="1" get="accessor" set="null">
			<x path="UInt"/>
			<meta><m n=":flash.property"/></meta>
		</bytesTotal>
		<childAllowsParent public="1" get="accessor" set="null">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</childAllowsParent>
		<childSandboxBridge public="1">
			<d/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash11_4</e></m>
			</meta>
		</childSandboxBridge>
		<content public="1" get="accessor" set="null">
			<c path="flash.display.DisplayObject"/>
			<meta><m n=":flash.property"/></meta>
		</content>
		<contentType public="1" get="accessor" set="null">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</contentType>
		<frameRate public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</frameRate>
		<height public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</height>
		<isURLInaccessible public="1">
			<x path="Bool"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</isURLInaccessible>
		<loader public="1" get="accessor" set="null">
			<c path="flash.display.Loader"/>
			<meta><m n=":flash.property"/></meta>
		</loader>
		<loaderURL public="1" get="accessor" set="null">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</loaderURL>
		<parameters public="1" get="accessor" set="null">
			<d><c path="String"/></d>
			<meta><m n=":flash.property"/></meta>
		</parameters>
		<parentAllowsChild public="1" get="accessor" set="null">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</parentAllowsChild>
		<parentSandboxBridge public="1">
			<d/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash11_4</e></m>
			</meta>
		</parentSandboxBridge>
		<sameDomain public="1" get="accessor" set="null">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</sameDomain>
		<sharedEvents public="1" get="accessor" set="null">
			<c path="flash.events.EventDispatcher"/>
			<meta><m n=":flash.property"/></meta>
		</sharedEvents>
		<swfVersion public="1" get="accessor" set="null">
			<x path="UInt"/>
			<meta><m n=":flash.property"/></meta>
		</swfVersion>
		<uncaughtErrorEvents public="1">
			<c path="flash.events.UncaughtErrorEvents"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</uncaughtErrorEvents>
		<url public="1" get="accessor" set="null">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</url>
		<width public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</width>
		<get_actionScriptVersion set="method"><f a=""><x path="flash.display.ActionScriptVersion"/></f></get_actionScriptVersion>
		<get_applicationDomain set="method"><f a=""><c path="flash.system.ApplicationDomain"/></f></get_applicationDomain>
		<get_bytes set="method"><f a=""><c path="flash.utils.ByteArray"/></f></get_bytes>
		<get_bytesLoaded set="method"><f a=""><x path="UInt"/></f></get_bytesLoaded>
		<get_bytesTotal set="method"><f a=""><x path="UInt"/></f></get_bytesTotal>
		<get_childAllowsParent set="method"><f a=""><x path="Bool"/></f></get_childAllowsParent>
		<get_childSandboxBridge set="method"><f a=""><d/></f></get_childSandboxBridge>
		<get_content set="method"><f a=""><c path="flash.display.DisplayObject"/></f></get_content>
		<get_contentType set="method"><f a=""><c path="String"/></f></get_contentType>
		<get_frameRate set="method"><f a=""><x path="Float"/></f></get_frameRate>
		<get_height set="method"><f a=""><x path="Int"/></f></get_height>
		<get_isURLInaccessible set="method"><f a=""><x path="Bool"/></f></get_isURLInaccessible>
		<get_loader set="method"><f a=""><c path="flash.display.Loader"/></f></get_loader>
		<get_loaderURL set="method"><f a=""><c path="String"/></f></get_loaderURL>
		<get_parameters set="method"><f a=""><d><c path="String"/></d></f></get_parameters>
		<get_parentAllowsChild set="method"><f a=""><x path="Bool"/></f></get_parentAllowsChild>
		<get_parentSandboxBridge set="method"><f a=""><d/></f></get_parentSandboxBridge>
		<get_sameDomain set="method"><f a=""><x path="Bool"/></f></get_sameDomain>
		<get_sharedEvents set="method"><f a=""><c path="flash.events.EventDispatcher"/></f></get_sharedEvents>
		<get_swfVersion set="method"><f a=""><x path="UInt"/></f></get_swfVersion>
		<get_uncaughtErrorEvents set="method"><f a=""><c path="flash.events.UncaughtErrorEvents"/></f></get_uncaughtErrorEvents>
		<get_url set="method"><f a=""><c path="String"/></f></get_url>
		<get_width set="method"><f a=""><x path="Int"/></f></get_width>
		<set_childSandboxBridge set="method"><f a="value">
	<d/>
	<d/>
</f></set_childSandboxBridge>
		<set_parentSandboxBridge set="method"><f a="value">
	<d/>
	<d/>
</f></set_parentSandboxBridge>
	</class>
	<class path="flash.display.NativeMenu" params="" file="C:\HaxeToolkit\haxe\std/flash/display/NativeMenu.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<new public="1"><f a=""><x path="Void"/></f></new>
		<meta><m n=":require"><e>flash10_1</e></m></meta>
	</class>
	<class path="flash.display.Scene" params="" file="C:\HaxeToolkit\haxe\std/flash/display/Scene.hx" extern="1" final="1">
		<labels public="1" get="accessor" set="null">
			<c path="Array"><c path="flash.display.FrameLabel"/></c>
			<meta><m n=":flash.property"/></meta>
		</labels>
		<name public="1" get="accessor" set="null">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</name>
		<numFrames public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</numFrames>
		<get_labels set="method"><f a=""><c path="Array"><c path="flash.display.FrameLabel"/></c></f></get_labels>
		<get_name set="method"><f a=""><c path="String"/></f></get_name>
		<get_numFrames set="method"><f a=""><x path="Int"/></f></get_numFrames>
		<new public="1" set="method"><f a="name:labels:numFrames">
	<c path="String"/>
	<c path="Array"><c path="flash.display.FrameLabel"/></c>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.display.Shader" params="" file="C:\HaxeToolkit\haxe\std/flash/display/Shader.hx" extern="1">
		<byteCode public="1" get="null" set="accessor">
			<c path="flash.utils.ByteArray"/>
			<meta><m n=":flash.property"/></meta>
		</byteCode>
		<data public="1" get="accessor" set="accessor">
			<c path="flash.display.ShaderData"/>
			<meta><m n=":flash.property"/></meta>
		</data>
		<precisionHint public="1" get="accessor" set="accessor">
			<x path="flash.display.ShaderPrecision"/>
			<meta><m n=":flash.property"/></meta>
		</precisionHint>
		<get_data set="method"><f a=""><c path="flash.display.ShaderData"/></f></get_data>
		<get_precisionHint set="method"><f a=""><x path="flash.display.ShaderPrecision"/></f></get_precisionHint>
		<set_byteCode set="method"><f a="value">
	<c path="flash.utils.ByteArray"/>
	<c path="flash.utils.ByteArray"/>
</f></set_byteCode>
		<set_data set="method"><f a="value">
	<c path="flash.display.ShaderData"/>
	<c path="flash.display.ShaderData"/>
</f></set_data>
		<set_precisionHint set="method"><f a="value">
	<x path="flash.display.ShaderPrecision"/>
	<x path="flash.display.ShaderPrecision"/>
</f></set_precisionHint>
		<new public="1" set="method"><f a="?code">
	<c path="flash.utils.ByteArray"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<class path="flash.display.ShaderData" params="" file="C:\HaxeToolkit\haxe\std/flash/display/ShaderData.hx" extern="1"><new public="1" set="method"><f a="byteCode">
	<c path="flash.utils.ByteArray"/>
	<x path="Void"/>
</f></new></class>
	<abstract path="flash.display.ShaderPrecision" params="" file="C:\HaxeToolkit\haxe\std/flash/display/ShaderPrecision.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display.ShaderPrecision"</e></m>
		</meta>
		<impl><class path="flash.display._ShaderPrecision.ShaderPrecision_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/display/ShaderPrecision.hx" private="1" module="flash.display.ShaderPrecision" extern="1" final="1">
	<FAST public="1" set="null" static="1">
		<x path="flash.display.ShaderPrecision"/>
		<meta><m n=":enum"/></meta>
	</FAST>
	<FULL public="1" set="null" static="1">
		<x path="flash.display.ShaderPrecision"/>
		<meta><m n=":enum"/></meta>
	</FULL>
	<meta>
		<m n=":native"><e>"flash.display.ShaderPrecision"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display._ShaderPrecision.ShaderPrecision_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/display/ShaderPrecision.hx" private="1" module="flash.display.ShaderPrecision" extern="1" final="1">
		<FAST public="1" set="null" static="1">
			<x path="flash.display.ShaderPrecision"/>
			<meta><m n=":enum"/></meta>
		</FAST>
		<FULL public="1" set="null" static="1">
			<x path="flash.display.ShaderPrecision"/>
			<meta><m n=":enum"/></meta>
		</FULL>
		<meta>
			<m n=":native"><e>"flash.display.ShaderPrecision"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="flash.display.SpreadMethod" params="" file="C:\HaxeToolkit\haxe\std/flash/display/SpreadMethod.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display.SpreadMethod"</e></m>
		</meta>
		<impl><class path="flash.display._SpreadMethod.SpreadMethod_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/display/SpreadMethod.hx" private="1" module="flash.display.SpreadMethod" extern="1" final="1">
	<PAD public="1" set="null" static="1">
		<x path="flash.display.SpreadMethod"/>
		<meta><m n=":enum"/></meta>
	</PAD>
	<REFLECT public="1" set="null" static="1">
		<x path="flash.display.SpreadMethod"/>
		<meta><m n=":enum"/></meta>
	</REFLECT>
	<REPEAT public="1" set="null" static="1">
		<x path="flash.display.SpreadMethod"/>
		<meta><m n=":enum"/></meta>
	</REPEAT>
	<meta>
		<m n=":native"><e>"flash.display.SpreadMethod"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display._SpreadMethod.SpreadMethod_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/display/SpreadMethod.hx" private="1" module="flash.display.SpreadMethod" extern="1" final="1">
		<PAD public="1" set="null" static="1">
			<x path="flash.display.SpreadMethod"/>
			<meta><m n=":enum"/></meta>
		</PAD>
		<REFLECT public="1" set="null" static="1">
			<x path="flash.display.SpreadMethod"/>
			<meta><m n=":enum"/></meta>
		</REFLECT>
		<REPEAT public="1" set="null" static="1">
			<x path="flash.display.SpreadMethod"/>
			<meta><m n=":enum"/></meta>
		</REPEAT>
		<meta>
			<m n=":native"><e>"flash.display.SpreadMethod"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="flash.display.Stage" params="" file="C:\HaxeToolkit\haxe\std/flash/display/Stage.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<align public="1" get="accessor" set="accessor">
			<x path="flash.display.StageAlign"/>
			<meta><m n=":flash.property"/></meta>
		</align>
		<allowsFullScreen public="1" get="accessor" set="null">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</allowsFullScreen>
		<allowsFullScreenInteractive public="1">
			<x path="Bool"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash11_3</e></m>
			</meta>
		</allowsFullScreenInteractive>
		<browserZoomFactor public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</browserZoomFactor>
		<color public="1">
			<x path="UInt"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_2</e></m>
			</meta>
		</color>
		<colorCorrection public="1" get="accessor" set="accessor">
			<x path="flash.display.ColorCorrection"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</colorCorrection>
		<colorCorrectionSupport public="1" get="accessor" set="null">
			<x path="flash.display.ColorCorrectionSupport"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</colorCorrectionSupport>
		<contentsScaleFactor public="1">
			<x path="Float"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash11_4</e></m>
			</meta>
		</contentsScaleFactor>
		<displayContextInfo public="1">
			<c path="String"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash11</e></m>
			</meta>
		</displayContextInfo>
		<displayState public="1" get="accessor" set="accessor">
			<x path="flash.display.StageDisplayState"/>
			<meta><m n=":flash.property"/></meta>
		</displayState>
		<focus public="1" get="accessor" set="accessor">
			<c path="flash.display.InteractiveObject"/>
			<meta><m n=":flash.property"/></meta>
		</focus>
		<frameRate public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</frameRate>
		<fullScreenHeight public="1" get="accessor" set="null">
			<x path="UInt"/>
			<meta><m n=":flash.property"/></meta>
		</fullScreenHeight>
		<fullScreenSourceRect public="1" get="accessor" set="accessor">
			<c path="flash.geom.Rectangle"/>
			<meta><m n=":flash.property"/></meta>
		</fullScreenSourceRect>
		<fullScreenWidth public="1" get="accessor" set="null">
			<x path="UInt"/>
			<meta><m n=":flash.property"/></meta>
		</fullScreenWidth>
		<mouseLock public="1">
			<x path="Bool"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash11_2</e></m>
			</meta>
		</mouseLock>
		<quality public="1" get="accessor" set="accessor">
			<x path="flash.display.StageQuality"/>
			<meta><m n=":flash.property"/></meta>
		</quality>
		<scaleMode public="1" get="accessor" set="accessor">
			<x path="flash.display.StageScaleMode"/>
			<meta><m n=":flash.property"/></meta>
		</scaleMode>
		<showDefaultContextMenu public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</showDefaultContextMenu>
		<softKeyboardRect public="1">
			<c path="flash.geom.Rectangle"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash11</e></m>
			</meta>
		</softKeyboardRect>
		<stage3Ds public="1">
			<c path="flash.Vector"><c path="flash.display.Stage3D"/></c>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash11</e></m>
			</meta>
		</stage3Ds>
		<stageFocusRect public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</stageFocusRect>
		<stageHeight public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</stageHeight>
		<stageVideos public="1">
			<c path="flash.Vector"><c path="flash.media.StageVideo"/></c>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_2</e></m>
			</meta>
		</stageVideos>
		<stageWidth public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</stageWidth>
		<wmodeGPU public="1">
			<x path="Bool"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</wmodeGPU>
		<get_align set="method"><f a=""><x path="flash.display.StageAlign"/></f></get_align>
		<get_allowsFullScreen set="method"><f a=""><x path="Bool"/></f></get_allowsFullScreen>
		<get_allowsFullScreenInteractive set="method"><f a=""><x path="Bool"/></f></get_allowsFullScreenInteractive>
		<get_browserZoomFactor set="method"><f a=""><x path="Float"/></f></get_browserZoomFactor>
		<get_color set="method"><f a=""><x path="UInt"/></f></get_color>
		<get_colorCorrection set="method"><f a=""><x path="flash.display.ColorCorrection"/></f></get_colorCorrection>
		<get_colorCorrectionSupport set="method"><f a=""><x path="flash.display.ColorCorrectionSupport"/></f></get_colorCorrectionSupport>
		<get_constructor set="method"><f a=""><d/></f></get_constructor>
		<get_contentsScaleFactor set="method"><f a=""><x path="Float"/></f></get_contentsScaleFactor>
		<get_displayContextInfo set="method"><f a=""><c path="String"/></f></get_displayContextInfo>
		<get_displayState set="method"><f a=""><x path="flash.display.StageDisplayState"/></f></get_displayState>
		<get_focus set="method"><f a=""><c path="flash.display.InteractiveObject"/></f></get_focus>
		<get_frameRate set="method"><f a=""><x path="Float"/></f></get_frameRate>
		<get_fullScreenHeight set="method"><f a=""><x path="UInt"/></f></get_fullScreenHeight>
		<get_fullScreenSourceRect set="method"><f a=""><c path="flash.geom.Rectangle"/></f></get_fullScreenSourceRect>
		<get_fullScreenWidth set="method"><f a=""><x path="UInt"/></f></get_fullScreenWidth>
		<get_mouseLock set="method"><f a=""><x path="Bool"/></f></get_mouseLock>
		<get_quality set="method"><f a=""><x path="flash.display.StageQuality"/></f></get_quality>
		<get_scaleMode set="method"><f a=""><x path="flash.display.StageScaleMode"/></f></get_scaleMode>
		<get_showDefaultContextMenu set="method"><f a=""><x path="Bool"/></f></get_showDefaultContextMenu>
		<get_softKeyboardRect set="method"><f a=""><c path="flash.geom.Rectangle"/></f></get_softKeyboardRect>
		<get_stage3Ds set="method"><f a=""><c path="flash.Vector"><c path="flash.display.Stage3D"/></c></f></get_stage3Ds>
		<get_stageFocusRect set="method"><f a=""><x path="Bool"/></f></get_stageFocusRect>
		<get_stageHeight set="method"><f a=""><x path="Int"/></f></get_stageHeight>
		<get_stageVideos set="method"><f a=""><c path="flash.Vector"><c path="flash.media.StageVideo"/></c></f></get_stageVideos>
		<get_stageWidth set="method"><f a=""><x path="Int"/></f></get_stageWidth>
		<get_wmodeGPU set="method"><f a=""><x path="Bool"/></f></get_wmodeGPU>
		<invalidate public="1" set="method"><f a=""><x path="Void"/></f></invalidate>
		<isFocusInaccessible public="1" set="method"><f a=""><x path="Bool"/></f></isFocusInaccessible>
		<set_align set="method"><f a="value">
	<x path="flash.display.StageAlign"/>
	<x path="flash.display.StageAlign"/>
</f></set_align>
		<set_color set="method"><f a="value">
	<x path="UInt"/>
	<x path="UInt"/>
</f></set_color>
		<set_colorCorrection set="method"><f a="value">
	<x path="flash.display.ColorCorrection"/>
	<x path="flash.display.ColorCorrection"/>
</f></set_colorCorrection>
		<set_constructor set="method"><f a="value">
	<d/>
	<d/>
</f></set_constructor>
		<set_displayState set="method"><f a="value">
	<x path="flash.display.StageDisplayState"/>
	<x path="flash.display.StageDisplayState"/>
</f></set_displayState>
		<set_focus set="method"><f a="value">
	<c path="flash.display.InteractiveObject"/>
	<c path="flash.display.InteractiveObject"/>
</f></set_focus>
		<set_frameRate set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_frameRate>
		<set_fullScreenSourceRect set="method"><f a="value">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
</f></set_fullScreenSourceRect>
		<set_mouseLock set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_mouseLock>
		<set_quality set="method"><f a="value">
	<x path="flash.display.StageQuality"/>
	<x path="flash.display.StageQuality"/>
</f></set_quality>
		<set_scaleMode set="method"><f a="value">
	<x path="flash.display.StageScaleMode"/>
	<x path="flash.display.StageScaleMode"/>
</f></set_scaleMode>
		<set_showDefaultContextMenu set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_showDefaultContextMenu>
		<set_stageFocusRect set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_stageFocusRect>
		<set_stageHeight set="method"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_stageHeight>
		<set_stageWidth set="method"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_stageWidth>
	</class>
	<class path="flash.display.Stage3D" params="" file="C:\HaxeToolkit\haxe\std/flash/display/Stage3D.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<context3D public="1" get="accessor" set="null">
			<c path="flash.display3D.Context3D"/>
			<meta><m n=":flash.property"/></meta>
		</context3D>
		<visible public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</visible>
		<x public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</x>
		<y public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</y>
		<get_context3D set="method"><f a=""><c path="flash.display3D.Context3D"/></f></get_context3D>
		<get_visible set="method"><f a=""><x path="Bool"/></f></get_visible>
		<get_x set="method"><f a=""><x path="Float"/></f></get_x>
		<get_y set="method"><f a=""><x path="Float"/></f></get_y>
		<requestContext3D public="1" set="method"><f a="?context3DRenderMode:?profile">
	<c path="String"/>
	<x path="flash.display3D.Context3DProfile"/>
	<x path="Void"/>
</f></requestContext3D>
		<requestContext3DMatchingProfiles public="1">
			<f a="profiles">
				<c path="flash.Vector"><c path="String"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash12</e></m></meta>
		</requestContext3DMatchingProfiles>
		<set_visible set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_visible>
		<set_x set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<set_y set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<meta><m n=":require"><e>flash11</e></m></meta>
	</class>
	<abstract path="flash.display.StageAlign" params="" file="C:\HaxeToolkit\haxe\std/flash/display/StageAlign.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display.StageAlign"</e></m>
		</meta>
		<impl><class path="flash.display._StageAlign.StageAlign_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/display/StageAlign.hx" private="1" module="flash.display.StageAlign" extern="1" final="1">
	<BOTTOM public="1" set="null" static="1">
		<x path="flash.display.StageAlign"/>
		<meta><m n=":enum"/></meta>
	</BOTTOM>
	<BOTTOM_LEFT public="1" set="null" static="1">
		<x path="flash.display.StageAlign"/>
		<meta><m n=":enum"/></meta>
	</BOTTOM_LEFT>
	<BOTTOM_RIGHT public="1" set="null" static="1">
		<x path="flash.display.StageAlign"/>
		<meta><m n=":enum"/></meta>
	</BOTTOM_RIGHT>
	<LEFT public="1" set="null" static="1">
		<x path="flash.display.StageAlign"/>
		<meta><m n=":enum"/></meta>
	</LEFT>
	<RIGHT public="1" set="null" static="1">
		<x path="flash.display.StageAlign"/>
		<meta><m n=":enum"/></meta>
	</RIGHT>
	<TOP public="1" set="null" static="1">
		<x path="flash.display.StageAlign"/>
		<meta><m n=":enum"/></meta>
	</TOP>
	<TOP_LEFT public="1" set="null" static="1">
		<x path="flash.display.StageAlign"/>
		<meta><m n=":enum"/></meta>
	</TOP_LEFT>
	<TOP_RIGHT public="1" set="null" static="1">
		<x path="flash.display.StageAlign"/>
		<meta><m n=":enum"/></meta>
	</TOP_RIGHT>
	<meta>
		<m n=":native"><e>"flash.display.StageAlign"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display._StageAlign.StageAlign_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/display/StageAlign.hx" private="1" module="flash.display.StageAlign" extern="1" final="1">
		<BOTTOM public="1" set="null" static="1">
			<x path="flash.display.StageAlign"/>
			<meta><m n=":enum"/></meta>
		</BOTTOM>
		<BOTTOM_LEFT public="1" set="null" static="1">
			<x path="flash.display.StageAlign"/>
			<meta><m n=":enum"/></meta>
		</BOTTOM_LEFT>
		<BOTTOM_RIGHT public="1" set="null" static="1">
			<x path="flash.display.StageAlign"/>
			<meta><m n=":enum"/></meta>
		</BOTTOM_RIGHT>
		<LEFT public="1" set="null" static="1">
			<x path="flash.display.StageAlign"/>
			<meta><m n=":enum"/></meta>
		</LEFT>
		<RIGHT public="1" set="null" static="1">
			<x path="flash.display.StageAlign"/>
			<meta><m n=":enum"/></meta>
		</RIGHT>
		<TOP public="1" set="null" static="1">
			<x path="flash.display.StageAlign"/>
			<meta><m n=":enum"/></meta>
		</TOP>
		<TOP_LEFT public="1" set="null" static="1">
			<x path="flash.display.StageAlign"/>
			<meta><m n=":enum"/></meta>
		</TOP_LEFT>
		<TOP_RIGHT public="1" set="null" static="1">
			<x path="flash.display.StageAlign"/>
			<meta><m n=":enum"/></meta>
		</TOP_RIGHT>
		<meta>
			<m n=":native"><e>"flash.display.StageAlign"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="flash.display.StageDisplayState" params="" file="C:\HaxeToolkit\haxe\std/flash/display/StageDisplayState.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display.StageDisplayState"</e></m>
		</meta>
		<impl><class path="flash.display._StageDisplayState.StageDisplayState_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/display/StageDisplayState.hx" private="1" module="flash.display.StageDisplayState" extern="1" final="1">
	<FULL_SCREEN public="1" set="null" static="1">
		<x path="flash.display.StageDisplayState"/>
		<meta><m n=":enum"/></meta>
	</FULL_SCREEN>
	<FULL_SCREEN_INTERACTIVE public="1" set="null" static="1">
		<x path="flash.display.StageDisplayState"/>
		<meta><m n=":enum"/></meta>
	</FULL_SCREEN_INTERACTIVE>
	<NORMAL public="1" set="null" static="1">
		<x path="flash.display.StageDisplayState"/>
		<meta><m n=":enum"/></meta>
	</NORMAL>
	<meta>
		<m n=":native"><e>"flash.display.StageDisplayState"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display._StageDisplayState.StageDisplayState_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/display/StageDisplayState.hx" private="1" module="flash.display.StageDisplayState" extern="1" final="1">
		<FULL_SCREEN public="1" set="null" static="1">
			<x path="flash.display.StageDisplayState"/>
			<meta><m n=":enum"/></meta>
		</FULL_SCREEN>
		<FULL_SCREEN_INTERACTIVE public="1" set="null" static="1">
			<x path="flash.display.StageDisplayState"/>
			<meta><m n=":enum"/></meta>
		</FULL_SCREEN_INTERACTIVE>
		<NORMAL public="1" set="null" static="1">
			<x path="flash.display.StageDisplayState"/>
			<meta><m n=":enum"/></meta>
		</NORMAL>
		<meta>
			<m n=":native"><e>"flash.display.StageDisplayState"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="flash.display.StageQuality" params="" file="C:\HaxeToolkit\haxe\std/flash/display/StageQuality.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display.StageQuality"</e></m>
		</meta>
		<impl><class path="flash.display._StageQuality.StageQuality_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/display/StageQuality.hx" private="1" module="flash.display.StageQuality" extern="1" final="1">
	<BEST public="1" set="null" static="1">
		<x path="flash.display.StageQuality"/>
		<meta><m n=":enum"/></meta>
	</BEST>
	<HIGH public="1" set="null" static="1">
		<x path="flash.display.StageQuality"/>
		<meta><m n=":enum"/></meta>
	</HIGH>
	<HIGH_16X16 public="1" set="null" static="1">
		<x path="flash.display.StageQuality"/>
		<meta><m n=":enum"/></meta>
	</HIGH_16X16>
	<HIGH_16X16_LINEAR public="1" set="null" static="1">
		<x path="flash.display.StageQuality"/>
		<meta><m n=":enum"/></meta>
	</HIGH_16X16_LINEAR>
	<HIGH_8X8 public="1" set="null" static="1">
		<x path="flash.display.StageQuality"/>
		<meta><m n=":enum"/></meta>
	</HIGH_8X8>
	<HIGH_8X8_LINEAR public="1" set="null" static="1">
		<x path="flash.display.StageQuality"/>
		<meta><m n=":enum"/></meta>
	</HIGH_8X8_LINEAR>
	<LOW public="1" set="null" static="1">
		<x path="flash.display.StageQuality"/>
		<meta><m n=":enum"/></meta>
	</LOW>
	<MEDIUM public="1" set="null" static="1">
		<x path="flash.display.StageQuality"/>
		<meta><m n=":enum"/></meta>
	</MEDIUM>
	<meta>
		<m n=":native"><e>"flash.display.StageQuality"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display._StageQuality.StageQuality_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/display/StageQuality.hx" private="1" module="flash.display.StageQuality" extern="1" final="1">
		<BEST public="1" set="null" static="1">
			<x path="flash.display.StageQuality"/>
			<meta><m n=":enum"/></meta>
		</BEST>
		<HIGH public="1" set="null" static="1">
			<x path="flash.display.StageQuality"/>
			<meta><m n=":enum"/></meta>
		</HIGH>
		<HIGH_16X16 public="1" set="null" static="1">
			<x path="flash.display.StageQuality"/>
			<meta><m n=":enum"/></meta>
		</HIGH_16X16>
		<HIGH_16X16_LINEAR public="1" set="null" static="1">
			<x path="flash.display.StageQuality"/>
			<meta><m n=":enum"/></meta>
		</HIGH_16X16_LINEAR>
		<HIGH_8X8 public="1" set="null" static="1">
			<x path="flash.display.StageQuality"/>
			<meta><m n=":enum"/></meta>
		</HIGH_8X8>
		<HIGH_8X8_LINEAR public="1" set="null" static="1">
			<x path="flash.display.StageQuality"/>
			<meta><m n=":enum"/></meta>
		</HIGH_8X8_LINEAR>
		<LOW public="1" set="null" static="1">
			<x path="flash.display.StageQuality"/>
			<meta><m n=":enum"/></meta>
		</LOW>
		<MEDIUM public="1" set="null" static="1">
			<x path="flash.display.StageQuality"/>
			<meta><m n=":enum"/></meta>
		</MEDIUM>
		<meta>
			<m n=":native"><e>"flash.display.StageQuality"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="flash.display.StageScaleMode" params="" file="C:\HaxeToolkit\haxe\std/flash/display/StageScaleMode.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display.StageScaleMode"</e></m>
		</meta>
		<impl><class path="flash.display._StageScaleMode.StageScaleMode_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/display/StageScaleMode.hx" private="1" module="flash.display.StageScaleMode" extern="1" final="1">
	<EXACT_FIT public="1" set="null" static="1">
		<x path="flash.display.StageScaleMode"/>
		<meta><m n=":enum"/></meta>
	</EXACT_FIT>
	<NO_BORDER public="1" set="null" static="1">
		<x path="flash.display.StageScaleMode"/>
		<meta><m n=":enum"/></meta>
	</NO_BORDER>
	<NO_SCALE public="1" set="null" static="1">
		<x path="flash.display.StageScaleMode"/>
		<meta><m n=":enum"/></meta>
	</NO_SCALE>
	<SHOW_ALL public="1" set="null" static="1">
		<x path="flash.display.StageScaleMode"/>
		<meta><m n=":enum"/></meta>
	</SHOW_ALL>
	<meta>
		<m n=":native"><e>"flash.display.StageScaleMode"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display._StageScaleMode.StageScaleMode_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/display/StageScaleMode.hx" private="1" module="flash.display.StageScaleMode" extern="1" final="1">
		<EXACT_FIT public="1" set="null" static="1">
			<x path="flash.display.StageScaleMode"/>
			<meta><m n=":enum"/></meta>
		</EXACT_FIT>
		<NO_BORDER public="1" set="null" static="1">
			<x path="flash.display.StageScaleMode"/>
			<meta><m n=":enum"/></meta>
		</NO_BORDER>
		<NO_SCALE public="1" set="null" static="1">
			<x path="flash.display.StageScaleMode"/>
			<meta><m n=":enum"/></meta>
		</NO_SCALE>
		<SHOW_ALL public="1" set="null" static="1">
			<x path="flash.display.StageScaleMode"/>
			<meta><m n=":enum"/></meta>
		</SHOW_ALL>
		<meta>
			<m n=":native"><e>"flash.display.StageScaleMode"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="flash.display.TriangleCulling" params="" file="C:\HaxeToolkit\haxe\std/flash/display/TriangleCulling.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display.TriangleCulling"</e></m>
		</meta>
		<impl><class path="flash.display._TriangleCulling.TriangleCulling_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/display/TriangleCulling.hx" private="1" module="flash.display.TriangleCulling" extern="1" final="1">
	<NEGATIVE public="1" set="null" static="1">
		<x path="flash.display.TriangleCulling"/>
		<meta><m n=":enum"/></meta>
	</NEGATIVE>
	<NONE public="1" set="null" static="1">
		<x path="flash.display.TriangleCulling"/>
		<meta><m n=":enum"/></meta>
	</NONE>
	<POSITIVE public="1" set="null" static="1">
		<x path="flash.display.TriangleCulling"/>
		<meta><m n=":enum"/></meta>
	</POSITIVE>
	<meta>
		<m n=":native"><e>"flash.display.TriangleCulling"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display._TriangleCulling.TriangleCulling_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/display/TriangleCulling.hx" private="1" module="flash.display.TriangleCulling" extern="1" final="1">
		<NEGATIVE public="1" set="null" static="1">
			<x path="flash.display.TriangleCulling"/>
			<meta><m n=":enum"/></meta>
		</NEGATIVE>
		<NONE public="1" set="null" static="1">
			<x path="flash.display.TriangleCulling"/>
			<meta><m n=":enum"/></meta>
		</NONE>
		<POSITIVE public="1" set="null" static="1">
			<x path="flash.display.TriangleCulling"/>
			<meta><m n=":enum"/></meta>
		</POSITIVE>
		<meta>
			<m n=":native"><e>"flash.display.TriangleCulling"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="flash.display3D.Context3D" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/Context3D.hx" extern="1" final="1">
		<extends path="flash.events.EventDispatcher"/>
		<supportsVideoTexture public="1" get="accessor" set="null" static="1">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</supportsVideoTexture>
		<get_supportsVideoTexture set="method" static="1"><f a=""><x path="Bool"/></f></get_supportsVideoTexture>
		<backBufferHeight public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</backBufferHeight>
		<backBufferWidth public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</backBufferWidth>
		<driverInfo public="1" get="accessor" set="null">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</driverInfo>
		<enableErrorChecking public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</enableErrorChecking>
		<maxBackBufferHeight public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</maxBackBufferHeight>
		<maxBackBufferWidth public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</maxBackBufferWidth>
		<profile public="1">
			<c path="String"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash12</e></m>
			</meta>
		</profile>
		<totalGPUMemory public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</totalGPUMemory>
		<clear public="1" set="method">
			<f a="?red:?green:?blue:?alpha:?depth:?stencil:?mask" v="0:0:0:1:1:0:0xFFFFFFFF">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ mask : 0xFFFFFFFF, stencil : 0, depth : 1, alpha : 1, blue : 0, green : 0, red : 0 }</e></m></meta>
		</clear>
		<configureBackBuffer public="1" set="method">
			<f a="width:height:antiAlias:?enableDepthAndStencil:?wantsBestResolution:?wantsBestResolutionOnBrowserZoom" v=":::true:false:false">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ wantsBestResolutionOnBrowserZoom : false, wantsBestResolution : false, enableDepthAndStencil : true }</e></m></meta>
		</configureBackBuffer>
		<createCubeTexture public="1" set="method">
			<f a="size:format:optimizeForRenderToTexture:?streamingLevels" v=":::0">
				<x path="Int"/>
				<x path="flash.display3D.Context3DTextureFormat"/>
				<x path="Bool"/>
				<x path="Int"/>
				<c path="flash.display3D.textures.CubeTexture"/>
			</f>
			<meta><m n=":value"><e>{ streamingLevels : 0 }</e></m></meta>
		</createCubeTexture>
		<createIndexBuffer public="1" set="method"><f a="numIndices:?bufferUsage">
	<x path="Int"/>
	<x path="flash.display3D.Context3DBufferUsage"/>
	<c path="flash.display3D.IndexBuffer3D"/>
</f></createIndexBuffer>
		<createProgram public="1" set="method"><f a=""><c path="flash.display3D.Program3D"/></f></createProgram>
		<createRectangleTexture public="1">
			<f a="width:height:format:optimizeForRenderToTexture">
				<x path="Int"/>
				<x path="Int"/>
				<x path="flash.display3D.Context3DTextureFormat"/>
				<x path="Bool"/>
				<c path="flash.display3D.textures.RectangleTexture"/>
			</f>
			<meta><m n=":require"><e>flash11_8</e></m></meta>
		</createRectangleTexture>
		<createTexture public="1" set="method">
			<f a="width:height:format:optimizeForRenderToTexture:?streamingLevels" v="::::0">
				<x path="Int"/>
				<x path="Int"/>
				<x path="flash.display3D.Context3DTextureFormat"/>
				<x path="Bool"/>
				<x path="Int"/>
				<c path="flash.display3D.textures.Texture"/>
			</f>
			<meta><m n=":value"><e>{ streamingLevels : 0 }</e></m></meta>
		</createTexture>
		<createVertexBuffer public="1" set="method"><f a="numVertices:data32PerVertex:?bufferUsage">
	<x path="Int"/>
	<x path="Int"/>
	<x path="flash.display3D.Context3DBufferUsage"/>
	<c path="flash.display3D.VertexBuffer3D"/>
</f></createVertexBuffer>
		<createVideoTexture public="1" set="method"><f a=""><c path="flash.display3D.textures.VideoTexture"/></f></createVideoTexture>
		<dispose public="1" set="method">
			<f a="?recreate" v="true">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ recreate : true }</e></m></meta>
		</dispose>
		<drawToBitmapData public="1" set="method"><f a="destination">
	<c path="flash.display.BitmapData"/>
	<x path="Void"/>
</f></drawToBitmapData>
		<drawTriangles public="1" set="method">
			<f a="indexBuffer:?firstIndex:?numTriangles" v=":0:-1">
				<c path="flash.display3D.IndexBuffer3D"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ numTriangles : -1, firstIndex : 0 }</e></m></meta>
		</drawTriangles>
		<get_backBufferHeight set="method"><f a=""><x path="Int"/></f></get_backBufferHeight>
		<get_backBufferWidth set="method"><f a=""><x path="Int"/></f></get_backBufferWidth>
		<get_driverInfo set="method"><f a=""><c path="String"/></f></get_driverInfo>
		<get_enableErrorChecking set="method"><f a=""><x path="Bool"/></f></get_enableErrorChecking>
		<get_maxBackBufferHeight set="method"><f a=""><x path="Int"/></f></get_maxBackBufferHeight>
		<get_maxBackBufferWidth set="method"><f a=""><x path="Int"/></f></get_maxBackBufferWidth>
		<get_profile set="method"><f a=""><c path="String"/></f></get_profile>
		<get_totalGPUMemory set="method"><f a=""><x path="Float"/></f></get_totalGPUMemory>
		<present public="1" set="method"><f a=""><x path="Void"/></f></present>
		<setBlendFactors public="1" set="method"><f a="sourceFactor:destinationFactor">
	<x path="flash.display3D.Context3DBlendFactor"/>
	<x path="flash.display3D.Context3DBlendFactor"/>
	<x path="Void"/>
</f></setBlendFactors>
		<setColorMask public="1" set="method"><f a="red:green:blue:alpha">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setColorMask>
		<setCulling public="1" set="method"><f a="triangleFaceToCull">
	<x path="flash.display3D.Context3DTriangleFace"/>
	<x path="Void"/>
</f></setCulling>
		<setDepthTest public="1" set="method"><f a="depthMask:passCompareMode">
	<x path="Bool"/>
	<x path="flash.display3D.Context3DCompareMode"/>
	<x path="Void"/>
</f></setDepthTest>
		<setProgram public="1" set="method"><f a="program">
	<c path="flash.display3D.Program3D"/>
	<x path="Void"/>
</f></setProgram>
		<setProgramConstantsFromByteArray public="1">
			<f a="programType:firstRegister:numRegisters:data:byteArrayOffset">
				<x path="flash.display3D.Context3DProgramType"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="flash.utils.ByteArray"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</setProgramConstantsFromByteArray>
		<setProgramConstantsFromMatrix public="1" set="method">
			<f a="programType:firstRegister:matrix:?transposedMatrix" v=":::false">
				<x path="flash.display3D.Context3DProgramType"/>
				<x path="Int"/>
				<c path="flash.geom.Matrix3D"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ transposedMatrix : false }</e></m></meta>
		</setProgramConstantsFromMatrix>
		<setProgramConstantsFromVector public="1" set="method">
			<f a="programType:firstRegister:data:?numRegisters" v=":::-1">
				<x path="flash.display3D.Context3DProgramType"/>
				<x path="Int"/>
				<c path="flash.Vector"><x path="Float"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ numRegisters : -1 }</e></m></meta>
		</setProgramConstantsFromVector>
		<setRenderToBackBuffer public="1" set="method"><f a=""><x path="Void"/></f></setRenderToBackBuffer>
		<setRenderToTexture public="1" set="method">
			<f a="texture:?enableDepthAndStencil:?antiAlias:?surfaceSelector:?colorOutputIndex" v=":false:0:0:0">
				<c path="flash.display3D.textures.TextureBase"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ colorOutputIndex : 0, surfaceSelector : 0, antiAlias : 0, enableDepthAndStencil : false }</e></m></meta>
		</setRenderToTexture>
		<setSamplerStateAt public="1">
			<f a="sampler:wrap:filter:mipfilter">
				<x path="Int"/>
				<x path="flash.display3D.Context3DWrapMode"/>
				<x path="flash.display3D.Context3DTextureFilter"/>
				<x path="flash.display3D.Context3DMipFilter"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11_6</e></m></meta>
		</setSamplerStateAt>
		<setScissorRectangle public="1" set="method"><f a="rectangle">
	<c path="flash.geom.Rectangle"/>
	<x path="Void"/>
</f></setScissorRectangle>
		<setStencilActions public="1" set="method"><f a="?triangleFace:?compareMode:?actionOnBothPass:?actionOnDepthFail:?actionOnDepthPassStencilFail">
	<x path="flash.display3D.Context3DTriangleFace"/>
	<x path="flash.display3D.Context3DCompareMode"/>
	<x path="flash.display3D.Context3DStencilAction"/>
	<x path="flash.display3D.Context3DStencilAction"/>
	<x path="flash.display3D.Context3DStencilAction"/>
	<x path="Void"/>
</f></setStencilActions>
		<setStencilReferenceValue public="1" set="method">
			<f a="referenceValue:?readMask:?writeMask" v=":255:255">
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ writeMask : 255, readMask : 255 }</e></m></meta>
		</setStencilReferenceValue>
		<setTextureAt public="1" set="method"><f a="sampler:texture">
	<x path="Int"/>
	<c path="flash.display3D.textures.TextureBase"/>
	<x path="Void"/>
</f></setTextureAt>
		<setVertexBufferAt public="1" set="method">
			<f a="index:buffer:?bufferOffset:?format" v="::0:">
				<x path="Int"/>
				<c path="flash.display3D.VertexBuffer3D"/>
				<x path="Int"/>
				<x path="flash.display3D.Context3DVertexBufferFormat"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ bufferOffset : 0 }</e></m></meta>
		</setVertexBufferAt>
		<set_enableErrorChecking set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_enableErrorChecking>
		<set_maxBackBufferHeight set="method"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_maxBackBufferHeight>
		<set_maxBackBufferWidth set="method"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_maxBackBufferWidth>
	</class>
	<abstract path="flash.display3D.Context3DBlendFactor" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/Context3DBlendFactor.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display3D.Context3DBlendFactor"</e></m>
		</meta>
		<impl><class path="flash.display3D._Context3DBlendFactor.Context3DBlendFactor_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/Context3DBlendFactor.hx" private="1" module="flash.display3D.Context3DBlendFactor" extern="1" final="1">
	<DESTINATION_ALPHA public="1" set="null" static="1">
		<x path="flash.display3D.Context3DBlendFactor"/>
		<meta><m n=":enum"/></meta>
	</DESTINATION_ALPHA>
	<DESTINATION_COLOR public="1" set="null" static="1">
		<x path="flash.display3D.Context3DBlendFactor"/>
		<meta><m n=":enum"/></meta>
	</DESTINATION_COLOR>
	<ONE public="1" set="null" static="1">
		<x path="flash.display3D.Context3DBlendFactor"/>
		<meta><m n=":enum"/></meta>
	</ONE>
	<ONE_MINUS_DESTINATION_ALPHA public="1" set="null" static="1">
		<x path="flash.display3D.Context3DBlendFactor"/>
		<meta><m n=":enum"/></meta>
	</ONE_MINUS_DESTINATION_ALPHA>
	<ONE_MINUS_DESTINATION_COLOR public="1" set="null" static="1">
		<x path="flash.display3D.Context3DBlendFactor"/>
		<meta><m n=":enum"/></meta>
	</ONE_MINUS_DESTINATION_COLOR>
	<ONE_MINUS_SOURCE_ALPHA public="1" set="null" static="1">
		<x path="flash.display3D.Context3DBlendFactor"/>
		<meta><m n=":enum"/></meta>
	</ONE_MINUS_SOURCE_ALPHA>
	<ONE_MINUS_SOURCE_COLOR public="1" set="null" static="1">
		<x path="flash.display3D.Context3DBlendFactor"/>
		<meta><m n=":enum"/></meta>
	</ONE_MINUS_SOURCE_COLOR>
	<SOURCE_ALPHA public="1" set="null" static="1">
		<x path="flash.display3D.Context3DBlendFactor"/>
		<meta><m n=":enum"/></meta>
	</SOURCE_ALPHA>
	<SOURCE_COLOR public="1" set="null" static="1">
		<x path="flash.display3D.Context3DBlendFactor"/>
		<meta><m n=":enum"/></meta>
	</SOURCE_COLOR>
	<ZERO public="1" set="null" static="1">
		<x path="flash.display3D.Context3DBlendFactor"/>
		<meta><m n=":enum"/></meta>
	</ZERO>
	<meta>
		<m n=":native"><e>"flash.display3D.Context3DBlendFactor"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display3D._Context3DBlendFactor.Context3DBlendFactor_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/Context3DBlendFactor.hx" private="1" module="flash.display3D.Context3DBlendFactor" extern="1" final="1">
		<DESTINATION_ALPHA public="1" set="null" static="1">
			<x path="flash.display3D.Context3DBlendFactor"/>
			<meta><m n=":enum"/></meta>
		</DESTINATION_ALPHA>
		<DESTINATION_COLOR public="1" set="null" static="1">
			<x path="flash.display3D.Context3DBlendFactor"/>
			<meta><m n=":enum"/></meta>
		</DESTINATION_COLOR>
		<ONE public="1" set="null" static="1">
			<x path="flash.display3D.Context3DBlendFactor"/>
			<meta><m n=":enum"/></meta>
		</ONE>
		<ONE_MINUS_DESTINATION_ALPHA public="1" set="null" static="1">
			<x path="flash.display3D.Context3DBlendFactor"/>
			<meta><m n=":enum"/></meta>
		</ONE_MINUS_DESTINATION_ALPHA>
		<ONE_MINUS_DESTINATION_COLOR public="1" set="null" static="1">
			<x path="flash.display3D.Context3DBlendFactor"/>
			<meta><m n=":enum"/></meta>
		</ONE_MINUS_DESTINATION_COLOR>
		<ONE_MINUS_SOURCE_ALPHA public="1" set="null" static="1">
			<x path="flash.display3D.Context3DBlendFactor"/>
			<meta><m n=":enum"/></meta>
		</ONE_MINUS_SOURCE_ALPHA>
		<ONE_MINUS_SOURCE_COLOR public="1" set="null" static="1">
			<x path="flash.display3D.Context3DBlendFactor"/>
			<meta><m n=":enum"/></meta>
		</ONE_MINUS_SOURCE_COLOR>
		<SOURCE_ALPHA public="1" set="null" static="1">
			<x path="flash.display3D.Context3DBlendFactor"/>
			<meta><m n=":enum"/></meta>
		</SOURCE_ALPHA>
		<SOURCE_COLOR public="1" set="null" static="1">
			<x path="flash.display3D.Context3DBlendFactor"/>
			<meta><m n=":enum"/></meta>
		</SOURCE_COLOR>
		<ZERO public="1" set="null" static="1">
			<x path="flash.display3D.Context3DBlendFactor"/>
			<meta><m n=":enum"/></meta>
		</ZERO>
		<meta>
			<m n=":native"><e>"flash.display3D.Context3DBlendFactor"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="flash.display3D.Context3DBufferUsage" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/Context3DBufferUsage.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display3D.Context3DBufferUsage"</e></m>
			<m n=":require"><e>flash12</e></m>
		</meta>
		<impl><class path="flash.display3D._Context3DBufferUsage.Context3DBufferUsage_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/Context3DBufferUsage.hx" private="1" module="flash.display3D.Context3DBufferUsage" extern="1" final="1">
	<DYNAMIC_DRAW public="1" set="null" static="1">
		<x path="flash.display3D.Context3DBufferUsage"/>
		<meta><m n=":enum"/></meta>
	</DYNAMIC_DRAW>
	<STATIC_DRAW public="1" set="null" static="1">
		<x path="flash.display3D.Context3DBufferUsage"/>
		<meta><m n=":enum"/></meta>
	</STATIC_DRAW>
	<meta>
		<m n=":native"><e>"flash.display3D.Context3DBufferUsage"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display3D._Context3DBufferUsage.Context3DBufferUsage_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/Context3DBufferUsage.hx" private="1" module="flash.display3D.Context3DBufferUsage" extern="1" final="1">
		<DYNAMIC_DRAW public="1" set="null" static="1">
			<x path="flash.display3D.Context3DBufferUsage"/>
			<meta><m n=":enum"/></meta>
		</DYNAMIC_DRAW>
		<STATIC_DRAW public="1" set="null" static="1">
			<x path="flash.display3D.Context3DBufferUsage"/>
			<meta><m n=":enum"/></meta>
		</STATIC_DRAW>
		<meta>
			<m n=":native"><e>"flash.display3D.Context3DBufferUsage"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="flash.display3D.Context3DCompareMode" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/Context3DCompareMode.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display3D.Context3DCompareMode"</e></m>
		</meta>
		<impl><class path="flash.display3D._Context3DCompareMode.Context3DCompareMode_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/Context3DCompareMode.hx" private="1" module="flash.display3D.Context3DCompareMode" extern="1" final="1">
	<ALWAYS public="1" set="null" static="1">
		<x path="flash.display3D.Context3DCompareMode"/>
		<meta><m n=":enum"/></meta>
	</ALWAYS>
	<EQUAL public="1" set="null" static="1">
		<x path="flash.display3D.Context3DCompareMode"/>
		<meta><m n=":enum"/></meta>
	</EQUAL>
	<GREATER public="1" set="null" static="1">
		<x path="flash.display3D.Context3DCompareMode"/>
		<meta><m n=":enum"/></meta>
	</GREATER>
	<GREATER_EQUAL public="1" set="null" static="1">
		<x path="flash.display3D.Context3DCompareMode"/>
		<meta><m n=":enum"/></meta>
	</GREATER_EQUAL>
	<LESS public="1" set="null" static="1">
		<x path="flash.display3D.Context3DCompareMode"/>
		<meta><m n=":enum"/></meta>
	</LESS>
	<LESS_EQUAL public="1" set="null" static="1">
		<x path="flash.display3D.Context3DCompareMode"/>
		<meta><m n=":enum"/></meta>
	</LESS_EQUAL>
	<NEVER public="1" set="null" static="1">
		<x path="flash.display3D.Context3DCompareMode"/>
		<meta><m n=":enum"/></meta>
	</NEVER>
	<NOT_EQUAL public="1" set="null" static="1">
		<x path="flash.display3D.Context3DCompareMode"/>
		<meta><m n=":enum"/></meta>
	</NOT_EQUAL>
	<meta>
		<m n=":native"><e>"flash.display3D.Context3DCompareMode"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display3D._Context3DCompareMode.Context3DCompareMode_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/Context3DCompareMode.hx" private="1" module="flash.display3D.Context3DCompareMode" extern="1" final="1">
		<ALWAYS public="1" set="null" static="1">
			<x path="flash.display3D.Context3DCompareMode"/>
			<meta><m n=":enum"/></meta>
		</ALWAYS>
		<EQUAL public="1" set="null" static="1">
			<x path="flash.display3D.Context3DCompareMode"/>
			<meta><m n=":enum"/></meta>
		</EQUAL>
		<GREATER public="1" set="null" static="1">
			<x path="flash.display3D.Context3DCompareMode"/>
			<meta><m n=":enum"/></meta>
		</GREATER>
		<GREATER_EQUAL public="1" set="null" static="1">
			<x path="flash.display3D.Context3DCompareMode"/>
			<meta><m n=":enum"/></meta>
		</GREATER_EQUAL>
		<LESS public="1" set="null" static="1">
			<x path="flash.display3D.Context3DCompareMode"/>
			<meta><m n=":enum"/></meta>
		</LESS>
		<LESS_EQUAL public="1" set="null" static="1">
			<x path="flash.display3D.Context3DCompareMode"/>
			<meta><m n=":enum"/></meta>
		</LESS_EQUAL>
		<NEVER public="1" set="null" static="1">
			<x path="flash.display3D.Context3DCompareMode"/>
			<meta><m n=":enum"/></meta>
		</NEVER>
		<NOT_EQUAL public="1" set="null" static="1">
			<x path="flash.display3D.Context3DCompareMode"/>
			<meta><m n=":enum"/></meta>
		</NOT_EQUAL>
		<meta>
			<m n=":native"><e>"flash.display3D.Context3DCompareMode"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="flash.display3D.Context3DMipFilter" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/Context3DMipFilter.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display3D.Context3DMipFilter"</e></m>
		</meta>
		<impl><class path="flash.display3D._Context3DMipFilter.Context3DMipFilter_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/Context3DMipFilter.hx" private="1" module="flash.display3D.Context3DMipFilter" extern="1" final="1">
	<MIPLINEAR public="1" set="null" static="1">
		<x path="flash.display3D.Context3DMipFilter"/>
		<meta><m n=":enum"/></meta>
	</MIPLINEAR>
	<MIPNEAREST public="1" set="null" static="1">
		<x path="flash.display3D.Context3DMipFilter"/>
		<meta><m n=":enum"/></meta>
	</MIPNEAREST>
	<MIPNONE public="1" set="null" static="1">
		<x path="flash.display3D.Context3DMipFilter"/>
		<meta><m n=":enum"/></meta>
	</MIPNONE>
	<meta>
		<m n=":native"><e>"flash.display3D.Context3DMipFilter"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display3D._Context3DMipFilter.Context3DMipFilter_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/Context3DMipFilter.hx" private="1" module="flash.display3D.Context3DMipFilter" extern="1" final="1">
		<MIPLINEAR public="1" set="null" static="1">
			<x path="flash.display3D.Context3DMipFilter"/>
			<meta><m n=":enum"/></meta>
		</MIPLINEAR>
		<MIPNEAREST public="1" set="null" static="1">
			<x path="flash.display3D.Context3DMipFilter"/>
			<meta><m n=":enum"/></meta>
		</MIPNEAREST>
		<MIPNONE public="1" set="null" static="1">
			<x path="flash.display3D.Context3DMipFilter"/>
			<meta><m n=":enum"/></meta>
		</MIPNONE>
		<meta>
			<m n=":native"><e>"flash.display3D.Context3DMipFilter"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="flash.display3D.Context3DProfile" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/Context3DProfile.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display3D.Context3DProfile"</e></m>
		</meta>
		<impl><class path="flash.display3D._Context3DProfile.Context3DProfile_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/Context3DProfile.hx" private="1" module="flash.display3D.Context3DProfile" extern="1" final="1">
	<BASELINE public="1" set="null" static="1">
		<x path="flash.display3D.Context3DProfile"/>
		<meta><m n=":enum"/></meta>
	</BASELINE>
	<BASELINE_CONSTRAINED public="1" set="null" static="1">
		<x path="flash.display3D.Context3DProfile"/>
		<meta><m n=":enum"/></meta>
	</BASELINE_CONSTRAINED>
	<BASELINE_EXTENDED public="1" set="null" static="1">
		<x path="flash.display3D.Context3DProfile"/>
		<meta><m n=":enum"/></meta>
	</BASELINE_EXTENDED>
	<STANDARD public="1" set="null" static="1">
		<x path="flash.display3D.Context3DProfile"/>
		<meta><m n=":enum"/></meta>
	</STANDARD>
	<STANDARD_CONSTRAINED public="1" set="null" static="1">
		<x path="flash.display3D.Context3DProfile"/>
		<meta><m n=":enum"/></meta>
	</STANDARD_CONSTRAINED>
	<STANDARD_EXTENDED public="1" set="null" static="1">
		<x path="flash.display3D.Context3DProfile"/>
		<meta><m n=":enum"/></meta>
	</STANDARD_EXTENDED>
	<meta>
		<m n=":native"><e>"flash.display3D.Context3DProfile"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display3D._Context3DProfile.Context3DProfile_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/Context3DProfile.hx" private="1" module="flash.display3D.Context3DProfile" extern="1" final="1">
		<BASELINE public="1" set="null" static="1">
			<x path="flash.display3D.Context3DProfile"/>
			<meta><m n=":enum"/></meta>
		</BASELINE>
		<BASELINE_CONSTRAINED public="1" set="null" static="1">
			<x path="flash.display3D.Context3DProfile"/>
			<meta><m n=":enum"/></meta>
		</BASELINE_CONSTRAINED>
		<BASELINE_EXTENDED public="1" set="null" static="1">
			<x path="flash.display3D.Context3DProfile"/>
			<meta><m n=":enum"/></meta>
		</BASELINE_EXTENDED>
		<STANDARD public="1" set="null" static="1">
			<x path="flash.display3D.Context3DProfile"/>
			<meta><m n=":enum"/></meta>
		</STANDARD>
		<STANDARD_CONSTRAINED public="1" set="null" static="1">
			<x path="flash.display3D.Context3DProfile"/>
			<meta><m n=":enum"/></meta>
		</STANDARD_CONSTRAINED>
		<STANDARD_EXTENDED public="1" set="null" static="1">
			<x path="flash.display3D.Context3DProfile"/>
			<meta><m n=":enum"/></meta>
		</STANDARD_EXTENDED>
		<meta>
			<m n=":native"><e>"flash.display3D.Context3DProfile"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="flash.display3D.Context3DProgramType" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/Context3DProgramType.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display3D.Context3DProgramType"</e></m>
		</meta>
		<impl><class path="flash.display3D._Context3DProgramType.Context3DProgramType_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/Context3DProgramType.hx" private="1" module="flash.display3D.Context3DProgramType" extern="1" final="1">
	<FRAGMENT public="1" set="null" static="1">
		<x path="flash.display3D.Context3DProgramType"/>
		<meta><m n=":enum"/></meta>
	</FRAGMENT>
	<VERTEX public="1" set="null" static="1">
		<x path="flash.display3D.Context3DProgramType"/>
		<meta><m n=":enum"/></meta>
	</VERTEX>
	<meta>
		<m n=":native"><e>"flash.display3D.Context3DProgramType"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display3D._Context3DProgramType.Context3DProgramType_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/Context3DProgramType.hx" private="1" module="flash.display3D.Context3DProgramType" extern="1" final="1">
		<FRAGMENT public="1" set="null" static="1">
			<x path="flash.display3D.Context3DProgramType"/>
			<meta><m n=":enum"/></meta>
		</FRAGMENT>
		<VERTEX public="1" set="null" static="1">
			<x path="flash.display3D.Context3DProgramType"/>
			<meta><m n=":enum"/></meta>
		</VERTEX>
		<meta>
			<m n=":native"><e>"flash.display3D.Context3DProgramType"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="flash.display3D.Context3DStencilAction" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/Context3DStencilAction.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display3D.Context3DStencilAction"</e></m>
		</meta>
		<impl><class path="flash.display3D._Context3DStencilAction.Context3DStencilAction_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/Context3DStencilAction.hx" private="1" module="flash.display3D.Context3DStencilAction" extern="1" final="1">
	<DECREMENT_SATURATE public="1" set="null" static="1">
		<x path="flash.display3D.Context3DStencilAction"/>
		<meta><m n=":enum"/></meta>
	</DECREMENT_SATURATE>
	<DECREMENT_WRAP public="1" set="null" static="1">
		<x path="flash.display3D.Context3DStencilAction"/>
		<meta><m n=":enum"/></meta>
	</DECREMENT_WRAP>
	<INCREMENT_SATURATE public="1" set="null" static="1">
		<x path="flash.display3D.Context3DStencilAction"/>
		<meta><m n=":enum"/></meta>
	</INCREMENT_SATURATE>
	<INCREMENT_WRAP public="1" set="null" static="1">
		<x path="flash.display3D.Context3DStencilAction"/>
		<meta><m n=":enum"/></meta>
	</INCREMENT_WRAP>
	<INVERT public="1" set="null" static="1">
		<x path="flash.display3D.Context3DStencilAction"/>
		<meta><m n=":enum"/></meta>
	</INVERT>
	<KEEP public="1" set="null" static="1">
		<x path="flash.display3D.Context3DStencilAction"/>
		<meta><m n=":enum"/></meta>
	</KEEP>
	<SET public="1" set="null" static="1">
		<x path="flash.display3D.Context3DStencilAction"/>
		<meta><m n=":enum"/></meta>
	</SET>
	<ZERO public="1" set="null" static="1">
		<x path="flash.display3D.Context3DStencilAction"/>
		<meta><m n=":enum"/></meta>
	</ZERO>
	<meta>
		<m n=":native"><e>"flash.display3D.Context3DStencilAction"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display3D._Context3DStencilAction.Context3DStencilAction_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/Context3DStencilAction.hx" private="1" module="flash.display3D.Context3DStencilAction" extern="1" final="1">
		<DECREMENT_SATURATE public="1" set="null" static="1">
			<x path="flash.display3D.Context3DStencilAction"/>
			<meta><m n=":enum"/></meta>
		</DECREMENT_SATURATE>
		<DECREMENT_WRAP public="1" set="null" static="1">
			<x path="flash.display3D.Context3DStencilAction"/>
			<meta><m n=":enum"/></meta>
		</DECREMENT_WRAP>
		<INCREMENT_SATURATE public="1" set="null" static="1">
			<x path="flash.display3D.Context3DStencilAction"/>
			<meta><m n=":enum"/></meta>
		</INCREMENT_SATURATE>
		<INCREMENT_WRAP public="1" set="null" static="1">
			<x path="flash.display3D.Context3DStencilAction"/>
			<meta><m n=":enum"/></meta>
		</INCREMENT_WRAP>
		<INVERT public="1" set="null" static="1">
			<x path="flash.display3D.Context3DStencilAction"/>
			<meta><m n=":enum"/></meta>
		</INVERT>
		<KEEP public="1" set="null" static="1">
			<x path="flash.display3D.Context3DStencilAction"/>
			<meta><m n=":enum"/></meta>
		</KEEP>
		<SET public="1" set="null" static="1">
			<x path="flash.display3D.Context3DStencilAction"/>
			<meta><m n=":enum"/></meta>
		</SET>
		<ZERO public="1" set="null" static="1">
			<x path="flash.display3D.Context3DStencilAction"/>
			<meta><m n=":enum"/></meta>
		</ZERO>
		<meta>
			<m n=":native"><e>"flash.display3D.Context3DStencilAction"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="flash.display3D.Context3DTextureFilter" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/Context3DTextureFilter.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display3D.Context3DTextureFilter"</e></m>
		</meta>
		<impl><class path="flash.display3D._Context3DTextureFilter.Context3DTextureFilter_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/Context3DTextureFilter.hx" private="1" module="flash.display3D.Context3DTextureFilter" extern="1" final="1">
	<ANISOTROPIC16X public="1" set="null" static="1">
		<x path="flash.display3D.Context3DTextureFilter"/>
		<meta><m n=":enum"/></meta>
	</ANISOTROPIC16X>
	<ANISOTROPIC2X public="1" set="null" static="1">
		<x path="flash.display3D.Context3DTextureFilter"/>
		<meta><m n=":enum"/></meta>
	</ANISOTROPIC2X>
	<ANISOTROPIC4X public="1" set="null" static="1">
		<x path="flash.display3D.Context3DTextureFilter"/>
		<meta><m n=":enum"/></meta>
	</ANISOTROPIC4X>
	<ANISOTROPIC8X public="1" set="null" static="1">
		<x path="flash.display3D.Context3DTextureFilter"/>
		<meta><m n=":enum"/></meta>
	</ANISOTROPIC8X>
	<LINEAR public="1" set="null" static="1">
		<x path="flash.display3D.Context3DTextureFilter"/>
		<meta><m n=":enum"/></meta>
	</LINEAR>
	<NEAREST public="1" set="null" static="1">
		<x path="flash.display3D.Context3DTextureFilter"/>
		<meta><m n=":enum"/></meta>
	</NEAREST>
	<meta>
		<m n=":native"><e>"flash.display3D.Context3DTextureFilter"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display3D._Context3DTextureFilter.Context3DTextureFilter_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/Context3DTextureFilter.hx" private="1" module="flash.display3D.Context3DTextureFilter" extern="1" final="1">
		<ANISOTROPIC16X public="1" set="null" static="1">
			<x path="flash.display3D.Context3DTextureFilter"/>
			<meta><m n=":enum"/></meta>
		</ANISOTROPIC16X>
		<ANISOTROPIC2X public="1" set="null" static="1">
			<x path="flash.display3D.Context3DTextureFilter"/>
			<meta><m n=":enum"/></meta>
		</ANISOTROPIC2X>
		<ANISOTROPIC4X public="1" set="null" static="1">
			<x path="flash.display3D.Context3DTextureFilter"/>
			<meta><m n=":enum"/></meta>
		</ANISOTROPIC4X>
		<ANISOTROPIC8X public="1" set="null" static="1">
			<x path="flash.display3D.Context3DTextureFilter"/>
			<meta><m n=":enum"/></meta>
		</ANISOTROPIC8X>
		<LINEAR public="1" set="null" static="1">
			<x path="flash.display3D.Context3DTextureFilter"/>
			<meta><m n=":enum"/></meta>
		</LINEAR>
		<NEAREST public="1" set="null" static="1">
			<x path="flash.display3D.Context3DTextureFilter"/>
			<meta><m n=":enum"/></meta>
		</NEAREST>
		<meta>
			<m n=":native"><e>"flash.display3D.Context3DTextureFilter"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="flash.display3D.Context3DTextureFormat" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/Context3DTextureFormat.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display3D.Context3DTextureFormat"</e></m>
		</meta>
		<impl><class path="flash.display3D._Context3DTextureFormat.Context3DTextureFormat_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/Context3DTextureFormat.hx" private="1" module="flash.display3D.Context3DTextureFormat" extern="1" final="1">
	<BGRA public="1" set="null" static="1">
		<x path="flash.display3D.Context3DTextureFormat"/>
		<meta><m n=":enum"/></meta>
	</BGRA>
	<BGRA_PACKED public="1" set="null" static="1">
		<x path="flash.display3D.Context3DTextureFormat"/>
		<meta><m n=":enum"/></meta>
	</BGRA_PACKED>
	<BGR_PACKED public="1" set="null" static="1">
		<x path="flash.display3D.Context3DTextureFormat"/>
		<meta><m n=":enum"/></meta>
	</BGR_PACKED>
	<COMPRESSED public="1" set="null" static="1">
		<x path="flash.display3D.Context3DTextureFormat"/>
		<meta><m n=":enum"/></meta>
	</COMPRESSED>
	<COMPRESSED_ALPHA public="1" set="null" static="1">
		<x path="flash.display3D.Context3DTextureFormat"/>
		<meta><m n=":enum"/></meta>
	</COMPRESSED_ALPHA>
	<RGBA_HALF_FLOAT public="1" set="null" static="1">
		<x path="flash.display3D.Context3DTextureFormat"/>
		<meta><m n=":enum"/></meta>
	</RGBA_HALF_FLOAT>
	<meta>
		<m n=":native"><e>"flash.display3D.Context3DTextureFormat"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display3D._Context3DTextureFormat.Context3DTextureFormat_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/Context3DTextureFormat.hx" private="1" module="flash.display3D.Context3DTextureFormat" extern="1" final="1">
		<BGRA public="1" set="null" static="1">
			<x path="flash.display3D.Context3DTextureFormat"/>
			<meta><m n=":enum"/></meta>
		</BGRA>
		<BGRA_PACKED public="1" set="null" static="1">
			<x path="flash.display3D.Context3DTextureFormat"/>
			<meta><m n=":enum"/></meta>
		</BGRA_PACKED>
		<BGR_PACKED public="1" set="null" static="1">
			<x path="flash.display3D.Context3DTextureFormat"/>
			<meta><m n=":enum"/></meta>
		</BGR_PACKED>
		<COMPRESSED public="1" set="null" static="1">
			<x path="flash.display3D.Context3DTextureFormat"/>
			<meta><m n=":enum"/></meta>
		</COMPRESSED>
		<COMPRESSED_ALPHA public="1" set="null" static="1">
			<x path="flash.display3D.Context3DTextureFormat"/>
			<meta><m n=":enum"/></meta>
		</COMPRESSED_ALPHA>
		<RGBA_HALF_FLOAT public="1" set="null" static="1">
			<x path="flash.display3D.Context3DTextureFormat"/>
			<meta><m n=":enum"/></meta>
		</RGBA_HALF_FLOAT>
		<meta>
			<m n=":native"><e>"flash.display3D.Context3DTextureFormat"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="flash.display3D.Context3DTriangleFace" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/Context3DTriangleFace.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display3D.Context3DTriangleFace"</e></m>
		</meta>
		<impl><class path="flash.display3D._Context3DTriangleFace.Context3DTriangleFace_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/Context3DTriangleFace.hx" private="1" module="flash.display3D.Context3DTriangleFace" extern="1" final="1">
	<BACK public="1" set="null" static="1">
		<x path="flash.display3D.Context3DTriangleFace"/>
		<meta><m n=":enum"/></meta>
	</BACK>
	<FRONT public="1" set="null" static="1">
		<x path="flash.display3D.Context3DTriangleFace"/>
		<meta><m n=":enum"/></meta>
	</FRONT>
	<FRONT_AND_BACK public="1" set="null" static="1">
		<x path="flash.display3D.Context3DTriangleFace"/>
		<meta><m n=":enum"/></meta>
	</FRONT_AND_BACK>
	<NONE public="1" set="null" static="1">
		<x path="flash.display3D.Context3DTriangleFace"/>
		<meta><m n=":enum"/></meta>
	</NONE>
	<meta>
		<m n=":native"><e>"flash.display3D.Context3DTriangleFace"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display3D._Context3DTriangleFace.Context3DTriangleFace_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/Context3DTriangleFace.hx" private="1" module="flash.display3D.Context3DTriangleFace" extern="1" final="1">
		<BACK public="1" set="null" static="1">
			<x path="flash.display3D.Context3DTriangleFace"/>
			<meta><m n=":enum"/></meta>
		</BACK>
		<FRONT public="1" set="null" static="1">
			<x path="flash.display3D.Context3DTriangleFace"/>
			<meta><m n=":enum"/></meta>
		</FRONT>
		<FRONT_AND_BACK public="1" set="null" static="1">
			<x path="flash.display3D.Context3DTriangleFace"/>
			<meta><m n=":enum"/></meta>
		</FRONT_AND_BACK>
		<NONE public="1" set="null" static="1">
			<x path="flash.display3D.Context3DTriangleFace"/>
			<meta><m n=":enum"/></meta>
		</NONE>
		<meta>
			<m n=":native"><e>"flash.display3D.Context3DTriangleFace"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="flash.display3D.Context3DVertexBufferFormat" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/Context3DVertexBufferFormat.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display3D.Context3DVertexBufferFormat"</e></m>
		</meta>
		<impl><class path="flash.display3D._Context3DVertexBufferFormat.Context3DVertexBufferFormat_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/Context3DVertexBufferFormat.hx" private="1" module="flash.display3D.Context3DVertexBufferFormat" extern="1" final="1">
	<BYTES_4 public="1" set="null" static="1">
		<x path="flash.display3D.Context3DVertexBufferFormat"/>
		<meta><m n=":enum"/></meta>
	</BYTES_4>
	<FLOAT_1 public="1" set="null" static="1">
		<x path="flash.display3D.Context3DVertexBufferFormat"/>
		<meta><m n=":enum"/></meta>
	</FLOAT_1>
	<FLOAT_2 public="1" set="null" static="1">
		<x path="flash.display3D.Context3DVertexBufferFormat"/>
		<meta><m n=":enum"/></meta>
	</FLOAT_2>
	<FLOAT_3 public="1" set="null" static="1">
		<x path="flash.display3D.Context3DVertexBufferFormat"/>
		<meta><m n=":enum"/></meta>
	</FLOAT_3>
	<FLOAT_4 public="1" set="null" static="1">
		<x path="flash.display3D.Context3DVertexBufferFormat"/>
		<meta><m n=":enum"/></meta>
	</FLOAT_4>
	<meta>
		<m n=":native"><e>"flash.display3D.Context3DVertexBufferFormat"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display3D._Context3DVertexBufferFormat.Context3DVertexBufferFormat_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/Context3DVertexBufferFormat.hx" private="1" module="flash.display3D.Context3DVertexBufferFormat" extern="1" final="1">
		<BYTES_4 public="1" set="null" static="1">
			<x path="flash.display3D.Context3DVertexBufferFormat"/>
			<meta><m n=":enum"/></meta>
		</BYTES_4>
		<FLOAT_1 public="1" set="null" static="1">
			<x path="flash.display3D.Context3DVertexBufferFormat"/>
			<meta><m n=":enum"/></meta>
		</FLOAT_1>
		<FLOAT_2 public="1" set="null" static="1">
			<x path="flash.display3D.Context3DVertexBufferFormat"/>
			<meta><m n=":enum"/></meta>
		</FLOAT_2>
		<FLOAT_3 public="1" set="null" static="1">
			<x path="flash.display3D.Context3DVertexBufferFormat"/>
			<meta><m n=":enum"/></meta>
		</FLOAT_3>
		<FLOAT_4 public="1" set="null" static="1">
			<x path="flash.display3D.Context3DVertexBufferFormat"/>
			<meta><m n=":enum"/></meta>
		</FLOAT_4>
		<meta>
			<m n=":native"><e>"flash.display3D.Context3DVertexBufferFormat"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="flash.display3D.Context3DWrapMode" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/Context3DWrapMode.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display3D.Context3DWrapMode"</e></m>
		</meta>
		<impl><class path="flash.display3D._Context3DWrapMode.Context3DWrapMode_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/Context3DWrapMode.hx" private="1" module="flash.display3D.Context3DWrapMode" extern="1" final="1">
	<CLAMP public="1" set="null" static="1">
		<x path="flash.display3D.Context3DWrapMode"/>
		<meta><m n=":enum"/></meta>
	</CLAMP>
	<CLAMP_U_REPEAT_V public="1" set="null" static="1">
		<x path="flash.display3D.Context3DWrapMode"/>
		<meta><m n=":enum"/></meta>
	</CLAMP_U_REPEAT_V>
	<REPEAT public="1" set="null" static="1">
		<x path="flash.display3D.Context3DWrapMode"/>
		<meta><m n=":enum"/></meta>
	</REPEAT>
	<REPEAT_U_CLAMP_V public="1" set="null" static="1">
		<x path="flash.display3D.Context3DWrapMode"/>
		<meta><m n=":enum"/></meta>
	</REPEAT_U_CLAMP_V>
	<meta>
		<m n=":native"><e>"flash.display3D.Context3DWrapMode"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display3D._Context3DWrapMode.Context3DWrapMode_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/Context3DWrapMode.hx" private="1" module="flash.display3D.Context3DWrapMode" extern="1" final="1">
		<CLAMP public="1" set="null" static="1">
			<x path="flash.display3D.Context3DWrapMode"/>
			<meta><m n=":enum"/></meta>
		</CLAMP>
		<CLAMP_U_REPEAT_V public="1" set="null" static="1">
			<x path="flash.display3D.Context3DWrapMode"/>
			<meta><m n=":enum"/></meta>
		</CLAMP_U_REPEAT_V>
		<REPEAT public="1" set="null" static="1">
			<x path="flash.display3D.Context3DWrapMode"/>
			<meta><m n=":enum"/></meta>
		</REPEAT>
		<REPEAT_U_CLAMP_V public="1" set="null" static="1">
			<x path="flash.display3D.Context3DWrapMode"/>
			<meta><m n=":enum"/></meta>
		</REPEAT_U_CLAMP_V>
		<meta>
			<m n=":native"><e>"flash.display3D.Context3DWrapMode"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="flash.display3D.IndexBuffer3D" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/IndexBuffer3D.hx" extern="1" final="1">
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset:startOffset:count">
	<c path="flash.utils.ByteArray"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadFromByteArray>
		<uploadFromVector public="1" set="method"><f a="data:startOffset:count">
	<c path="flash.Vector"><x path="UInt"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadFromVector>
	</class>
	<class path="flash.display3D.Program3D" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/Program3D.hx" extern="1" final="1">
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<upload public="1" set="method"><f a="vertexProgram:fragmentProgram">
	<c path="flash.utils.ByteArray"/>
	<c path="flash.utils.ByteArray"/>
	<x path="Void"/>
</f></upload>
	</class>
	<class path="flash.display3D.VertexBuffer3D" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/VertexBuffer3D.hx" extern="1">
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset:startVertex:numVertices">
	<c path="flash.utils.ByteArray"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadFromByteArray>
		<uploadFromVector public="1" set="method"><f a="data:startVertex:numVertices">
	<c path="flash.Vector"><x path="Float"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadFromVector>
	</class>
	<class path="flash.display3D.textures.TextureBase" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/textures/TextureBase.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
	</class>
	<class path="flash.display3D.textures.CubeTexture" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/textures/CubeTexture.hx" extern="1" final="1">
		<extends path="flash.display3D.textures.TextureBase"/>
		<uploadCompressedTextureFromByteArray public="1" set="method">
			<f a="data:byteArrayOffset:?async" v="::false">
				<c path="flash.utils.ByteArray"/>
				<x path="UInt"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ async : false }</e></m></meta>
		</uploadCompressedTextureFromByteArray>
		<uploadFromBitmapData public="1" set="method">
			<f a="source:side:?miplevel" v="::0">
				<c path="flash.display.BitmapData"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ miplevel : 0 }</e></m></meta>
		</uploadFromBitmapData>
		<uploadFromByteArray public="1" set="method">
			<f a="data:byteArrayOffset:side:?miplevel" v=":::0">
				<c path="flash.utils.ByteArray"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ miplevel : 0 }</e></m></meta>
		</uploadFromByteArray>
	</class>
	<class path="flash.display3D.textures.RectangleTexture" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/textures/RectangleTexture.hx" extern="1" final="1">
		<extends path="flash.display3D.textures.TextureBase"/>
		<uploadFromBitmapData public="1" set="method"><f a="source">
	<c path="flash.display.BitmapData"/>
	<x path="Void"/>
</f></uploadFromBitmapData>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset">
	<c path="flash.utils.ByteArray"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></uploadFromByteArray>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.display3D.textures.Texture" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/textures/Texture.hx" extern="1" final="1">
		<extends path="flash.display3D.textures.TextureBase"/>
		<uploadCompressedTextureFromByteArray public="1" set="method">
			<f a="data:byteArrayOffset:?async" v="::false">
				<c path="flash.utils.ByteArray"/>
				<x path="UInt"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ async : false }</e></m></meta>
		</uploadCompressedTextureFromByteArray>
		<uploadFromBitmapData public="1" set="method">
			<f a="source:?miplevel" v=":0">
				<c path="flash.display.BitmapData"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ miplevel : 0 }</e></m></meta>
		</uploadFromBitmapData>
		<uploadFromByteArray public="1" set="method">
			<f a="data:byteArrayOffset:?miplevel" v="::0">
				<c path="flash.utils.ByteArray"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ miplevel : 0 }</e></m></meta>
		</uploadFromByteArray>
	</class>
	<class path="flash.display3D.textures.VideoTexture" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/textures/VideoTexture.hx" extern="1" final="1">
		<extends path="flash.display3D.textures.TextureBase"/>
		<videoHeight public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</videoHeight>
		<videoWidth public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</videoWidth>
		<attachCamera public="1" set="method"><f a="theCamera">
	<c path="flash.media.Camera"/>
	<x path="Void"/>
</f></attachCamera>
		<attachNetStream public="1" set="method"><f a="netStream">
	<c path="flash.net.NetStream"/>
	<x path="Void"/>
</f></attachNetStream>
		<get_videoHeight set="method"><f a=""><x path="Int"/></f></get_videoHeight>
		<get_videoWidth set="method"><f a=""><x path="Int"/></f></get_videoWidth>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.errors.Error" params="" file="C:\HaxeToolkit\haxe\std/flash/errors/Error.hx" extern="1">
		<length final="1" public="1" set="null" static="1"><x path="Int"/></length>
		<getErrorMessage public="1" set="method" static="1"><f a="index">
	<x path="Int"/>
	<c path="String"/>
</f></getErrorMessage>
		<throwError public="1" set="method" static="1"><f a="type:index:restArgs">
	<x path="Class"><d/></x>
	<x path="UInt"/>
	<t path="haxe.extern.Rest"><d/></t>
	<d/>
</f></throwError>
		<errorID public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</errorID>
		<message public="1"><d/></message>
		<name public="1"><d/></name>
		<getStackTrace public="1" set="method"><f a=""><c path="String"/></f></getStackTrace>
		<get_errorID set="method"><f a=""><x path="Int"/></f></get_errorID>
		<new public="1" set="method">
			<f a="?message:?id" v=":0">
				<d/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ id : 0 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flash.events.Event" params="" file="C:\HaxeToolkit\haxe\std/flash/events/Event.hx" extern="1">
		<ACTIVATE final="1" public="1" set="null" static="1"><c path="String"/></ACTIVATE>
		<ADDED final="1" public="1" set="null" static="1"><c path="String"/></ADDED>
		<ADDED_TO_STAGE final="1" public="1" set="null" static="1"><c path="String"/></ADDED_TO_STAGE>
		<BROWSER_ZOOM_CHANGE final="1" public="1" set="null" static="1"><c path="String"/></BROWSER_ZOOM_CHANGE>
		<CANCEL final="1" public="1" set="null" static="1"><c path="String"/></CANCEL>
		<CHANGE final="1" public="1" set="null" static="1"><c path="String"/></CHANGE>
		<CHANNEL_MESSAGE final="1" public="1" set="null" static="1"><c path="String"/></CHANNEL_MESSAGE>
		<CHANNEL_STATE final="1" public="1" set="null" static="1"><c path="String"/></CHANNEL_STATE>
		<CLEAR final="1" public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</CLEAR>
		<CLOSE final="1" public="1" set="null" static="1"><c path="String"/></CLOSE>
		<COMPLETE final="1" public="1" set="null" static="1"><c path="String"/></COMPLETE>
		<CONNECT final="1" public="1" set="null" static="1"><c path="String"/></CONNECT>
		<CONTEXT3D_CREATE final="1" public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</CONTEXT3D_CREATE>
		<COPY final="1" public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</COPY>
		<CUT final="1" public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</CUT>
		<DEACTIVATE final="1" public="1" set="null" static="1"><c path="String"/></DEACTIVATE>
		<ENTER_FRAME final="1" public="1" set="null" static="1"><c path="String"/></ENTER_FRAME>
		<EXIT_FRAME final="1" public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</EXIT_FRAME>
		<FRAME_CONSTRUCTED final="1" public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</FRAME_CONSTRUCTED>
		<FRAME_LABEL final="1" public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</FRAME_LABEL>
		<FULLSCREEN final="1" public="1" set="null" static="1"><c path="String"/></FULLSCREEN>
		<ID3 final="1" public="1" set="null" static="1"><c path="String"/></ID3>
		<INIT final="1" public="1" set="null" static="1"><c path="String"/></INIT>
		<MOUSE_LEAVE final="1" public="1" set="null" static="1"><c path="String"/></MOUSE_LEAVE>
		<OPEN final="1" public="1" set="null" static="1"><c path="String"/></OPEN>
		<PASTE final="1" public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</PASTE>
		<REMOVED final="1" public="1" set="null" static="1"><c path="String"/></REMOVED>
		<REMOVED_FROM_STAGE final="1" public="1" set="null" static="1"><c path="String"/></REMOVED_FROM_STAGE>
		<RENDER final="1" public="1" set="null" static="1"><c path="String"/></RENDER>
		<RESIZE final="1" public="1" set="null" static="1"><c path="String"/></RESIZE>
		<SCROLL final="1" public="1" set="null" static="1"><c path="String"/></SCROLL>
		<SELECT final="1" public="1" set="null" static="1"><c path="String"/></SELECT>
		<SELECT_ALL final="1" public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</SELECT_ALL>
		<SOUND_COMPLETE final="1" public="1" set="null" static="1"><c path="String"/></SOUND_COMPLETE>
		<SUSPEND final="1" public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</SUSPEND>
		<TAB_CHILDREN_CHANGE final="1" public="1" set="null" static="1"><c path="String"/></TAB_CHILDREN_CHANGE>
		<TAB_ENABLED_CHANGE final="1" public="1" set="null" static="1"><c path="String"/></TAB_ENABLED_CHANGE>
		<TAB_INDEX_CHANGE final="1" public="1" set="null" static="1"><c path="String"/></TAB_INDEX_CHANGE>
		<TEXTURE_READY final="1" public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</TEXTURE_READY>
		<TEXT_INTERACTION_MODE_CHANGE final="1" public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</TEXT_INTERACTION_MODE_CHANGE>
		<UNLOAD final="1" public="1" set="null" static="1"><c path="String"/></UNLOAD>
		<VIDEO_FRAME final="1" public="1" set="null" static="1"><c path="String"/></VIDEO_FRAME>
		<WORKER_STATE final="1" public="1" set="null" static="1"><c path="String"/></WORKER_STATE>
		<bubbles public="1" get="accessor" set="null">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</bubbles>
		<cancelable public="1" get="accessor" set="null">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</cancelable>
		<currentTarget public="1" get="accessor" set="null">
			<d/>
			<meta><m n=":flash.property"/></meta>
		</currentTarget>
		<eventPhase public="1" get="accessor" set="null">
			<x path="flash.events.EventPhase"/>
			<meta><m n=":flash.property"/></meta>
		</eventPhase>
		<target public="1" get="accessor" set="null">
			<d/>
			<meta><m n=":flash.property"/></meta>
		</target>
		<type public="1" get="accessor" set="null">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</type>
		<clone public="1" set="method"><f a=""><c path="flash.events.Event"/></f></clone>
		<formatToString public="1" set="method"><f a="className:restArgs">
	<c path="String"/>
	<t path="haxe.extern.Rest"><d/></t>
	<c path="String"/>
</f></formatToString>
		<get_bubbles set="method"><f a=""><x path="Bool"/></f></get_bubbles>
		<get_cancelable set="method"><f a=""><x path="Bool"/></f></get_cancelable>
		<get_currentTarget set="method"><f a=""><d/></f></get_currentTarget>
		<get_eventPhase set="method"><f a=""><x path="flash.events.EventPhase"/></f></get_eventPhase>
		<get_target set="method"><f a=""><d/></f></get_target>
		<get_type set="method"><f a=""><c path="String"/></f></get_type>
		<isDefaultPrevented public="1" set="method"><f a=""><x path="Bool"/></f></isDefaultPrevented>
		<preventDefault public="1" set="method"><f a=""><x path="Void"/></f></preventDefault>
		<stopImmediatePropagation public="1" set="method"><f a=""><x path="Void"/></f></stopImmediatePropagation>
		<stopPropagation public="1" set="method"><f a=""><x path="Void"/></f></stopPropagation>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method">
			<f a="type:?bubbles:?cancelable" v=":false:false">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cancelable : false, bubbles : false }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="flash.events.EventPhase" params="" file="C:\HaxeToolkit\haxe\std/flash/events/EventPhase.hx">
		<this><x path="UInt"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.events.EventPhase"</e></m>
		</meta>
		<impl><class path="flash.events._EventPhase.EventPhase_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/events/EventPhase.hx" private="1" module="flash.events.EventPhase" extern="1" final="1">
	<AT_TARGET public="1" set="null" static="1">
		<x path="flash.events.EventPhase"/>
		<meta><m n=":enum"/></meta>
	</AT_TARGET>
	<BUBBLING_PHASE public="1" set="null" static="1">
		<x path="flash.events.EventPhase"/>
		<meta><m n=":enum"/></meta>
	</BUBBLING_PHASE>
	<CAPTURING_PHASE public="1" set="null" static="1">
		<x path="flash.events.EventPhase"/>
		<meta><m n=":enum"/></meta>
	</CAPTURING_PHASE>
	<meta>
		<m n=":native"><e>"flash.events.EventPhase"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.events._EventPhase.EventPhase_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/events/EventPhase.hx" private="1" module="flash.events.EventPhase" extern="1" final="1">
		<AT_TARGET public="1" set="null" static="1">
			<x path="flash.events.EventPhase"/>
			<meta><m n=":enum"/></meta>
		</AT_TARGET>
		<BUBBLING_PHASE public="1" set="null" static="1">
			<x path="flash.events.EventPhase"/>
			<meta><m n=":enum"/></meta>
		</BUBBLING_PHASE>
		<CAPTURING_PHASE public="1" set="null" static="1">
			<x path="flash.events.EventPhase"/>
			<meta><m n=":enum"/></meta>
		</CAPTURING_PHASE>
		<meta>
			<m n=":native"><e>"flash.events.EventPhase"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="flash.events.UncaughtErrorEvents" params="" file="C:\HaxeToolkit\haxe\std/flash/events/UncaughtErrorEvents.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<new public="1"><f a=""><x path="Void"/></f></new>
		<meta><m n=":require"><e>flash10_1</e></m></meta>
	</class>
	<class path="flash.external.ExternalInterface" params="" file="C:\HaxeToolkit\haxe\std/flash/external/ExternalInterface.hx" extern="1">
		<available public="1" get="accessor" set="null" static="1">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</available>
		<marshallExceptions public="1" static="1"><x path="Bool"/></marshallExceptions>
		<objectID public="1" get="accessor" set="null" static="1">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</objectID>
		<addCallback public="1" set="method" static="1"><f a="functionName:closure">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></addCallback>
		<call public="1" set="method" static="1"><f a="functionName:restArgs">
	<c path="String"/>
	<t path="haxe.extern.Rest"><d/></t>
	<d/>
</f></call>
		<get_available set="method" static="1"><f a=""><x path="Bool"/></f></get_available>
		<get_objectID set="method" static="1"><f a=""><c path="String"/></f></get_objectID>
	</class>
	<class path="flash.filters.BitmapFilter" params="" file="C:\HaxeToolkit\haxe\std/flash/filters/BitmapFilter.hx" extern="1">
		<clone public="1" set="method"><f a=""><c path="flash.filters.BitmapFilter"/></f></clone>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.geom.ColorTransform" params="" file="C:\HaxeToolkit\haxe\std/flash/geom/ColorTransform.hx" extern="1">
		<alphaMultiplier public="1"><x path="Float"/></alphaMultiplier>
		<alphaOffset public="1"><x path="Float"/></alphaOffset>
		<blueMultiplier public="1"><x path="Float"/></blueMultiplier>
		<blueOffset public="1"><x path="Float"/></blueOffset>
		<color public="1" get="accessor" set="accessor">
			<x path="UInt"/>
			<meta><m n=":flash.property"/></meta>
		</color>
		<greenMultiplier public="1"><x path="Float"/></greenMultiplier>
		<greenOffset public="1"><x path="Float"/></greenOffset>
		<redMultiplier public="1"><x path="Float"/></redMultiplier>
		<redOffset public="1"><x path="Float"/></redOffset>
		<concat public="1" set="method"><f a="second">
	<c path="flash.geom.ColorTransform"/>
	<x path="Void"/>
</f></concat>
		<get_color set="method"><f a=""><x path="UInt"/></f></get_color>
		<set_color set="method"><f a="value">
	<x path="UInt"/>
	<x path="UInt"/>
</f></set_color>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method">
			<f a="?redMultiplier:?greenMultiplier:?blueMultiplier:?alphaMultiplier:?redOffset:?greenOffset:?blueOffset:?alphaOffset" v="1:1:1:1:0:0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ alphaOffset : 0, blueOffset : 0, greenOffset : 0, redOffset : 0, alphaMultiplier : 1, blueMultiplier : 1, greenMultiplier : 1, redMultiplier : 1 }</e></m></meta>
		</new>
	</class>
	<class path="flash.geom.Matrix" params="" file="C:\HaxeToolkit\haxe\std/flash/geom/Matrix.hx" extern="1">
		<a public="1"><x path="Float"/></a>
		<b public="1"><x path="Float"/></b>
		<c public="1"><x path="Float"/></c>
		<d public="1"><x path="Float"/></d>
		<tx public="1"><x path="Float"/></tx>
		<ty public="1"><x path="Float"/></ty>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Matrix"/></f></clone>
		<concat public="1" set="method"><f a="m">
	<c path="flash.geom.Matrix"/>
	<x path="Void"/>
</f></concat>
		<copyColumnFrom public="1">
			<f a="column:vector3D">
				<x path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyColumnFrom>
		<copyColumnTo public="1">
			<f a="column:vector3D">
				<x path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyColumnTo>
		<copyFrom public="1">
			<f a="sourceMatrix">
				<c path="flash.geom.Matrix"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<copyRowFrom public="1">
			<f a="row:vector3D">
				<x path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRowFrom>
		<copyRowTo public="1">
			<f a="row:vector3D">
				<x path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRowTo>
		<createBox public="1" set="method">
			<f a="scaleX:scaleY:?rotation:?tx:?ty" v="::0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ ty : 0, tx : 0, rotation : 0 }</e></m></meta>
		</createBox>
		<createGradientBox public="1" set="method">
			<f a="width:height:?rotation:?tx:?ty" v="::0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ ty : 0, tx : 0, rotation : 0 }</e></m></meta>
		</createGradientBox>
		<deltaTransformPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></deltaTransformPoint>
		<identity public="1" set="method"><f a=""><x path="Void"/></f></identity>
		<invert public="1" set="method"><f a=""><x path="Void"/></f></invert>
		<rotate public="1" set="method"><f a="angle">
	<x path="Float"/>
	<x path="Void"/>
</f></rotate>
		<scale public="1" set="method"><f a="sx:sy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></scale>
		<setTo public="1">
			<f a="aa:ba:ca:da:txa:tya">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</setTo>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<transformPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></transformPoint>
		<translate public="1" set="method"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></translate>
		<new public="1" set="method">
			<f a="?a:?b:?c:?d:?tx:?ty" v="1:0:0:1:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ ty : 0, tx : 0, d : 1, c : 0, b : 0, a : 1 }</e></m></meta>
		</new>
	</class>
	<class path="flash.geom.Matrix3D" params="" file="C:\HaxeToolkit\haxe\std/flash/geom/Matrix3D.hx" extern="1">
		<interpolate public="1" set="method" static="1"><f a="thisMat:toMat:percent">
	<c path="flash.geom.Matrix3D"/>
	<c path="flash.geom.Matrix3D"/>
	<x path="Float"/>
	<c path="flash.geom.Matrix3D"/>
</f></interpolate>
		<determinant public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</determinant>
		<position public="1" get="accessor" set="accessor">
			<c path="flash.geom.Vector3D"/>
			<meta><m n=":flash.property"/></meta>
		</position>
		<rawData public="1" get="accessor" set="accessor">
			<c path="flash.Vector"><x path="Float"/></c>
			<meta><m n=":flash.property"/></meta>
		</rawData>
		<append public="1" set="method"><f a="lhs">
	<c path="flash.geom.Matrix3D"/>
	<x path="Void"/>
</f></append>
		<appendRotation public="1" set="method"><f a="degrees:axis:?pivotPoint">
	<x path="Float"/>
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></appendRotation>
		<appendScale public="1" set="method"><f a="xScale:yScale:zScale">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></appendScale>
		<appendTranslation public="1" set="method"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></appendTranslation>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Matrix3D"/></f></clone>
		<copyColumnFrom public="1">
			<f a="column:vector3D">
				<x path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyColumnFrom>
		<copyColumnTo public="1">
			<f a="column:vector3D">
				<x path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyColumnTo>
		<copyFrom public="1">
			<f a="sourceMatrix3D">
				<c path="flash.geom.Matrix3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<copyRawDataFrom public="1" expr="{ transpose : false, index : 0 }">
			<f a="vector:?index:?transpose">
				<c path="flash.Vector"><x path="Float"/></c>
				<x path="UInt"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ transpose : false, index : 0 }</e></m>
				<m n=":require"><e>flash11</e></m>
			</meta>
		</copyRawDataFrom>
		<copyRawDataTo public="1" expr="{ transpose : false, index : 0 }">
			<f a="vector:?index:?transpose">
				<c path="flash.Vector"><x path="Float"/></c>
				<x path="UInt"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ transpose : false, index : 0 }</e></m>
				<m n=":require"><e>flash11</e></m>
			</meta>
		</copyRawDataTo>
		<copyRowFrom public="1">
			<f a="row:vector3D">
				<x path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRowFrom>
		<copyRowTo public="1">
			<f a="row:vector3D">
				<x path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRowTo>
		<copyToMatrix3D public="1">
			<f a="dest">
				<c path="flash.geom.Matrix3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyToMatrix3D>
		<decompose public="1" set="method"><f a="?orientationStyle">
	<x path="flash.geom.Orientation3D"/>
	<c path="flash.Vector"><c path="flash.geom.Vector3D"/></c>
</f></decompose>
		<deltaTransformVector public="1" set="method"><f a="v">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></deltaTransformVector>
		<get_determinant set="method"><f a=""><x path="Float"/></f></get_determinant>
		<get_position set="method"><f a=""><c path="flash.geom.Vector3D"/></f></get_position>
		<get_rawData set="method"><f a=""><c path="flash.Vector"><x path="Float"/></c></f></get_rawData>
		<identity public="1" set="method"><f a=""><x path="Void"/></f></identity>
		<interpolateTo public="1" set="method"><f a="toMat:percent">
	<c path="flash.geom.Matrix3D"/>
	<x path="Float"/>
	<x path="Void"/>
</f></interpolateTo>
		<invert public="1" set="method"><f a=""><x path="Bool"/></f></invert>
		<pointAt public="1" set="method"><f a="pos:?at:?up">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></pointAt>
		<prepend public="1" set="method"><f a="rhs">
	<c path="flash.geom.Matrix3D"/>
	<x path="Void"/>
</f></prepend>
		<prependRotation public="1" set="method"><f a="degrees:axis:?pivotPoint">
	<x path="Float"/>
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></prependRotation>
		<prependScale public="1" set="method"><f a="xScale:yScale:zScale">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></prependScale>
		<prependTranslation public="1" set="method"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></prependTranslation>
		<recompose public="1" set="method"><f a="components:?orientationStyle">
	<c path="flash.Vector"><c path="flash.geom.Vector3D"/></c>
	<x path="flash.geom.Orientation3D"/>
	<x path="Bool"/>
</f></recompose>
		<set_position set="method"><f a="value">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></set_position>
		<set_rawData set="method"><f a="value">
	<c path="flash.Vector"><x path="Float"/></c>
	<c path="flash.Vector"><x path="Float"/></c>
</f></set_rawData>
		<transformVector public="1" set="method"><f a="v">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></transformVector>
		<transformVectors public="1" set="method"><f a="vin:vout">
	<c path="flash.Vector"><x path="Float"/></c>
	<c path="flash.Vector"><x path="Float"/></c>
	<x path="Void"/>
</f></transformVectors>
		<transpose public="1" set="method"><f a=""><x path="Void"/></f></transpose>
		<new public="1" set="method"><f a="?v">
	<c path="flash.Vector"><x path="Float"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<abstract path="flash.geom.Orientation3D" params="" file="C:\HaxeToolkit\haxe\std/flash/geom/Orientation3D.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.geom.Orientation3D"</e></m>
		</meta>
		<impl><class path="flash.geom._Orientation3D.Orientation3D_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/geom/Orientation3D.hx" private="1" module="flash.geom.Orientation3D" extern="1" final="1">
	<AXIS_ANGLE public="1" set="null" static="1">
		<x path="flash.geom.Orientation3D"/>
		<meta><m n=":enum"/></meta>
	</AXIS_ANGLE>
	<EULER_ANGLES public="1" set="null" static="1">
		<x path="flash.geom.Orientation3D"/>
		<meta><m n=":enum"/></meta>
	</EULER_ANGLES>
	<QUATERNION public="1" set="null" static="1">
		<x path="flash.geom.Orientation3D"/>
		<meta><m n=":enum"/></meta>
	</QUATERNION>
	<meta>
		<m n=":native"><e>"flash.geom.Orientation3D"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.geom._Orientation3D.Orientation3D_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/geom/Orientation3D.hx" private="1" module="flash.geom.Orientation3D" extern="1" final="1">
		<AXIS_ANGLE public="1" set="null" static="1">
			<x path="flash.geom.Orientation3D"/>
			<meta><m n=":enum"/></meta>
		</AXIS_ANGLE>
		<EULER_ANGLES public="1" set="null" static="1">
			<x path="flash.geom.Orientation3D"/>
			<meta><m n=":enum"/></meta>
		</EULER_ANGLES>
		<QUATERNION public="1" set="null" static="1">
			<x path="flash.geom.Orientation3D"/>
			<meta><m n=":enum"/></meta>
		</QUATERNION>
		<meta>
			<m n=":native"><e>"flash.geom.Orientation3D"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="flash.geom.PerspectiveProjection" params="" file="C:\HaxeToolkit\haxe\std/flash/geom/PerspectiveProjection.hx" extern="1">
		<fieldOfView public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</fieldOfView>
		<focalLength public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</focalLength>
		<projectionCenter public="1" get="accessor" set="accessor">
			<c path="flash.geom.Point"/>
			<meta><m n=":flash.property"/></meta>
		</projectionCenter>
		<get_fieldOfView set="method"><f a=""><x path="Float"/></f></get_fieldOfView>
		<get_focalLength set="method"><f a=""><x path="Float"/></f></get_focalLength>
		<get_projectionCenter set="method"><f a=""><c path="flash.geom.Point"/></f></get_projectionCenter>
		<set_fieldOfView set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_fieldOfView>
		<set_focalLength set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_focalLength>
		<set_projectionCenter set="method"><f a="value">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></set_projectionCenter>
		<toMatrix3D public="1" set="method"><f a=""><c path="flash.geom.Matrix3D"/></f></toMatrix3D>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<class path="flash.geom.Point" params="" file="C:\HaxeToolkit\haxe\std/flash/geom/Point.hx" extern="1">
		<distance public="1" set="method" static="1"><f a="pt1:pt2">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
	<x path="Float"/>
</f></distance>
		<interpolate public="1" set="method" static="1"><f a="pt1:pt2:f">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
	<x path="Float"/>
	<c path="flash.geom.Point"/>
</f></interpolate>
		<polar public="1" set="method" static="1"><f a="len:angle">
	<x path="Float"/>
	<x path="Float"/>
	<c path="flash.geom.Point"/>
</f></polar>
		<length public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</length>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<add public="1" set="method"><f a="v">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></add>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Point"/></f></clone>
		<copyFrom public="1">
			<f a="sourcePoint">
				<c path="flash.geom.Point"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<equals public="1" set="method"><f a="toCompare">
	<c path="flash.geom.Point"/>
	<x path="Bool"/>
</f></equals>
		<get_length set="method"><f a=""><x path="Float"/></f></get_length>
		<normalize public="1" set="method"><f a="thickness">
	<x path="Float"/>
	<x path="Void"/>
</f></normalize>
		<offset public="1" set="method"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></offset>
		<setTo public="1">
			<f a="xa:ya">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</setTo>
		<subtract public="1" set="method"><f a="v">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></subtract>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method">
			<f a="?x:?y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ y : 0, x : 0 }</e></m></meta>
		</new>
	</class>
	<class path="flash.geom.Rectangle" params="" file="C:\HaxeToolkit\haxe\std/flash/geom/Rectangle.hx" extern="1">
		<bottom public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</bottom>
		<bottomRight public="1" get="accessor" set="accessor">
			<c path="flash.geom.Point"/>
			<meta><m n=":flash.property"/></meta>
		</bottomRight>
		<height public="1"><x path="Float"/></height>
		<left public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</left>
		<right public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</right>
		<size public="1" get="accessor" set="accessor">
			<c path="flash.geom.Point"/>
			<meta><m n=":flash.property"/></meta>
		</size>
		<top public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</top>
		<topLeft public="1" get="accessor" set="accessor">
			<c path="flash.geom.Point"/>
			<meta><m n=":flash.property"/></meta>
		</topLeft>
		<width public="1"><x path="Float"/></width>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Rectangle"/></f></clone>
		<contains public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></contains>
		<containsPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<x path="Bool"/>
</f></containsPoint>
		<containsRect public="1" set="method"><f a="rect">
	<c path="flash.geom.Rectangle"/>
	<x path="Bool"/>
</f></containsRect>
		<copyFrom public="1">
			<f a="sourceRect">
				<c path="flash.geom.Rectangle"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<equals public="1" set="method"><f a="toCompare">
	<c path="flash.geom.Rectangle"/>
	<x path="Bool"/>
</f></equals>
		<get_bottom set="method"><f a=""><x path="Float"/></f></get_bottom>
		<get_bottomRight set="method"><f a=""><c path="flash.geom.Point"/></f></get_bottomRight>
		<get_left set="method"><f a=""><x path="Float"/></f></get_left>
		<get_right set="method"><f a=""><x path="Float"/></f></get_right>
		<get_size set="method"><f a=""><c path="flash.geom.Point"/></f></get_size>
		<get_top set="method"><f a=""><x path="Float"/></f></get_top>
		<get_topLeft set="method"><f a=""><c path="flash.geom.Point"/></f></get_topLeft>
		<inflate public="1" set="method"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></inflate>
		<inflatePoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<x path="Void"/>
</f></inflatePoint>
		<intersection public="1" set="method"><f a="toIntersect">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
</f></intersection>
		<intersects public="1" set="method"><f a="toIntersect">
	<c path="flash.geom.Rectangle"/>
	<x path="Bool"/>
</f></intersects>
		<isEmpty public="1" set="method"><f a=""><x path="Bool"/></f></isEmpty>
		<offset public="1" set="method"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></offset>
		<offsetPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<x path="Void"/>
</f></offsetPoint>
		<setEmpty public="1" set="method"><f a=""><x path="Void"/></f></setEmpty>
		<setTo public="1">
			<f a="xa:ya:widtha:heighta">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</setTo>
		<set_bottom set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_bottom>
		<set_bottomRight set="method"><f a="value">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></set_bottomRight>
		<set_left set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_left>
		<set_right set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_right>
		<set_size set="method"><f a="value">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></set_size>
		<set_top set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_top>
		<set_topLeft set="method"><f a="value">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></set_topLeft>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<union public="1" set="method"><f a="toUnion">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
</f></union>
		<new public="1" set="method">
			<f a="?x:?y:?width:?height" v="0:0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ height : 0, width : 0, y : 0, x : 0 }</e></m></meta>
		</new>
	</class>
	<class path="flash.geom.Transform" params="" file="C:\HaxeToolkit\haxe\std/flash/geom/Transform.hx" extern="1">
		<colorTransform public="1" get="accessor" set="accessor">
			<c path="flash.geom.ColorTransform"/>
			<meta><m n=":flash.property"/></meta>
		</colorTransform>
		<concatenatedColorTransform public="1" get="accessor" set="null">
			<c path="flash.geom.ColorTransform"/>
			<meta><m n=":flash.property"/></meta>
		</concatenatedColorTransform>
		<concatenatedMatrix public="1" get="accessor" set="null">
			<c path="flash.geom.Matrix"/>
			<meta><m n=":flash.property"/></meta>
		</concatenatedMatrix>
		<matrix public="1" get="accessor" set="accessor">
			<c path="flash.geom.Matrix"/>
			<meta><m n=":flash.property"/></meta>
		</matrix>
		<matrix3D public="1" get="accessor" set="accessor">
			<c path="flash.geom.Matrix3D"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</matrix3D>
		<perspectiveProjection public="1" get="accessor" set="accessor">
			<c path="flash.geom.PerspectiveProjection"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</perspectiveProjection>
		<pixelBounds public="1" get="accessor" set="null">
			<c path="flash.geom.Rectangle"/>
			<meta><m n=":flash.property"/></meta>
		</pixelBounds>
		<getRelativeMatrix3D public="1" set="method">
			<f a="relativeTo">
				<c path="flash.display.DisplayObject"/>
				<c path="flash.geom.Matrix3D"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</getRelativeMatrix3D>
		<get_colorTransform set="method"><f a=""><c path="flash.geom.ColorTransform"/></f></get_colorTransform>
		<get_concatenatedColorTransform set="method"><f a=""><c path="flash.geom.ColorTransform"/></f></get_concatenatedColorTransform>
		<get_concatenatedMatrix set="method"><f a=""><c path="flash.geom.Matrix"/></f></get_concatenatedMatrix>
		<get_matrix set="method"><f a=""><c path="flash.geom.Matrix"/></f></get_matrix>
		<get_matrix3D set="method"><f a=""><c path="flash.geom.Matrix3D"/></f></get_matrix3D>
		<get_perspectiveProjection set="method"><f a=""><c path="flash.geom.PerspectiveProjection"/></f></get_perspectiveProjection>
		<get_pixelBounds set="method"><f a=""><c path="flash.geom.Rectangle"/></f></get_pixelBounds>
		<set_colorTransform set="method"><f a="value">
	<c path="flash.geom.ColorTransform"/>
	<c path="flash.geom.ColorTransform"/>
</f></set_colorTransform>
		<set_matrix set="method"><f a="value">
	<c path="flash.geom.Matrix"/>
	<c path="flash.geom.Matrix"/>
</f></set_matrix>
		<set_matrix3D set="method"><f a="value">
	<c path="flash.geom.Matrix3D"/>
	<c path="flash.geom.Matrix3D"/>
</f></set_matrix3D>
		<set_perspectiveProjection set="method"><f a="value">
	<c path="flash.geom.PerspectiveProjection"/>
	<c path="flash.geom.PerspectiveProjection"/>
</f></set_perspectiveProjection>
		<new public="1" set="method"><f a="displayObject">
	<c path="flash.display.DisplayObject"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Vector3D" params="" file="C:\HaxeToolkit\haxe\std/flash/geom/Vector3D.hx" extern="1">
		<X_AXIS final="1" public="1" set="null" static="1"><c path="flash.geom.Vector3D"/></X_AXIS>
		<Y_AXIS final="1" public="1" set="null" static="1"><c path="flash.geom.Vector3D"/></Y_AXIS>
		<Z_AXIS final="1" public="1" set="null" static="1"><c path="flash.geom.Vector3D"/></Z_AXIS>
		<angleBetween public="1" set="method" static="1"><f a="a:b">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<x path="Float"/>
</f></angleBetween>
		<distance public="1" set="method" static="1"><f a="pt1:pt2">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<x path="Float"/>
</f></distance>
		<length public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</length>
		<lengthSquared public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</lengthSquared>
		<w public="1"><x path="Float"/></w>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<z public="1"><x path="Float"/></z>
		<add public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></add>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Vector3D"/></f></clone>
		<copyFrom public="1">
			<f a="sourceVector3D">
				<c path="flash.geom.Vector3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<crossProduct public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></crossProduct>
		<decrementBy public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></decrementBy>
		<dotProduct public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<x path="Float"/>
</f></dotProduct>
		<equals public="1" set="method">
			<f a="toCompare:?allFour" v=":false">
				<c path="flash.geom.Vector3D"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ allFour : false }</e></m></meta>
		</equals>
		<get_length set="method"><f a=""><x path="Float"/></f></get_length>
		<get_lengthSquared set="method"><f a=""><x path="Float"/></f></get_lengthSquared>
		<incrementBy public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></incrementBy>
		<nearEquals public="1" set="method">
			<f a="toCompare:tolerance:?allFour" v="::false">
				<c path="flash.geom.Vector3D"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ allFour : false }</e></m></meta>
		</nearEquals>
		<negate public="1" set="method"><f a=""><x path="Void"/></f></negate>
		<normalize public="1" set="method"><f a=""><x path="Float"/></f></normalize>
		<project public="1" set="method"><f a=""><x path="Void"/></f></project>
		<scaleBy public="1" set="method"><f a="s">
	<x path="Float"/>
	<x path="Void"/>
</f></scaleBy>
		<setTo public="1">
			<f a="xa:ya:za">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</setTo>
		<subtract public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></subtract>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method">
			<f a="?x:?y:?z:?w" v="0:0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ w : 0, z : 0, y : 0, x : 0 }</e></m></meta>
		</new>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<class path="flash.media.AVCaptionStyle" params="" file="C:\HaxeToolkit\haxe\std/flash/media/AVCaptionStyle.hx" extern="1">
		<BLACK final="1" public="1" set="null" static="1"><c path="String"/></BLACK>
		<BLUE final="1" public="1" set="null" static="1"><c path="String"/></BLUE>
		<BRIGHT_BLUE final="1" public="1" set="null" static="1"><c path="String"/></BRIGHT_BLUE>
		<BRIGHT_CYAN final="1" public="1" set="null" static="1"><c path="String"/></BRIGHT_CYAN>
		<BRIGHT_GREEN final="1" public="1" set="null" static="1"><c path="String"/></BRIGHT_GREEN>
		<BRIGHT_MAGENTA final="1" public="1" set="null" static="1"><c path="String"/></BRIGHT_MAGENTA>
		<BRIGHT_RED final="1" public="1" set="null" static="1"><c path="String"/></BRIGHT_RED>
		<BRIGHT_WHITE final="1" public="1" set="null" static="1"><c path="String"/></BRIGHT_WHITE>
		<BRIGHT_YELLOW final="1" public="1" set="null" static="1"><c path="String"/></BRIGHT_YELLOW>
		<CASUAL final="1" public="1" set="null" static="1"><c path="String"/></CASUAL>
		<CURSIVE final="1" public="1" set="null" static="1"><c path="String"/></CURSIVE>
		<CYAN final="1" public="1" set="null" static="1"><c path="String"/></CYAN>
		<DARK_BLUE final="1" public="1" set="null" static="1"><c path="String"/></DARK_BLUE>
		<DARK_CYAN final="1" public="1" set="null" static="1"><c path="String"/></DARK_CYAN>
		<DARK_GREEN final="1" public="1" set="null" static="1"><c path="String"/></DARK_GREEN>
		<DARK_MAGENTA final="1" public="1" set="null" static="1"><c path="String"/></DARK_MAGENTA>
		<DARK_RED final="1" public="1" set="null" static="1"><c path="String"/></DARK_RED>
		<DARK_YELLOW final="1" public="1" set="null" static="1"><c path="String"/></DARK_YELLOW>
		<DEFAULT final="1" public="1" set="null" static="1"><c path="String"/></DEFAULT>
		<DEPRESSED final="1" public="1" set="null" static="1"><c path="String"/></DEPRESSED>
		<GRAY final="1" public="1" set="null" static="1"><c path="String"/></GRAY>
		<GREEN final="1" public="1" set="null" static="1"><c path="String"/></GREEN>
		<LARGE final="1" public="1" set="null" static="1"><c path="String"/></LARGE>
		<LEFT_DROP_SHADOW final="1" public="1" set="null" static="1"><c path="String"/></LEFT_DROP_SHADOW>
		<MAGENTA final="1" public="1" set="null" static="1"><c path="String"/></MAGENTA>
		<MEDIUM final="1" public="1" set="null" static="1"><c path="String"/></MEDIUM>
		<MONOSPACED_WITHOUT_SERIFS final="1" public="1" set="null" static="1"><c path="String"/></MONOSPACED_WITHOUT_SERIFS>
		<MONOSPACE_WITH_SERIFS final="1" public="1" set="null" static="1"><c path="String"/></MONOSPACE_WITH_SERIFS>
		<NONE final="1" public="1" set="null" static="1"><c path="String"/></NONE>
		<PROPORTIONAL_WITHOUT_SERIFS final="1" public="1" set="null" static="1"><c path="String"/></PROPORTIONAL_WITHOUT_SERIFS>
		<PROPORTIONAL_WITH_SERIFS final="1" public="1" set="null" static="1"><c path="String"/></PROPORTIONAL_WITH_SERIFS>
		<RAISED final="1" public="1" set="null" static="1"><c path="String"/></RAISED>
		<RED final="1" public="1" set="null" static="1"><c path="String"/></RED>
		<RIGHT_DROP_SHADOW final="1" public="1" set="null" static="1"><c path="String"/></RIGHT_DROP_SHADOW>
		<SMALL final="1" public="1" set="null" static="1"><c path="String"/></SMALL>
		<SMALL_CAPITALS final="1" public="1" set="null" static="1"><c path="String"/></SMALL_CAPITALS>
		<UNIFORM final="1" public="1" set="null" static="1"><c path="String"/></UNIFORM>
		<WHITE final="1" public="1" set="null" static="1"><c path="String"/></WHITE>
		<YELLOW final="1" public="1" set="null" static="1"><c path="String"/></YELLOW>
		<backgroundColor public="1" get="accessor" set="accessor">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</backgroundColor>
		<backgroundOpacity public="1" get="accessor" set="accessor">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</backgroundOpacity>
		<bottomInset public="1" get="accessor" set="accessor">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</bottomInset>
		<edgeColor public="1" get="accessor" set="accessor">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</edgeColor>
		<fillColor public="1" get="accessor" set="accessor">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</fillColor>
		<fillOpacity public="1" get="accessor" set="accessor">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</fillOpacity>
		<font public="1" get="accessor" set="accessor">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</font>
		<fontColor public="1" get="accessor" set="accessor">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</fontColor>
		<fontEdge public="1" get="accessor" set="accessor">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</fontEdge>
		<fontOpacity public="1" get="accessor" set="accessor">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</fontOpacity>
		<size public="1" get="accessor" set="accessor">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</size>
		<get_backgroundColor set="method"><f a=""><c path="String"/></f></get_backgroundColor>
		<get_backgroundOpacity set="method"><f a=""><c path="String"/></f></get_backgroundOpacity>
		<get_bottomInset set="method"><f a=""><c path="String"/></f></get_bottomInset>
		<get_edgeColor set="method"><f a=""><c path="String"/></f></get_edgeColor>
		<get_fillColor set="method"><f a=""><c path="String"/></f></get_fillColor>
		<get_fillOpacity set="method"><f a=""><c path="String"/></f></get_fillOpacity>
		<get_font set="method"><f a=""><c path="String"/></f></get_font>
		<get_fontColor set="method"><f a=""><c path="String"/></f></get_fontColor>
		<get_fontEdge set="method"><f a=""><c path="String"/></f></get_fontEdge>
		<get_fontOpacity set="method"><f a=""><c path="String"/></f></get_fontOpacity>
		<get_size set="method"><f a=""><c path="String"/></f></get_size>
		<set_backgroundColor set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_backgroundColor>
		<set_backgroundOpacity set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_backgroundOpacity>
		<set_bottomInset set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_bottomInset>
		<set_edgeColor set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_edgeColor>
		<set_fillColor set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_fillColor>
		<set_fillOpacity set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_fillOpacity>
		<set_font set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_font>
		<set_fontColor set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_fontColor>
		<set_fontEdge set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_fontEdge>
		<set_fontOpacity set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_fontOpacity>
		<set_size set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_size>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.media.AVPlayState" params="" file="C:\HaxeToolkit\haxe\std/flash/media/AVPlayState.hx" extern="1">
		<BUFFERING final="1" public="1" set="null" static="1"><x path="Int"/></BUFFERING>
		<EOF final="1" public="1" set="null" static="1"><x path="Int"/></EOF>
		<PAUSED final="1" public="1" set="null" static="1"><x path="Int"/></PAUSED>
		<PLAYING final="1" public="1" set="null" static="1"><x path="Int"/></PLAYING>
		<READY final="1" public="1" set="null" static="1"><x path="Int"/></READY>
		<SUSPENDED final="1" public="1" set="null" static="1"><x path="Int"/></SUSPENDED>
		<TRICK_PLAY final="1" public="1" set="null" static="1"><x path="Int"/></TRICK_PLAY>
		<UNINITIALIZED final="1" public="1" set="null" static="1"><x path="Int"/></UNINITIALIZED>
		<UNRECOVERABLE_ERROR final="1" public="1" set="null" static="1"><x path="Int"/></UNRECOVERABLE_ERROR>
		<state public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</state>
		<get_state set="method"><f a=""><x path="Int"/></f></get_state>
		<new public="1" set="method"><f a="state">
	<x path="UInt"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.media.AVResult" params="" file="C:\HaxeToolkit\haxe\std/flash/media/AVResult.hx" extern="1">
		<ASYNC_OPERATION_IN_PROGRESS final="1" public="1" set="null" static="1"><x path="Int"/></ASYNC_OPERATION_IN_PROGRESS>
		<AUDIO_ONLY_STREAM_END final="1" public="1" set="null" static="1"><x path="Int"/></AUDIO_ONLY_STREAM_END>
		<AUDIO_ONLY_STREAM_START final="1" public="1" set="null" static="1"><x path="Int"/></AUDIO_ONLY_STREAM_START>
		<AUDIO_START_ERROR final="1" public="1" set="null" static="1"><x path="Int"/></AUDIO_START_ERROR>
		<BAD_MANIFEST_SIGNATURE final="1" public="1" set="null" static="1"><x path="Int"/></BAD_MANIFEST_SIGNATURE>
		<BAD_MEDIASAMPLE_FOUND final="1" public="1" set="null" static="1"><x path="Int"/></BAD_MEDIASAMPLE_FOUND>
		<BAD_MEDIA_INTERLEAVING final="1" public="1" set="null" static="1"><x path="Int"/></BAD_MEDIA_INTERLEAVING>
		<CALLED_FROM_WRONG_THREAD final="1" public="1" set="null" static="1"><x path="Int"/></CALLED_FROM_WRONG_THREAD>
		<CANNOT_ERASE_TIMELINE final="1" public="1" set="null" static="1"><x path="Int"/></CANNOT_ERASE_TIMELINE>
		<CANNOT_FAIL_OVER final="1" public="1" set="null" static="1"><x path="Int"/></CANNOT_FAIL_OVER>
		<CANNOT_HANDLE_MAIN_MANIFEST_UPDATE final="1" public="1" set="null" static="1"><x path="Int"/></CANNOT_HANDLE_MAIN_MANIFEST_UPDATE>
		<CANNOT_LOAD_PLAY_LIST final="1" public="1" set="null" static="1"><x path="Int"/></CANNOT_LOAD_PLAY_LIST>
		<CANNOT_SPLIT_TIMELINE final="1" public="1" set="null" static="1"><x path="Int"/></CANNOT_SPLIT_TIMELINE>
		<CODEC_NOT_SUPPORTED final="1" public="1" set="null" static="1"><x path="Int"/></CODEC_NOT_SUPPORTED>
		<COMPONENT_CREATION_FAILURE final="1" public="1" set="null" static="1"><x path="Int"/></COMPONENT_CREATION_FAILURE>
		<CONTAINER_NOT_SUPPORTED final="1" public="1" set="null" static="1"><x path="Int"/></CONTAINER_NOT_SUPPORTED>
		<CONTENT_LENGTH_MISMATCH final="1" public="1" set="null" static="1"><x path="Int"/></CONTENT_LENGTH_MISMATCH>
		<CRYPTO_ALGORITHM_NOT_SUPPORTED final="1" public="1" set="null" static="1"><x path="Int"/></CRYPTO_ALGORITHM_NOT_SUPPORTED>
		<CRYPTO_ERROR_BAD_CERTIFICATE final="1" public="1" set="null" static="1"><x path="Int"/></CRYPTO_ERROR_BAD_CERTIFICATE>
		<CRYPTO_ERROR_BAD_PARAMETER final="1" public="1" set="null" static="1"><x path="Int"/></CRYPTO_ERROR_BAD_PARAMETER>
		<CRYPTO_ERROR_BUFFER_TOO_SMALL final="1" public="1" set="null" static="1"><x path="Int"/></CRYPTO_ERROR_BUFFER_TOO_SMALL>
		<CRYPTO_ERROR_CORRUPTED_DATA final="1" public="1" set="null" static="1"><x path="Int"/></CRYPTO_ERROR_CORRUPTED_DATA>
		<CRYPTO_ERROR_DIGEST_FINISH final="1" public="1" set="null" static="1"><x path="Int"/></CRYPTO_ERROR_DIGEST_FINISH>
		<CRYPTO_ERROR_DIGEST_UPDATE final="1" public="1" set="null" static="1"><x path="Int"/></CRYPTO_ERROR_DIGEST_UPDATE>
		<CRYPTO_ERROR_UNKNOWN final="1" public="1" set="null" static="1"><x path="Int"/></CRYPTO_ERROR_UNKNOWN>
		<CURRENT_PERIOD_EXPIRED final="1" public="1" set="null" static="1"><x path="Int"/></CURRENT_PERIOD_EXPIRED>
		<DECODER_FAILED final="1" public="1" set="null" static="1"><x path="Int"/></DECODER_FAILED>
		<DEVICE_OPEN_ERROR final="1" public="1" set="null" static="1"><x path="Int"/></DEVICE_OPEN_ERROR>
		<DID_NOT_GET_NEXT_FRAGMENT final="1" public="1" set="null" static="1"><x path="Int"/></DID_NOT_GET_NEXT_FRAGMENT>
		<DRM_INIT_ERROR final="1" public="1" set="null" static="1"><x path="Int"/></DRM_INIT_ERROR>
		<DRM_NOT_AVAILABLE final="1" public="1" set="null" static="1"><x path="Int"/></DRM_NOT_AVAILABLE>
		<END_OF_PERIOD final="1" public="1" set="null" static="1"><x path="Int"/></END_OF_PERIOD>
		<EOF final="1" public="1" set="null" static="1"><x path="Int"/></EOF>
		<FILE_NOT_FOUND final="1" public="1" set="null" static="1"><x path="Int"/></FILE_NOT_FOUND>
		<FILE_OPEN_ERROR final="1" public="1" set="null" static="1"><x path="Int"/></FILE_OPEN_ERROR>
		<FILE_READ_ERROR final="1" public="1" set="null" static="1"><x path="Int"/></FILE_READ_ERROR>
		<FILE_STRUCTURE_INVALID final="1" public="1" set="null" static="1"><x path="Int"/></FILE_STRUCTURE_INVALID>
		<FILE_WRITE_ERROR final="1" public="1" set="null" static="1"><x path="Int"/></FILE_WRITE_ERROR>
		<FRAGMENT_READ_ERROR final="1" public="1" set="null" static="1"><x path="Int"/></FRAGMENT_READ_ERROR>
		<GENERIC_ERROR final="1" public="1" set="null" static="1"><x path="Int"/></GENERIC_ERROR>
		<HTTP_TIME_OUT final="1" public="1" set="null" static="1"><x path="Int"/></HTTP_TIME_OUT>
		<ID3_PARSE_ERROR final="1" public="1" set="null" static="1"><x path="Int"/></ID3_PARSE_ERROR>
		<INCOMPATIBLE_RENDER_MODE final="1" public="1" set="null" static="1"><x path="Int"/></INCOMPATIBLE_RENDER_MODE>
		<INCOMPATIBLE_VERSION final="1" public="1" set="null" static="1"><x path="Int"/></INCOMPATIBLE_VERSION>
		<INTERNAL_ERROR final="1" public="1" set="null" static="1"><x path="Int"/></INTERNAL_ERROR>
		<INVALID_KEY final="1" public="1" set="null" static="1"><x path="Int"/></INVALID_KEY>
		<INVALID_OPERATION final="1" public="1" set="null" static="1"><x path="Int"/></INVALID_OPERATION>
		<INVALID_PARAMETER final="1" public="1" set="null" static="1"><x path="Int"/></INVALID_PARAMETER>
		<INVALID_REPLACE_DURATION final="1" public="1" set="null" static="1"><x path="Int"/></INVALID_REPLACE_DURATION>
		<INVALID_SEEK_TIME final="1" public="1" set="null" static="1"><x path="Int"/></INVALID_SEEK_TIME>
		<INVALID_WITH_AUDIO_ONLY_FILE final="1" public="1" set="null" static="1"><x path="Int"/></INVALID_WITH_AUDIO_ONLY_FILE>
		<IRRECOVERABLE_ERROR final="1" public="1" set="null" static="1"><x path="Int"/></IRRECOVERABLE_ERROR>
		<KEY_NOT_FOUND final="1" public="1" set="null" static="1"><x path="Int"/></KEY_NOT_FOUND>
		<KEY_SERVER_NOT_FOUND final="1" public="1" set="null" static="1"><x path="Int"/></KEY_SERVER_NOT_FOUND>
		<LISTENER_NOT_FOUND final="1" public="1" set="null" static="1"><x path="Int"/></LISTENER_NOT_FOUND>
		<LIVE_HOLD final="1" public="1" set="null" static="1"><x path="Int"/></LIVE_HOLD>
		<LIVE_WINDOW_MOVED_BACKWARD final="1" public="1" set="null" static="1"><x path="Int"/></LIVE_WINDOW_MOVED_BACKWARD>
		<LOST_CONNECTION_RECOVERABLE final="1" public="1" set="null" static="1"><x path="Int"/></LOST_CONNECTION_RECOVERABLE>
		<MAIN_MANIFEST_UPDATE_TO_BE_HANDLED final="1" public="1" set="null" static="1"><x path="Int"/></MAIN_MANIFEST_UPDATE_TO_BE_HANDLED>
		<MANIFEST_FILE_UNEXPECTEDLY_CHANGED final="1" public="1" set="null" static="1"><x path="Int"/></MANIFEST_FILE_UNEXPECTEDLY_CHANGED>
		<NETWORK_DOWN final="1" public="1" set="null" static="1"><x path="Int"/></NETWORK_DOWN>
		<NETWORK_ERROR final="1" public="1" set="null" static="1"><x path="Int"/></NETWORK_ERROR>
		<NETWORK_UNAVAILABLE final="1" public="1" set="null" static="1"><x path="Int"/></NETWORK_UNAVAILABLE>
		<NOT_IMPLEMENTED final="1" public="1" set="null" static="1"><x path="Int"/></NOT_IMPLEMENTED>
		<NO_AUDIO_SINK final="1" public="1" set="null" static="1"><x path="Int"/></NO_AUDIO_SINK>
		<NO_FIXED_SIZE final="1" public="1" set="null" static="1"><x path="Int"/></NO_FIXED_SIZE>
		<NO_TIMELINE final="1" public="1" set="null" static="1"><x path="Int"/></NO_TIMELINE>
		<NO_USEABLE_BITRATE_PROFILE final="1" public="1" set="null" static="1"><x path="Int"/></NO_USEABLE_BITRATE_PROFILE>
		<NULL_OPERATION final="1" public="1" set="null" static="1"><x path="Int"/></NULL_OPERATION>
		<ONLY_ALLOWED_IN_PAUSED_STATE final="1" public="1" set="null" static="1"><x path="Int"/></ONLY_ALLOWED_IN_PAUSED_STATE>
		<OPERATION_ABORTED final="1" public="1" set="null" static="1"><x path="Int"/></OPERATION_ABORTED>
		<OUT_OF_MEMORY final="1" public="1" set="null" static="1"><x path="Int"/></OUT_OF_MEMORY>
		<OVERFLOW final="1" public="1" set="null" static="1"><x path="Int"/></OVERFLOW>
		<PARSE_ERROR final="1" public="1" set="null" static="1"><x path="Int"/></PARSE_ERROR>
		<PARTIAL_REPLACEMENT final="1" public="1" set="null" static="1"><x path="Int"/></PARTIAL_REPLACEMENT>
		<PERIOD_HOLD final="1" public="1" set="null" static="1"><x path="Int"/></PERIOD_HOLD>
		<PERIOD_NOT_LOADED final="1" public="1" set="null" static="1"><x path="Int"/></PERIOD_NOT_LOADED>
		<PLAYBACK_NOT_ENABLED final="1" public="1" set="null" static="1"><x path="Int"/></PLAYBACK_NOT_ENABLED>
		<POSTROLL_WITH_LIVE_NOT_ALLOWED final="1" public="1" set="null" static="1"><x path="Int"/></POSTROLL_WITH_LIVE_NOT_ALLOWED>
		<PREVIOUS_STEP_SEEK_IN_PROGRESS final="1" public="1" set="null" static="1"><x path="Int"/></PREVIOUS_STEP_SEEK_IN_PROGRESS>
		<PROTOCOL_NOT_SUPPORTED final="1" public="1" set="null" static="1"><x path="Int"/></PROTOCOL_NOT_SUPPORTED>
		<RANGE_ERROR final="1" public="1" set="null" static="1"><x path="Int"/></RANGE_ERROR>
		<RANGE_SPANS_READHEAD final="1" public="1" set="null" static="1"><x path="Int"/></RANGE_SPANS_READHEAD>
		<RENDITION_M3U8_ERROR final="1" public="1" set="null" static="1"><x path="Int"/></RENDITION_M3U8_ERROR>
		<REPLACEMENT_FAILED final="1" public="1" set="null" static="1"><x path="Int"/></REPLACEMENT_FAILED>
		<RESOURCE_NOT_SPECIFIED final="1" public="1" set="null" static="1"><x path="Int"/></RESOURCE_NOT_SPECIFIED>
		<SECURITY_ERROR final="1" public="1" set="null" static="1"><x path="Int"/></SECURITY_ERROR>
		<SEEK_FAILED final="1" public="1" set="null" static="1"><x path="Int"/></SEEK_FAILED>
		<SEGMENT_SKIPPED_ON_FAILURE final="1" public="1" set="null" static="1"><x path="Int"/></SEGMENT_SKIPPED_ON_FAILURE>
		<SIZE_UNKNOWN final="1" public="1" set="null" static="1"><x path="Int"/></SIZE_UNKNOWN>
		<SPS_PPS_FOUND_OUTSIDE_AVCC final="1" public="1" set="null" static="1"><x path="Int"/></SPS_PPS_FOUND_OUTSIDE_AVCC>
		<SUCCESS final="1" public="1" set="null" static="1"><x path="Int"/></SUCCESS>
		<SWITCH_TO_ASYMMETRIC_PROFILE final="1" public="1" set="null" static="1"><x path="Int"/></SWITCH_TO_ASYMMETRIC_PROFILE>
		<TIMELINE_TOO_SHORT final="1" public="1" set="null" static="1"><x path="Int"/></TIMELINE_TOO_SHORT>
		<UNDERFLOW final="1" public="1" set="null" static="1"><x path="Int"/></UNDERFLOW>
		<UNREPORTED_TIME_DISCONTINUITY_FOUND final="1" public="1" set="null" static="1"><x path="Int"/></UNREPORTED_TIME_DISCONTINUITY_FOUND>
		<UNSUPPORTED_CONFIGURATION final="1" public="1" set="null" static="1"><x path="Int"/></UNSUPPORTED_CONFIGURATION>
		<UNSUPPORTED_HLS_VERSION final="1" public="1" set="null" static="1"><x path="Int"/></UNSUPPORTED_HLS_VERSION>
		<UNSUPPORTED_OPERATION final="1" public="1" set="null" static="1"><x path="Int"/></UNSUPPORTED_OPERATION>
		<VIDEO_PROFILE_NOT_SUPPORTED final="1" public="1" set="null" static="1"><x path="Int"/></VIDEO_PROFILE_NOT_SUPPORTED>
		<WAITING_FOR_INIT final="1" public="1" set="null" static="1"><x path="Int"/></WAITING_FOR_INIT>
		<result public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</result>
		<get_result set="method"><f a=""><x path="Int"/></f></get_result>
		<new public="1" set="method"><f a="inResult">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.media.AVSource" params="" file="C:\HaxeToolkit\haxe\std/flash/media/AVSource.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.media.AVStream" params="" file="C:\HaxeToolkit\haxe\std/flash/media/AVStream.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<HARDWARE final="1" public="1" set="null" static="1"><c path="String"/></HARDWARE>
		<SOFTWARE final="1" public="1" set="null" static="1"><c path="String"/></SOFTWARE>
		<UNDEFINED final="1" public="1" set="null" static="1"><c path="String"/></UNDEFINED>
		<backBufferLength public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</backBufferLength>
		<backBufferTime public="1" get="null" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</backBufferTime>
		<bufferLength public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</bufferLength>
		<bufferTime public="1" get="null" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</bufferTime>
		<captionStyle public="1" get="null" set="accessor">
			<c path="flash.media.AVCaptionStyle"/>
			<meta><m n=":flash.property"/></meta>
		</captionStyle>
		<captionsEnabled public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</captionsEnabled>
		<clientLivePoint public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</clientLivePoint>
		<currentFPS public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</currentFPS>
		<decoderType public="1" get="accessor" set="null">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</decoderType>
		<droppedFrames public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</droppedFrames>
		<frameTime public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</frameTime>
		<initialBufferTime public="1" get="null" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</initialBufferTime>
		<playState public="1" get="accessor" set="null">
			<c path="flash.media.AVPlayState"/>
			<meta><m n=":flash.property"/></meta>
		</playState>
		<renderType public="1" get="accessor" set="null">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</renderType>
		<time public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</time>
		<useHardwareDecoder public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</useHardwareDecoder>
		<volume public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</volume>
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<fastForward public="1" set="method"><f a="rate">
	<x path="Float"/>
	<c path="flash.media.AVResult"/>
</f></fastForward>
		<get_backBufferLength set="method"><f a=""><x path="Float"/></f></get_backBufferLength>
		<get_bufferLength set="method"><f a=""><x path="Float"/></f></get_bufferLength>
		<get_captionsEnabled set="method"><f a=""><x path="Bool"/></f></get_captionsEnabled>
		<get_clientLivePoint set="method"><f a=""><x path="Float"/></f></get_clientLivePoint>
		<get_currentFPS set="method"><f a=""><x path="Float"/></f></get_currentFPS>
		<get_decoderType set="method"><f a=""><c path="String"/></f></get_decoderType>
		<get_droppedFrames set="method"><f a=""><x path="Int"/></f></get_droppedFrames>
		<get_frameTime set="method"><f a=""><x path="Float"/></f></get_frameTime>
		<get_playState set="method"><f a=""><c path="flash.media.AVPlayState"/></f></get_playState>
		<get_renderType set="method"><f a=""><c path="String"/></f></get_renderType>
		<get_time set="method"><f a=""><x path="Float"/></f></get_time>
		<get_useHardwareDecoder set="method"><f a=""><x path="Bool"/></f></get_useHardwareDecoder>
		<get_volume set="method"><f a=""><x path="Float"/></f></get_volume>
		<pause public="1" set="method"><f a=""><c path="flash.media.AVResult"/></f></pause>
		<play public="1" set="method"><f a=""><c path="flash.media.AVResult"/></f></play>
		<resume public="1" set="method"><f a=""><x path="Bool"/></f></resume>
		<rewind public="1" set="method"><f a="rate">
	<x path="Float"/>
	<c path="flash.media.AVResult"/>
</f></rewind>
		<seek public="1" set="method">
			<f a="offset:?inBufferSeek" v=":true">
				<x path="Float"/>
				<x path="Bool"/>
				<c path="flash.media.AVResult"/>
			</f>
			<meta><m n=":value"><e>{ inBufferSeek : true }</e></m></meta>
		</seek>
		<seekToKeyFrame public="1" set="method">
			<f a="offset:?inBufferSeek" v=":true">
				<x path="Float"/>
				<x path="Bool"/>
				<c path="flash.media.AVResult"/>
			</f>
			<meta><m n=":value"><e>{ inBufferSeek : true }</e></m></meta>
		</seekToKeyFrame>
		<seekToLivePoint public="1" set="method"><f a=""><c path="flash.media.AVResult"/></f></seekToLivePoint>
		<seekToLocalTime public="1" set="method"><f a="periodIndex:time">
	<x path="Int"/>
	<x path="Float"/>
	<c path="flash.media.AVResult"/>
</f></seekToLocalTime>
		<setPlaySpeed public="1" set="method"><f a="speed:reserved">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setPlaySpeed>
		<set_backBufferTime set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_backBufferTime>
		<set_bufferTime set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_bufferTime>
		<set_captionStyle set="method"><f a="value">
	<c path="flash.media.AVCaptionStyle"/>
	<c path="flash.media.AVCaptionStyle"/>
</f></set_captionStyle>
		<set_captionsEnabled set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_captionsEnabled>
		<set_initialBufferTime set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_initialBufferTime>
		<set_useHardwareDecoder set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_useHardwareDecoder>
		<set_volume set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_volume>
		<step public="1" set="method"><f a="frames">
	<x path="Int"/>
	<c path="flash.media.AVResult"/>
</f></step>
		<new public="1" set="method"><f a="source">
	<c path="flash.media.AVSource"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.media.Camera" params="" file="C:\HaxeToolkit\haxe\std/flash/media/Camera.hx" extern="1" final="1">
		<extends path="flash.events.EventDispatcher"/>
		<isSupported public="1" static="1">
			<x path="Bool"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</isSupported>
		<names public="1" get="accessor" set="null" static="1">
			<c path="Array"><d/></c>
			<meta><m n=":flash.property"/></meta>
		</names>
		<_scanHardware public="1" static="1">
			<f a=""><x path="Void"/></f>
			<meta>
				<m n=":ns">
					<e>"flash.media"</e>
					<e>internal</e>
				</m>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</_scanHardware>
		<getCamera public="1" set="method" static="1"><f a="?name">
	<c path="String"/>
	<c path="flash.media.Camera"/>
</f></getCamera>
		<get_isSupported set="method" static="1"><f a=""><x path="Bool"/></f></get_isSupported>
		<get_names set="method" static="1"><f a=""><c path="Array"><d/></c></f></get_names>
		<activityLevel public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</activityLevel>
		<bandwidth public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</bandwidth>
		<currentFPS public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</currentFPS>
		<fps public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</fps>
		<height public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</height>
		<index public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</index>
		<keyFrameInterval public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</keyFrameInterval>
		<loopback public="1" get="accessor" set="null">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</loopback>
		<motionLevel public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</motionLevel>
		<motionTimeout public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</motionTimeout>
		<muted public="1" get="accessor" set="null">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</muted>
		<name public="1" get="accessor" set="null">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</name>
		<position public="1">
			<c path="String"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash11_2</e></m>
			</meta>
		</position>
		<quality public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</quality>
		<width public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</width>
		<copyToByteArray public="1">
			<f a="rect:destination">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.utils.ByteArray"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11_4</e></m></meta>
		</copyToByteArray>
		<copyToVector public="1">
			<f a="rect:destination">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.Vector"><x path="UInt"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11_4</e></m></meta>
		</copyToVector>
		<drawToBitmapData public="1">
			<f a="destination">
				<c path="flash.display.BitmapData"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11_4</e></m></meta>
		</drawToBitmapData>
		<get_activityLevel set="method"><f a=""><x path="Float"/></f></get_activityLevel>
		<get_bandwidth set="method"><f a=""><x path="Int"/></f></get_bandwidth>
		<get_currentFPS set="method"><f a=""><x path="Float"/></f></get_currentFPS>
		<get_fps set="method"><f a=""><x path="Float"/></f></get_fps>
		<get_height set="method"><f a=""><x path="Int"/></f></get_height>
		<get_index set="method"><f a=""><x path="Int"/></f></get_index>
		<get_keyFrameInterval set="method"><f a=""><x path="Int"/></f></get_keyFrameInterval>
		<get_loopback set="method"><f a=""><x path="Bool"/></f></get_loopback>
		<get_motionLevel set="method"><f a=""><x path="Int"/></f></get_motionLevel>
		<get_motionTimeout set="method"><f a=""><x path="Int"/></f></get_motionTimeout>
		<get_muted set="method"><f a=""><x path="Bool"/></f></get_muted>
		<get_name set="method"><f a=""><c path="String"/></f></get_name>
		<get_position set="method"><f a=""><c path="String"/></f></get_position>
		<get_quality set="method"><f a=""><x path="Int"/></f></get_quality>
		<get_width set="method"><f a=""><x path="Int"/></f></get_width>
		<setCursor public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Void"/>
</f></setCursor>
		<setKeyFrameInterval public="1" set="method"><f a="keyFrameInterval">
	<x path="Int"/>
	<x path="Void"/>
</f></setKeyFrameInterval>
		<setLoopback public="1" set="method">
			<f a="?compress" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ compress : false }</e></m></meta>
		</setLoopback>
		<setMode public="1" set="method">
			<f a="width:height:fps:?favorArea" v=":::true">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ favorArea : true }</e></m></meta>
		</setMode>
		<setMotionLevel public="1" set="method">
			<f a="motionLevel:?timeout" v=":2000">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ timeout : 2000 }</e></m></meta>
		</setMotionLevel>
		<setQuality public="1" set="method"><f a="bandwidth:quality">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setQuality>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.media.Microphone" params="" file="C:\HaxeToolkit\haxe\std/flash/media/Microphone.hx" extern="1" final="1">
		<extends path="flash.events.EventDispatcher"/>
		<isSupported public="1" static="1">
			<x path="Bool"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</isSupported>
		<names public="1" get="accessor" set="null" static="1">
			<c path="Array"><d/></c>
			<meta><m n=":flash.property"/></meta>
		</names>
		<getEnhancedMicrophone public="1" expr="{ index : -1 }" static="1">
			<f a="?index">
				<x path="Int"/>
				<c path="flash.media.Microphone"/>
			</f>
			<meta>
				<m n=":value"><e>{ index : -1 }</e></m>
				<m n=":require"><e>flash10_2</e></m>
			</meta>
		</getEnhancedMicrophone>
		<getMicrophone public="1" set="method" static="1">
			<f a="?index" v="-1">
				<x path="Int"/>
				<c path="flash.media.Microphone"/>
			</f>
			<meta><m n=":value"><e>{ index : -1 }</e></m></meta>
		</getMicrophone>
		<get_isSupported set="method" static="1"><f a=""><x path="Bool"/></f></get_isSupported>
		<get_names set="method" static="1"><f a=""><c path="Array"><d/></c></f></get_names>
		<activityLevel public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</activityLevel>
		<codec public="1" get="accessor" set="accessor">
			<x path="flash.media.SoundCodec"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</codec>
		<enableVAD public="1">
			<x path="Bool"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</enableVAD>
		<encodeQuality public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</encodeQuality>
		<enhancedOptions public="1">
			<c path="flash.media.MicrophoneEnhancedOptions"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_2</e></m>
			</meta>
		</enhancedOptions>
		<framesPerPacket public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</framesPerPacket>
		<gain public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</gain>
		<index public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</index>
		<muted public="1" get="accessor" set="null">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</muted>
		<name public="1" get="accessor" set="null">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</name>
		<noiseSuppressionLevel public="1">
			<x path="Int"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</noiseSuppressionLevel>
		<rate public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</rate>
		<silenceLevel public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</silenceLevel>
		<silenceTimeout public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</silenceTimeout>
		<soundTransform public="1" get="accessor" set="accessor">
			<c path="flash.media.SoundTransform"/>
			<meta><m n=":flash.property"/></meta>
		</soundTransform>
		<useEchoSuppression public="1" get="accessor" set="null">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</useEchoSuppression>
		<get_activityLevel set="method"><f a=""><x path="Float"/></f></get_activityLevel>
		<get_codec set="method"><f a=""><x path="flash.media.SoundCodec"/></f></get_codec>
		<get_enableVAD set="method"><f a=""><x path="Bool"/></f></get_enableVAD>
		<get_encodeQuality set="method"><f a=""><x path="Int"/></f></get_encodeQuality>
		<get_enhancedOptions set="method"><f a=""><c path="flash.media.MicrophoneEnhancedOptions"/></f></get_enhancedOptions>
		<get_framesPerPacket set="method"><f a=""><x path="Int"/></f></get_framesPerPacket>
		<get_gain set="method"><f a=""><x path="Float"/></f></get_gain>
		<get_index set="method"><f a=""><x path="Int"/></f></get_index>
		<get_muted set="method"><f a=""><x path="Bool"/></f></get_muted>
		<get_name set="method"><f a=""><c path="String"/></f></get_name>
		<get_noiseSuppressionLevel set="method"><f a=""><x path="Int"/></f></get_noiseSuppressionLevel>
		<get_rate set="method"><f a=""><x path="Int"/></f></get_rate>
		<get_silenceLevel set="method"><f a=""><x path="Float"/></f></get_silenceLevel>
		<get_silenceTimeout set="method"><f a=""><x path="Int"/></f></get_silenceTimeout>
		<get_soundTransform set="method"><f a=""><c path="flash.media.SoundTransform"/></f></get_soundTransform>
		<get_useEchoSuppression set="method"><f a=""><x path="Bool"/></f></get_useEchoSuppression>
		<setLoopBack public="1" set="method">
			<f a="?state" v="true">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ state : true }</e></m></meta>
		</setLoopBack>
		<setSilenceLevel public="1" set="method">
			<f a="silenceLevel:?timeout" v=":-1">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ timeout : -1 }</e></m></meta>
		</setSilenceLevel>
		<setUseEchoSuppression public="1" set="method"><f a="useEchoSuppression">
	<x path="Bool"/>
	<x path="Void"/>
</f></setUseEchoSuppression>
		<set_codec set="method"><f a="value">
	<x path="flash.media.SoundCodec"/>
	<x path="flash.media.SoundCodec"/>
</f></set_codec>
		<set_enableVAD set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_enableVAD>
		<set_encodeQuality set="method"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_encodeQuality>
		<set_enhancedOptions set="method"><f a="value">
	<c path="flash.media.MicrophoneEnhancedOptions"/>
	<c path="flash.media.MicrophoneEnhancedOptions"/>
</f></set_enhancedOptions>
		<set_framesPerPacket set="method"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_framesPerPacket>
		<set_gain set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_gain>
		<set_noiseSuppressionLevel set="method"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_noiseSuppressionLevel>
		<set_rate set="method"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_rate>
		<set_soundTransform set="method"><f a="value">
	<c path="flash.media.SoundTransform"/>
	<c path="flash.media.SoundTransform"/>
</f></set_soundTransform>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<abstract path="flash.media.MicrophoneEnhancedMode" params="" file="C:\HaxeToolkit\haxe\std/flash/media/MicrophoneEnhancedMode.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.media.MicrophoneEnhancedMode"</e></m>
			<m n=":require"><e>flash10_2</e></m>
		</meta>
		<impl><class path="flash.media._MicrophoneEnhancedMode.MicrophoneEnhancedMode_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/media/MicrophoneEnhancedMode.hx" private="1" module="flash.media.MicrophoneEnhancedMode" extern="1" final="1">
	<FULL_DUPLEX public="1" set="null" static="1">
		<x path="flash.media.MicrophoneEnhancedMode"/>
		<meta><m n=":enum"/></meta>
	</FULL_DUPLEX>
	<HALF_DUPLEX public="1" set="null" static="1">
		<x path="flash.media.MicrophoneEnhancedMode"/>
		<meta><m n=":enum"/></meta>
	</HALF_DUPLEX>
	<HEADSET public="1" set="null" static="1">
		<x path="flash.media.MicrophoneEnhancedMode"/>
		<meta><m n=":enum"/></meta>
	</HEADSET>
	<OFF public="1" set="null" static="1">
		<x path="flash.media.MicrophoneEnhancedMode"/>
		<meta><m n=":enum"/></meta>
	</OFF>
	<SPEAKER_MUTE public="1" set="null" static="1">
		<x path="flash.media.MicrophoneEnhancedMode"/>
		<meta><m n=":enum"/></meta>
	</SPEAKER_MUTE>
	<meta>
		<m n=":native"><e>"flash.media.MicrophoneEnhancedMode"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.media._MicrophoneEnhancedMode.MicrophoneEnhancedMode_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/media/MicrophoneEnhancedMode.hx" private="1" module="flash.media.MicrophoneEnhancedMode" extern="1" final="1">
		<FULL_DUPLEX public="1" set="null" static="1">
			<x path="flash.media.MicrophoneEnhancedMode"/>
			<meta><m n=":enum"/></meta>
		</FULL_DUPLEX>
		<HALF_DUPLEX public="1" set="null" static="1">
			<x path="flash.media.MicrophoneEnhancedMode"/>
			<meta><m n=":enum"/></meta>
		</HALF_DUPLEX>
		<HEADSET public="1" set="null" static="1">
			<x path="flash.media.MicrophoneEnhancedMode"/>
			<meta><m n=":enum"/></meta>
		</HEADSET>
		<OFF public="1" set="null" static="1">
			<x path="flash.media.MicrophoneEnhancedMode"/>
			<meta><m n=":enum"/></meta>
		</OFF>
		<SPEAKER_MUTE public="1" set="null" static="1">
			<x path="flash.media.MicrophoneEnhancedMode"/>
			<meta><m n=":enum"/></meta>
		</SPEAKER_MUTE>
		<meta>
			<m n=":native"><e>"flash.media.MicrophoneEnhancedMode"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="flash.media.MicrophoneEnhancedOptions" params="" file="C:\HaxeToolkit\haxe\std/flash/media/MicrophoneEnhancedOptions.hx" extern="1" final="1">
		<autoGain public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</autoGain>
		<echoPath public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</echoPath>
		<isVoiceDetected public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</isVoiceDetected>
		<mode public="1" get="accessor" set="accessor">
			<x path="flash.media.MicrophoneEnhancedMode"/>
			<meta><m n=":flash.property"/></meta>
		</mode>
		<nonLinearProcessing public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</nonLinearProcessing>
		<get_autoGain set="method"><f a=""><x path="Bool"/></f></get_autoGain>
		<get_echoPath set="method"><f a=""><x path="Int"/></f></get_echoPath>
		<get_isVoiceDetected set="method"><f a=""><x path="Int"/></f></get_isVoiceDetected>
		<get_mode set="method"><f a=""><x path="flash.media.MicrophoneEnhancedMode"/></f></get_mode>
		<get_nonLinearProcessing set="method"><f a=""><x path="Bool"/></f></get_nonLinearProcessing>
		<set_autoGain set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_autoGain>
		<set_echoPath set="method"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_echoPath>
		<set_isVoiceDetected set="method"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_isVoiceDetected>
		<set_mode set="method"><f a="value">
	<x path="flash.media.MicrophoneEnhancedMode"/>
	<x path="flash.media.MicrophoneEnhancedMode"/>
</f></set_mode>
		<set_nonLinearProcessing set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_nonLinearProcessing>
		<new public="1"><f a=""><x path="Void"/></f></new>
		<meta><m n=":require"><e>flash10_2</e></m></meta>
	</class>
	<abstract path="flash.media.SoundCodec" params="" file="C:\HaxeToolkit\haxe\std/flash/media/SoundCodec.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.media.SoundCodec"</e></m>
		</meta>
		<impl><class path="flash.media._SoundCodec.SoundCodec_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/media/SoundCodec.hx" private="1" module="flash.media.SoundCodec" extern="1" final="1">
	<NELLYMOSER public="1" set="null" static="1">
		<x path="flash.media.SoundCodec"/>
		<meta><m n=":enum"/></meta>
	</NELLYMOSER>
	<PCMA public="1" set="null" static="1">
		<x path="flash.media.SoundCodec"/>
		<meta><m n=":enum"/></meta>
	</PCMA>
	<PCMU public="1" set="null" static="1">
		<x path="flash.media.SoundCodec"/>
		<meta><m n=":enum"/></meta>
	</PCMU>
	<SPEEX public="1" set="null" static="1">
		<x path="flash.media.SoundCodec"/>
		<meta><m n=":enum"/></meta>
	</SPEEX>
	<meta>
		<m n=":native"><e>"flash.media.SoundCodec"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.media._SoundCodec.SoundCodec_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/media/SoundCodec.hx" private="1" module="flash.media.SoundCodec" extern="1" final="1">
		<NELLYMOSER public="1" set="null" static="1">
			<x path="flash.media.SoundCodec"/>
			<meta><m n=":enum"/></meta>
		</NELLYMOSER>
		<PCMA public="1" set="null" static="1">
			<x path="flash.media.SoundCodec"/>
			<meta><m n=":enum"/></meta>
		</PCMA>
		<PCMU public="1" set="null" static="1">
			<x path="flash.media.SoundCodec"/>
			<meta><m n=":enum"/></meta>
		</PCMU>
		<SPEEX public="1" set="null" static="1">
			<x path="flash.media.SoundCodec"/>
			<meta><m n=":enum"/></meta>
		</SPEEX>
		<meta>
			<m n=":native"><e>"flash.media.SoundCodec"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="flash.media.SoundTransform" params="" file="C:\HaxeToolkit\haxe\std/flash/media/SoundTransform.hx" extern="1" final="1">
		<leftToLeft public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</leftToLeft>
		<leftToRight public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</leftToRight>
		<pan public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</pan>
		<rightToLeft public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</rightToLeft>
		<rightToRight public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</rightToRight>
		<volume public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</volume>
		<get_leftToLeft set="method"><f a=""><x path="Float"/></f></get_leftToLeft>
		<get_leftToRight set="method"><f a=""><x path="Float"/></f></get_leftToRight>
		<get_pan set="method"><f a=""><x path="Float"/></f></get_pan>
		<get_rightToLeft set="method"><f a=""><x path="Float"/></f></get_rightToLeft>
		<get_rightToRight set="method"><f a=""><x path="Float"/></f></get_rightToRight>
		<get_volume set="method"><f a=""><x path="Float"/></f></get_volume>
		<set_leftToLeft set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_leftToLeft>
		<set_leftToRight set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_leftToRight>
		<set_pan set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_pan>
		<set_rightToLeft set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_rightToLeft>
		<set_rightToRight set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_rightToRight>
		<set_volume set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_volume>
		<new public="1" set="method">
			<f a="?vol:?panning" v="1:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ panning : 0, vol : 1 }</e></m></meta>
		</new>
	</class>
	<class path="flash.media.StageVideo" params="" file="C:\HaxeToolkit\haxe\std/flash/media/StageVideo.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<colorSpaces public="1" get="accessor" set="null">
			<c path="flash.Vector"><c path="String"/></c>
			<meta><m n=":flash.property"/></meta>
		</colorSpaces>
		<depth public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</depth>
		<pan public="1" get="accessor" set="accessor">
			<c path="flash.geom.Point"/>
			<meta><m n=":flash.property"/></meta>
		</pan>
		<videoHeight public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</videoHeight>
		<videoWidth public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</videoWidth>
		<viewPort public="1" get="accessor" set="accessor">
			<c path="flash.geom.Rectangle"/>
			<meta><m n=":flash.property"/></meta>
		</viewPort>
		<zoom public="1" get="accessor" set="accessor">
			<c path="flash.geom.Point"/>
			<meta><m n=":flash.property"/></meta>
		</zoom>
		<attachAVStream public="1">
			<f a="avStream">
				<c path="flash.media.AVStream"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11_7</e></m></meta>
		</attachAVStream>
		<attachCamera public="1">
			<f a="theCamera">
				<c path="flash.media.Camera"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11_4</e></m></meta>
		</attachCamera>
		<attachNetStream public="1" set="method"><f a="netStream">
	<c path="flash.net.NetStream"/>
	<x path="Void"/>
</f></attachNetStream>
		<get_colorSpaces set="method"><f a=""><c path="flash.Vector"><c path="String"/></c></f></get_colorSpaces>
		<get_depth set="method"><f a=""><x path="Int"/></f></get_depth>
		<get_pan set="method"><f a=""><c path="flash.geom.Point"/></f></get_pan>
		<get_videoHeight set="method"><f a=""><x path="Int"/></f></get_videoHeight>
		<get_videoWidth set="method"><f a=""><x path="Int"/></f></get_videoWidth>
		<get_viewPort set="method"><f a=""><c path="flash.geom.Rectangle"/></f></get_viewPort>
		<get_zoom set="method"><f a=""><c path="flash.geom.Point"/></f></get_zoom>
		<set_depth set="method"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_depth>
		<set_pan set="method"><f a="value">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></set_pan>
		<set_viewPort set="method"><f a="value">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
</f></set_viewPort>
		<set_zoom set="method"><f a="value">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></set_zoom>
		<new public="1"><f a=""><x path="Void"/></f></new>
		<meta><m n=":require"><e>flash10_2</e></m></meta>
	</class>
	<class path="flash.media.VideoStreamSettings" params="" file="C:\HaxeToolkit\haxe\std/flash/media/VideoStreamSettings.hx" extern="1">
		<bandwidth public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</bandwidth>
		<codec public="1" get="accessor" set="null">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</codec>
		<fps public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</fps>
		<height public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</height>
		<keyFrameInterval public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</keyFrameInterval>
		<quality public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</quality>
		<width public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</width>
		<get_bandwidth set="method"><f a=""><x path="Int"/></f></get_bandwidth>
		<get_codec set="method"><f a=""><c path="String"/></f></get_codec>
		<get_fps set="method"><f a=""><x path="Float"/></f></get_fps>
		<get_height set="method"><f a=""><x path="Int"/></f></get_height>
		<get_keyFrameInterval set="method"><f a=""><x path="Int"/></f></get_keyFrameInterval>
		<get_quality set="method"><f a=""><x path="Int"/></f></get_quality>
		<get_width set="method"><f a=""><x path="Int"/></f></get_width>
		<setKeyFrameInterval public="1" set="method"><f a="keyFrameInterval">
	<x path="Int"/>
	<x path="Void"/>
</f></setKeyFrameInterval>
		<setMode public="1" set="method"><f a="width:height:fps">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setMode>
		<setQuality public="1" set="method"><f a="bandwidth:quality">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setQuality>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.net.NetConnection" params="" file="C:\HaxeToolkit\haxe\std/flash/net/NetConnection.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<defaultObjectEncoding public="1" get="accessor" set="accessor" static="1">
			<x path="UInt"/>
			<meta><m n=":flash.property"/></meta>
		</defaultObjectEncoding>
		<get_defaultObjectEncoding set="method" static="1"><f a=""><x path="UInt"/></f></get_defaultObjectEncoding>
		<set_defaultObjectEncoding set="method" static="1"><f a="value">
	<x path="UInt"/>
	<x path="UInt"/>
</f></set_defaultObjectEncoding>
		<client public="1" get="accessor" set="accessor">
			<d/>
			<meta><m n=":flash.property"/></meta>
		</client>
		<connected public="1" get="accessor" set="null">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</connected>
		<connectedProxyType public="1" get="accessor" set="null">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</connectedProxyType>
		<farID public="1" get="accessor" set="null">
			<c path="String"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</farID>
		<farNonce public="1" get="accessor" set="null">
			<c path="String"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</farNonce>
		<maxPeerConnections public="1" get="accessor" set="accessor">
			<x path="UInt"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</maxPeerConnections>
		<nearID public="1" get="accessor" set="null">
			<c path="String"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</nearID>
		<nearNonce public="1" get="accessor" set="null">
			<c path="String"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</nearNonce>
		<objectEncoding public="1" get="accessor" set="accessor">
			<x path="UInt"/>
			<meta><m n=":flash.property"/></meta>
		</objectEncoding>
		<protocol public="1" get="accessor" set="null">
			<c path="String"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</protocol>
		<proxyType public="1" get="accessor" set="accessor">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</proxyType>
		<unconnectedPeerStreams public="1" get="accessor" set="null">
			<c path="Array"><d/></c>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</unconnectedPeerStreams>
		<uri public="1" get="accessor" set="null">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</uri>
		<usingTLS public="1" get="accessor" set="null">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</usingTLS>
		<addHeader public="1" set="method">
			<f a="operation:?mustUnderstand:?param" v=":false:">
				<c path="String"/>
				<x path="Bool"/>
				<x path="flash.utils.Object"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ mustUnderstand : false }</e></m></meta>
		</addHeader>
		<call public="1" set="method"><f a="command:responder:restArgs">
	<c path="String"/>
	<c path="flash.net.Responder"/>
	<t path="haxe.extern.Rest"><d/></t>
	<x path="Void"/>
</f></call>
		<close public="1" set="method"><f a=""><x path="Void"/></f></close>
		<connect public="1" set="method"><f a="command:restArgs">
	<c path="String"/>
	<t path="haxe.extern.Rest"><d/></t>
	<x path="Void"/>
</f></connect>
		<get_client set="method"><f a=""><d/></f></get_client>
		<get_connected set="method"><f a=""><x path="Bool"/></f></get_connected>
		<get_connectedProxyType set="method"><f a=""><c path="String"/></f></get_connectedProxyType>
		<get_farID set="method"><f a=""><c path="String"/></f></get_farID>
		<get_farNonce set="method"><f a=""><c path="String"/></f></get_farNonce>
		<get_maxPeerConnections set="method"><f a=""><x path="UInt"/></f></get_maxPeerConnections>
		<get_nearID set="method"><f a=""><c path="String"/></f></get_nearID>
		<get_nearNonce set="method"><f a=""><c path="String"/></f></get_nearNonce>
		<get_objectEncoding set="method"><f a=""><x path="UInt"/></f></get_objectEncoding>
		<get_protocol set="method"><f a=""><c path="String"/></f></get_protocol>
		<get_proxyType set="method"><f a=""><c path="String"/></f></get_proxyType>
		<get_unconnectedPeerStreams set="method"><f a=""><c path="Array"><d/></c></f></get_unconnectedPeerStreams>
		<get_uri set="method"><f a=""><c path="String"/></f></get_uri>
		<get_usingTLS set="method"><f a=""><x path="Bool"/></f></get_usingTLS>
		<set_client set="method"><f a="value">
	<d/>
	<d/>
</f></set_client>
		<set_maxPeerConnections set="method"><f a="value">
	<x path="UInt"/>
	<x path="UInt"/>
</f></set_maxPeerConnections>
		<set_objectEncoding set="method"><f a="value">
	<x path="UInt"/>
	<x path="UInt"/>
</f></set_objectEncoding>
		<set_proxyType set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_proxyType>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.net.NetStream" params="" file="C:\HaxeToolkit\haxe\std/flash/net/NetStream.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<CONNECT_TO_FMS final="1" public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</CONNECT_TO_FMS>
		<DIRECT_CONNECTIONS final="1" public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</DIRECT_CONNECTIONS>
		<resetDRMVouchers public="1" set="method" static="1"><f a=""><x path="Void"/></f></resetDRMVouchers>
		<audioCodec public="1" get="accessor" set="null">
			<x path="UInt"/>
			<meta><m n=":flash.property"/></meta>
		</audioCodec>
		<audioReliable public="1">
			<x path="Bool"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</audioReliable>
		<audioSampleAccess public="1">
			<x path="Bool"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</audioSampleAccess>
		<backBufferLength public="1">
			<x path="Float"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</backBufferLength>
		<backBufferTime public="1">
			<x path="Float"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</backBufferTime>
		<bufferLength public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</bufferLength>
		<bufferTime public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</bufferTime>
		<bufferTimeMax public="1">
			<x path="Float"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</bufferTimeMax>
		<bytesLoaded public="1" get="accessor" set="null">
			<x path="UInt"/>
			<meta><m n=":flash.property"/></meta>
		</bytesLoaded>
		<bytesTotal public="1" get="accessor" set="null">
			<x path="UInt"/>
			<meta><m n=":flash.property"/></meta>
		</bytesTotal>
		<checkPolicyFile public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</checkPolicyFile>
		<client public="1" get="accessor" set="accessor">
			<d/>
			<meta><m n=":flash.property"/></meta>
		</client>
		<currentFPS public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</currentFPS>
		<dataReliable public="1">
			<x path="Bool"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</dataReliable>
		<decodedFrames public="1" get="accessor" set="null">
			<x path="UInt"/>
			<meta><m n=":flash.property"/></meta>
		</decodedFrames>
		<farID public="1" get="accessor" set="null">
			<c path="String"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</farID>
		<farNonce public="1" get="accessor" set="null">
			<c path="String"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</farNonce>
		<inBufferSeek public="1">
			<x path="Bool"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</inBufferSeek>
		<info public="1" get="accessor" set="null">
			<c path="flash.net.NetStreamInfo"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</info>
		<liveDelay public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</liveDelay>
		<maxPauseBufferTime public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</maxPauseBufferTime>
		<multicastAvailabilitySendToAll public="1">
			<x path="Bool"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</multicastAvailabilitySendToAll>
		<multicastAvailabilityUpdatePeriod public="1">
			<x path="Float"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</multicastAvailabilityUpdatePeriod>
		<multicastFetchPeriod public="1">
			<x path="Float"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</multicastFetchPeriod>
		<multicastInfo public="1">
			<c path="flash.net.NetStreamMulticastInfo"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</multicastInfo>
		<multicastPushNeighborLimit public="1">
			<x path="Float"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</multicastPushNeighborLimit>
		<multicastRelayMarginDuration public="1">
			<x path="Float"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</multicastRelayMarginDuration>
		<multicastWindowDuration public="1">
			<x path="Float"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</multicastWindowDuration>
		<nearNonce public="1" get="accessor" set="null">
			<c path="String"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</nearNonce>
		<objectEncoding public="1" get="accessor" set="null">
			<x path="UInt"/>
			<meta><m n=":flash.property"/></meta>
		</objectEncoding>
		<peerStreams public="1" get="accessor" set="null">
			<c path="Array"><d/></c>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</peerStreams>
		<soundTransform public="1" get="accessor" set="accessor">
			<c path="flash.media.SoundTransform"/>
			<meta><m n=":flash.property"/></meta>
		</soundTransform>
		<time public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</time>
		<useHardwareDecoder public="1">
			<x path="Bool"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash11</e></m>
			</meta>
		</useHardwareDecoder>
		<useJitterBuffer public="1">
			<x path="Bool"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash11_3</e></m>
			</meta>
		</useJitterBuffer>
		<videoCodec public="1" get="accessor" set="null">
			<x path="UInt"/>
			<meta><m n=":flash.property"/></meta>
		</videoCodec>
		<videoReliable public="1">
			<x path="Bool"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</videoReliable>
		<videoSampleAccess public="1">
			<x path="Bool"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</videoSampleAccess>
		<videoStreamSettings public="1">
			<c path="flash.media.VideoStreamSettings"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash11</e></m>
			</meta>
		</videoStreamSettings>
		<appendBytes public="1">
			<f a="bytes">
				<c path="flash.utils.ByteArray"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</appendBytes>
		<appendBytesAction public="1">
			<f a="netStreamAppendBytesAction">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</appendBytesAction>
		<attach public="1">
			<f a="connection">
				<c path="flash.net.NetConnection"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</attach>
		<attachAudio public="1" set="method"><f a="microphone">
	<c path="flash.media.Microphone"/>
	<x path="Void"/>
</f></attachAudio>
		<attachCamera public="1" set="method">
			<f a="theCamera:?snapshotMilliseconds" v=":-1">
				<c path="flash.media.Camera"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ snapshotMilliseconds : -1 }</e></m></meta>
		</attachCamera>
		<close public="1" set="method"><f a=""><x path="Void"/></f></close>
		<dispose public="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</dispose>
		<get_audioCodec set="method"><f a=""><x path="UInt"/></f></get_audioCodec>
		<get_audioReliable set="method"><f a=""><x path="Bool"/></f></get_audioReliable>
		<get_audioSampleAccess set="method"><f a=""><x path="Bool"/></f></get_audioSampleAccess>
		<get_backBufferLength set="method"><f a=""><x path="Float"/></f></get_backBufferLength>
		<get_backBufferTime set="method"><f a=""><x path="Float"/></f></get_backBufferTime>
		<get_bufferLength set="method"><f a=""><x path="Float"/></f></get_bufferLength>
		<get_bufferTime set="method"><f a=""><x path="Float"/></f></get_bufferTime>
		<get_bufferTimeMax set="method"><f a=""><x path="Float"/></f></get_bufferTimeMax>
		<get_bytesLoaded set="method"><f a=""><x path="UInt"/></f></get_bytesLoaded>
		<get_bytesTotal set="method"><f a=""><x path="UInt"/></f></get_bytesTotal>
		<get_checkPolicyFile set="method"><f a=""><x path="Bool"/></f></get_checkPolicyFile>
		<get_client set="method"><f a=""><d/></f></get_client>
		<get_currentFPS set="method"><f a=""><x path="Float"/></f></get_currentFPS>
		<get_dataReliable set="method"><f a=""><x path="Bool"/></f></get_dataReliable>
		<get_decodedFrames set="method"><f a=""><x path="UInt"/></f></get_decodedFrames>
		<get_farID set="method"><f a=""><c path="String"/></f></get_farID>
		<get_farNonce set="method"><f a=""><c path="String"/></f></get_farNonce>
		<get_inBufferSeek set="method"><f a=""><x path="Bool"/></f></get_inBufferSeek>
		<get_info set="method"><f a=""><c path="flash.net.NetStreamInfo"/></f></get_info>
		<get_liveDelay set="method"><f a=""><x path="Float"/></f></get_liveDelay>
		<get_maxPauseBufferTime set="method"><f a=""><x path="Float"/></f></get_maxPauseBufferTime>
		<get_multicastAvailabilitySendToAll set="method"><f a=""><x path="Bool"/></f></get_multicastAvailabilitySendToAll>
		<get_multicastAvailabilityUpdatePeriod set="method"><f a=""><x path="Float"/></f></get_multicastAvailabilityUpdatePeriod>
		<get_multicastFetchPeriod set="method"><f a=""><x path="Float"/></f></get_multicastFetchPeriod>
		<get_multicastInfo set="method"><f a=""><c path="flash.net.NetStreamMulticastInfo"/></f></get_multicastInfo>
		<get_multicastPushNeighborLimit set="method"><f a=""><x path="Float"/></f></get_multicastPushNeighborLimit>
		<get_multicastRelayMarginDuration set="method"><f a=""><x path="Float"/></f></get_multicastRelayMarginDuration>
		<get_multicastWindowDuration set="method"><f a=""><x path="Float"/></f></get_multicastWindowDuration>
		<get_nearNonce set="method"><f a=""><c path="String"/></f></get_nearNonce>
		<get_objectEncoding set="method"><f a=""><x path="UInt"/></f></get_objectEncoding>
		<get_peerStreams set="method"><f a=""><c path="Array"><d/></c></f></get_peerStreams>
		<get_soundTransform set="method"><f a=""><c path="flash.media.SoundTransform"/></f></get_soundTransform>
		<get_time set="method"><f a=""><x path="Float"/></f></get_time>
		<get_useHardwareDecoder set="method"><f a=""><x path="Bool"/></f></get_useHardwareDecoder>
		<get_useJitterBuffer set="method"><f a=""><x path="Bool"/></f></get_useJitterBuffer>
		<get_videoCodec set="method"><f a=""><x path="UInt"/></f></get_videoCodec>
		<get_videoReliable set="method"><f a=""><x path="Bool"/></f></get_videoReliable>
		<get_videoSampleAccess set="method"><f a=""><x path="Bool"/></f></get_videoSampleAccess>
		<get_videoStreamSettings set="method"><f a=""><c path="flash.media.VideoStreamSettings"/></f></get_videoStreamSettings>
		<onPeerConnect public="1" set="method">
			<f a="subscriber">
				<c path="flash.net.NetStream"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</onPeerConnect>
		<pause public="1" set="method"><f a=""><x path="Void"/></f></pause>
		<play public="1" set="method"><f a="restArgs">
	<t path="haxe.extern.Rest"><d/></t>
	<x path="Void"/>
</f></play>
		<play2 public="1" set="method">
			<f a="param">
				<c path="flash.net.NetStreamPlayOptions"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</play2>
		<publish public="1" set="method"><f a="?name:?type">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></publish>
		<receiveAudio public="1" set="method"><f a="flag">
	<x path="Bool"/>
	<x path="Void"/>
</f></receiveAudio>
		<receiveVideo public="1" set="method"><f a="flag">
	<x path="Bool"/>
	<x path="Void"/>
</f></receiveVideo>
		<receiveVideoFPS public="1" set="method"><f a="FPS">
	<x path="Float"/>
	<x path="Void"/>
</f></receiveVideoFPS>
		<resume public="1" set="method"><f a=""><x path="Void"/></f></resume>
		<seek public="1" set="method"><f a="offset">
	<x path="Float"/>
	<x path="Void"/>
</f></seek>
		<send public="1" set="method"><f a="handlerName:restArgs">
	<c path="String"/>
	<t path="haxe.extern.Rest"><d/></t>
	<x path="Void"/>
</f></send>
		<set_audioReliable set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_audioReliable>
		<set_audioSampleAccess set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_audioSampleAccess>
		<set_backBufferTime set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_backBufferTime>
		<set_bufferTime set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_bufferTime>
		<set_bufferTimeMax set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_bufferTimeMax>
		<set_checkPolicyFile set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_checkPolicyFile>
		<set_client set="method"><f a="value">
	<d/>
	<d/>
</f></set_client>
		<set_dataReliable set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_dataReliable>
		<set_inBufferSeek set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_inBufferSeek>
		<set_maxPauseBufferTime set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_maxPauseBufferTime>
		<set_multicastAvailabilitySendToAll set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_multicastAvailabilitySendToAll>
		<set_multicastAvailabilityUpdatePeriod set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_multicastAvailabilityUpdatePeriod>
		<set_multicastFetchPeriod set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_multicastFetchPeriod>
		<set_multicastPushNeighborLimit set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_multicastPushNeighborLimit>
		<set_multicastRelayMarginDuration set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_multicastRelayMarginDuration>
		<set_multicastWindowDuration set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_multicastWindowDuration>
		<set_soundTransform set="method"><f a="value">
	<c path="flash.media.SoundTransform"/>
	<c path="flash.media.SoundTransform"/>
</f></set_soundTransform>
		<set_useHardwareDecoder set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_useHardwareDecoder>
		<set_useJitterBuffer set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_useJitterBuffer>
		<set_videoReliable set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_videoReliable>
		<set_videoSampleAccess set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_videoSampleAccess>
		<set_videoStreamSettings set="method"><f a="value">
	<c path="flash.media.VideoStreamSettings"/>
	<c path="flash.media.VideoStreamSettings"/>
</f></set_videoStreamSettings>
		<step public="1">
			<f a="frames">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</step>
		<togglePause public="1" set="method"><f a=""><x path="Void"/></f></togglePause>
		<new public="1" set="method"><f a="connection:?peerID">
	<c path="flash.net.NetConnection"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.net.NetStreamInfo" params="" file="C:\HaxeToolkit\haxe\std/flash/net/NetStreamInfo.hx" extern="1" final="1">
		<SRTT public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</SRTT>
		<audioBufferByteLength public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</audioBufferByteLength>
		<audioBufferLength public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</audioBufferLength>
		<audioByteCount public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</audioByteCount>
		<audioBytesPerSecond public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</audioBytesPerSecond>
		<audioLossRate public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</audioLossRate>
		<byteCount public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</byteCount>
		<currentBytesPerSecond public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</currentBytesPerSecond>
		<dataBufferByteLength public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</dataBufferByteLength>
		<dataBufferLength public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</dataBufferLength>
		<dataByteCount public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</dataByteCount>
		<dataBytesPerSecond public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</dataBytesPerSecond>
		<droppedFrames public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</droppedFrames>
		<isLive public="1" get="accessor" set="null">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</isLive>
		<maxBytesPerSecond public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</maxBytesPerSecond>
		<metaData public="1" get="accessor" set="null">
			<d/>
			<meta><m n=":flash.property"/></meta>
		</metaData>
		<playbackBytesPerSecond public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</playbackBytesPerSecond>
		<resourceName public="1" get="accessor" set="null">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</resourceName>
		<uri public="1" get="accessor" set="null">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</uri>
		<videoBufferByteLength public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</videoBufferByteLength>
		<videoBufferLength public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</videoBufferLength>
		<videoByteCount public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</videoByteCount>
		<videoBytesPerSecond public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</videoBytesPerSecond>
		<videoLossRate public="1">
			<x path="Float"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</videoLossRate>
		<xmpData public="1" get="accessor" set="null">
			<d/>
			<meta><m n=":flash.property"/></meta>
		</xmpData>
		<get_SRTT set="method"><f a=""><x path="Float"/></f></get_SRTT>
		<get_audioBufferByteLength set="method"><f a=""><x path="Float"/></f></get_audioBufferByteLength>
		<get_audioBufferLength set="method"><f a=""><x path="Float"/></f></get_audioBufferLength>
		<get_audioByteCount set="method"><f a=""><x path="Float"/></f></get_audioByteCount>
		<get_audioBytesPerSecond set="method"><f a=""><x path="Float"/></f></get_audioBytesPerSecond>
		<get_audioLossRate set="method"><f a=""><x path="Float"/></f></get_audioLossRate>
		<get_byteCount set="method"><f a=""><x path="Float"/></f></get_byteCount>
		<get_currentBytesPerSecond set="method"><f a=""><x path="Float"/></f></get_currentBytesPerSecond>
		<get_dataBufferByteLength set="method"><f a=""><x path="Float"/></f></get_dataBufferByteLength>
		<get_dataBufferLength set="method"><f a=""><x path="Float"/></f></get_dataBufferLength>
		<get_dataByteCount set="method"><f a=""><x path="Float"/></f></get_dataByteCount>
		<get_dataBytesPerSecond set="method"><f a=""><x path="Float"/></f></get_dataBytesPerSecond>
		<get_droppedFrames set="method"><f a=""><x path="Float"/></f></get_droppedFrames>
		<get_isLive set="method"><f a=""><x path="Bool"/></f></get_isLive>
		<get_maxBytesPerSecond set="method"><f a=""><x path="Float"/></f></get_maxBytesPerSecond>
		<get_metaData set="method"><f a=""><d/></f></get_metaData>
		<get_playbackBytesPerSecond set="method"><f a=""><x path="Float"/></f></get_playbackBytesPerSecond>
		<get_resourceName set="method"><f a=""><c path="String"/></f></get_resourceName>
		<get_uri set="method"><f a=""><c path="String"/></f></get_uri>
		<get_videoBufferByteLength set="method"><f a=""><x path="Float"/></f></get_videoBufferByteLength>
		<get_videoBufferLength set="method"><f a=""><x path="Float"/></f></get_videoBufferLength>
		<get_videoByteCount set="method"><f a=""><x path="Float"/></f></get_videoByteCount>
		<get_videoBytesPerSecond set="method"><f a=""><x path="Float"/></f></get_videoBytesPerSecond>
		<get_videoLossRate set="method"><f a=""><x path="Float"/></f></get_videoLossRate>
		<get_xmpData set="method"><f a=""><d/></f></get_xmpData>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method">
			<f a="curBPS:byteCount:maxBPS:audioBPS:audioByteCount:videoBPS:videoByteCount:dataBPS:dataByteCount:playbackBPS:droppedFrames:audioBufferByteLength:videoBufferByteLength:dataBufferByteLength:audioBufferLength:videoBufferLength:dataBufferLength:srtt:audioLossRate:videoLossRate:?metaData:?xmpData:?uri:?resourceName:?isLive" v="::::::::::::::::::::::::true">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<d/>
				<d/>
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ isLive : true }</e></m></meta>
		</new>
	</class>
	<class path="flash.net.NetStreamMulticastInfo" params="" file="C:\HaxeToolkit\haxe\std/flash/net/NetStreamMulticastInfo.hx" extern="1" final="1">
		<bytesPushedFromPeers public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</bytesPushedFromPeers>
		<bytesPushedToPeers public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</bytesPushedToPeers>
		<bytesReceivedFromIPMulticast public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</bytesReceivedFromIPMulticast>
		<bytesReceivedFromServer public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</bytesReceivedFromServer>
		<bytesRequestedByPeers public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</bytesRequestedByPeers>
		<bytesRequestedFromPeers public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</bytesRequestedFromPeers>
		<fragmentsPushedFromPeers public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</fragmentsPushedFromPeers>
		<fragmentsPushedToPeers public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</fragmentsPushedToPeers>
		<fragmentsReceivedFromIPMulticast public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</fragmentsReceivedFromIPMulticast>
		<fragmentsReceivedFromServer public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</fragmentsReceivedFromServer>
		<fragmentsRequestedByPeers public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</fragmentsRequestedByPeers>
		<fragmentsRequestedFromPeers public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</fragmentsRequestedFromPeers>
		<receiveControlBytesPerSecond public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</receiveControlBytesPerSecond>
		<receiveDataBytesPerSecond public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</receiveDataBytesPerSecond>
		<receiveDataBytesPerSecondFromIPMulticast public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</receiveDataBytesPerSecondFromIPMulticast>
		<receiveDataBytesPerSecondFromServer public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</receiveDataBytesPerSecondFromServer>
		<sendControlBytesPerSecond public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</sendControlBytesPerSecond>
		<sendControlBytesPerSecondToServer public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</sendControlBytesPerSecondToServer>
		<sendDataBytesPerSecond public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</sendDataBytesPerSecond>
		<get_bytesPushedFromPeers set="method"><f a=""><x path="Float"/></f></get_bytesPushedFromPeers>
		<get_bytesPushedToPeers set="method"><f a=""><x path="Float"/></f></get_bytesPushedToPeers>
		<get_bytesReceivedFromIPMulticast set="method"><f a=""><x path="Float"/></f></get_bytesReceivedFromIPMulticast>
		<get_bytesReceivedFromServer set="method"><f a=""><x path="Float"/></f></get_bytesReceivedFromServer>
		<get_bytesRequestedByPeers set="method"><f a=""><x path="Float"/></f></get_bytesRequestedByPeers>
		<get_bytesRequestedFromPeers set="method"><f a=""><x path="Float"/></f></get_bytesRequestedFromPeers>
		<get_fragmentsPushedFromPeers set="method"><f a=""><x path="Float"/></f></get_fragmentsPushedFromPeers>
		<get_fragmentsPushedToPeers set="method"><f a=""><x path="Float"/></f></get_fragmentsPushedToPeers>
		<get_fragmentsReceivedFromIPMulticast set="method"><f a=""><x path="Float"/></f></get_fragmentsReceivedFromIPMulticast>
		<get_fragmentsReceivedFromServer set="method"><f a=""><x path="Float"/></f></get_fragmentsReceivedFromServer>
		<get_fragmentsRequestedByPeers set="method"><f a=""><x path="Float"/></f></get_fragmentsRequestedByPeers>
		<get_fragmentsRequestedFromPeers set="method"><f a=""><x path="Float"/></f></get_fragmentsRequestedFromPeers>
		<get_receiveControlBytesPerSecond set="method"><f a=""><x path="Float"/></f></get_receiveControlBytesPerSecond>
		<get_receiveDataBytesPerSecond set="method"><f a=""><x path="Float"/></f></get_receiveDataBytesPerSecond>
		<get_receiveDataBytesPerSecondFromIPMulticast set="method"><f a=""><x path="Float"/></f></get_receiveDataBytesPerSecondFromIPMulticast>
		<get_receiveDataBytesPerSecondFromServer set="method"><f a=""><x path="Float"/></f></get_receiveDataBytesPerSecondFromServer>
		<get_sendControlBytesPerSecond set="method"><f a=""><x path="Float"/></f></get_sendControlBytesPerSecond>
		<get_sendControlBytesPerSecondToServer set="method"><f a=""><x path="Float"/></f></get_sendControlBytesPerSecondToServer>
		<get_sendDataBytesPerSecond set="method"><f a=""><x path="Float"/></f></get_sendDataBytesPerSecond>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<new public="1"><f a="sendDataBytesPerSecond:sendControlBytesPerSecond:receiveDataBytesPerSecond:receiveControlBytesPerSecond:bytesPushedToPeers:fragmentsPushedToPeers:bytesRequestedByPeers:fragmentsRequestedByPeers:bytesPushedFromPeers:fragmentsPushedFromPeers:bytesRequestedFromPeers:fragmentsRequestedFromPeers:sendControlBytesPerSecondToServer:receiveDataBytesPerSecondFromServer:bytesReceivedFromServer:fragmentsReceivedFromServer:receiveDataBytesPerSecondFromIPMulticast:bytesReceivedFromIPMulticast:fragmentsReceivedFromIPMulticast">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":require"><e>flash10_1</e></m></meta>
	</class>
	<class path="flash.net.NetStreamPlayOptions" params="" file="C:\HaxeToolkit\haxe\std/flash/net/NetStreamPlayOptions.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<len public="1"><x path="Float"/></len>
		<offset public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</offset>
		<oldStreamName public="1"><c path="String"/></oldStreamName>
		<start public="1"><x path="Float"/></start>
		<streamName public="1"><c path="String"/></streamName>
		<transition public="1"><c path="String"/></transition>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.net.Responder" params="" file="C:\HaxeToolkit\haxe\std/flash/net/Responder.hx" extern="1"><new public="1" set="method"><f a="result:?status">
	<d/>
	<d/>
	<x path="Void"/>
</f></new></class>
	<class path="flash.net.URLRequest" params="" file="C:\HaxeToolkit\haxe\std/flash/net/URLRequest.hx" extern="1" final="1">
		<contentType public="1" get="accessor" set="accessor">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</contentType>
		<data public="1" get="accessor" set="accessor">
			<d/>
			<meta><m n=":flash.property"/></meta>
		</data>
		<digest public="1" get="accessor" set="accessor">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</digest>
		<method public="1" get="accessor" set="accessor">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</method>
		<requestHeaders public="1" get="accessor" set="accessor">
			<c path="Array"><c path="flash.net.URLRequestHeader"/></c>
			<meta><m n=":flash.property"/></meta>
		</requestHeaders>
		<url public="1" get="accessor" set="accessor">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</url>
		<get_contentType set="method"><f a=""><c path="String"/></f></get_contentType>
		<get_data set="method"><f a=""><d/></f></get_data>
		<get_digest set="method"><f a=""><c path="String"/></f></get_digest>
		<get_method set="method"><f a=""><c path="String"/></f></get_method>
		<get_requestHeaders set="method"><f a=""><c path="Array"><c path="flash.net.URLRequestHeader"/></c></f></get_requestHeaders>
		<get_url set="method"><f a=""><c path="String"/></f></get_url>
		<set_contentType set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_contentType>
		<set_data set="method"><f a="value">
	<d/>
	<d/>
</f></set_data>
		<set_digest set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_digest>
		<set_method set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_method>
		<set_requestHeaders set="method"><f a="value">
	<c path="Array"><c path="flash.net.URLRequestHeader"/></c>
	<c path="Array"><c path="flash.net.URLRequestHeader"/></c>
</f></set_requestHeaders>
		<set_url set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_url>
		<useRedirectedURL public="1" set="method">
			<f a="sourceRequest:?wholeURL:?pattern:?replace" v=":false::">
				<c path="flash.net.URLRequest"/>
				<x path="Bool"/>
				<d/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ wholeURL : false }</e></m></meta>
		</useRedirectedURL>
		<new public="1" set="method"><f a="?url">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.net.URLRequestHeader" params="" file="C:\HaxeToolkit\haxe\std/flash/net/URLRequestHeader.hx" extern="1" final="1">
		<name public="1"><c path="String"/></name>
		<value public="1"><c path="String"/></value>
		<new public="1" set="method"><f a="?name:?value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.system.ApplicationDomain" params="" file="C:\HaxeToolkit\haxe\std/flash/system/ApplicationDomain.hx" extern="1" final="1">
		<MIN_DOMAIN_MEMORY_LENGTH public="1" get="accessor" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</MIN_DOMAIN_MEMORY_LENGTH>
		<currentDomain public="1" get="accessor" set="null" static="1">
			<c path="flash.system.ApplicationDomain"/>
			<meta><m n=":flash.property"/></meta>
		</currentDomain>
		<get_MIN_DOMAIN_MEMORY_LENGTH set="method" static="1"><f a=""><x path="UInt"/></f></get_MIN_DOMAIN_MEMORY_LENGTH>
		<get_currentDomain set="method" static="1"><f a=""><c path="flash.system.ApplicationDomain"/></f></get_currentDomain>
		<domainMemory public="1" get="accessor" set="accessor">
			<c path="flash.utils.ByteArray"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</domainMemory>
		<parentDomain public="1" get="accessor" set="null">
			<c path="flash.system.ApplicationDomain"/>
			<meta><m n=":flash.property"/></meta>
		</parentDomain>
		<getDefinition public="1" set="method"><f a="name">
	<c path="String"/>
	<x path="flash.utils.Object"/>
</f></getDefinition>
		<getQualifiedDefinitionNames public="1">
			<f a=""><c path="flash.Vector"><c path="String"/></c></f>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</getQualifiedDefinitionNames>
		<get_domainMemory set="method"><f a=""><c path="flash.utils.ByteArray"/></f></get_domainMemory>
		<get_parentDomain set="method"><f a=""><c path="flash.system.ApplicationDomain"/></f></get_parentDomain>
		<hasDefinition public="1" set="method"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></hasDefinition>
		<set_domainMemory set="method"><f a="value">
	<c path="flash.utils.ByteArray"/>
	<c path="flash.utils.ByteArray"/>
</f></set_domainMemory>
		<new public="1" set="method"><f a="?parentDomain">
	<c path="flash.system.ApplicationDomain"/>
	<x path="Void"/>
</f></new>
	</class>
	<abstract path="flash.system.ImageDecodingPolicy" params="" file="C:\HaxeToolkit\haxe\std/flash/system/ImageDecodingPolicy.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.system.ImageDecodingPolicy"</e></m>
		</meta>
		<impl><class path="flash.system._ImageDecodingPolicy.ImageDecodingPolicy_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/system/ImageDecodingPolicy.hx" private="1" module="flash.system.ImageDecodingPolicy" extern="1" final="1">
	<ON_DEMAND public="1" set="null" static="1">
		<x path="flash.system.ImageDecodingPolicy"/>
		<meta><m n=":enum"/></meta>
	</ON_DEMAND>
	<ON_LOAD public="1" set="null" static="1">
		<x path="flash.system.ImageDecodingPolicy"/>
		<meta><m n=":enum"/></meta>
	</ON_LOAD>
	<meta>
		<m n=":native"><e>"flash.system.ImageDecodingPolicy"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.system._ImageDecodingPolicy.ImageDecodingPolicy_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/system/ImageDecodingPolicy.hx" private="1" module="flash.system.ImageDecodingPolicy" extern="1" final="1">
		<ON_DEMAND public="1" set="null" static="1">
			<x path="flash.system.ImageDecodingPolicy"/>
			<meta><m n=":enum"/></meta>
		</ON_DEMAND>
		<ON_LOAD public="1" set="null" static="1">
			<x path="flash.system.ImageDecodingPolicy"/>
			<meta><m n=":enum"/></meta>
		</ON_LOAD>
		<meta>
			<m n=":native"><e>"flash.system.ImageDecodingPolicy"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="flash.system.LoaderContext" params="" file="C:\HaxeToolkit\haxe\std/flash/system/LoaderContext.hx" extern="1">
		<allowCodeImport public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</allowCodeImport>
		<allowLoadBytesCodeExecution public="1">
			<x path="Bool"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</allowLoadBytesCodeExecution>
		<applicationDomain public="1"><c path="flash.system.ApplicationDomain"/></applicationDomain>
		<checkPolicyFile public="1"><x path="Bool"/></checkPolicyFile>
		<imageDecodingPolicy public="1">
			<x path="flash.system.ImageDecodingPolicy"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</imageDecodingPolicy>
		<parameters public="1">
			<d/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</parameters>
		<requestedContentParent public="1">
			<c path="flash.display.DisplayObjectContainer"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</requestedContentParent>
		<securityDomain public="1"><c path="flash.system.SecurityDomain"/></securityDomain>
		<get_allowLoadBytesCodeExecution set="method"><f a=""><x path="Bool"/></f></get_allowLoadBytesCodeExecution>
		<set_allowLoadBytesCodeExecution set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_allowLoadBytesCodeExecution>
		<new public="1" set="method">
			<f a="?checkPolicyFile:?applicationDomain:?securityDomain" v="false::">
				<x path="Bool"/>
				<c path="flash.system.ApplicationDomain"/>
				<c path="flash.system.SecurityDomain"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ checkPolicyFile : false }</e></m></meta>
		</new>
	</class>
	<class path="flash.system.SecurityDomain" params="" file="C:\HaxeToolkit\haxe\std/flash/system/SecurityDomain.hx" extern="1">
		<currentDomain public="1" get="accessor" set="null" static="1">
			<c path="flash.system.SecurityDomain"/>
			<meta><m n=":flash.property"/></meta>
		</currentDomain>
		<get_currentDomain set="method" static="1"><f a=""><c path="flash.system.SecurityDomain"/></f></get_currentDomain>
		<domainID public="1">
			<c path="String"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash11_3</e></m>
			</meta>
		</domainID>
		<get_domainID set="method"><f a=""><c path="String"/></f></get_domainID>
	</class>
	<abstract path="flash.text.AntiAliasType" params="" file="C:\HaxeToolkit\haxe\std/flash/text/AntiAliasType.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.text.AntiAliasType"</e></m>
		</meta>
		<impl><class path="flash.text._AntiAliasType.AntiAliasType_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/text/AntiAliasType.hx" private="1" module="flash.text.AntiAliasType" extern="1" final="1">
	<ADVANCED public="1" set="null" static="1">
		<x path="flash.text.AntiAliasType"/>
		<meta><m n=":enum"/></meta>
	</ADVANCED>
	<NORMAL public="1" set="null" static="1">
		<x path="flash.text.AntiAliasType"/>
		<meta><m n=":enum"/></meta>
	</NORMAL>
	<meta>
		<m n=":native"><e>"flash.text.AntiAliasType"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.text._AntiAliasType.AntiAliasType_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/text/AntiAliasType.hx" private="1" module="flash.text.AntiAliasType" extern="1" final="1">
		<ADVANCED public="1" set="null" static="1">
			<x path="flash.text.AntiAliasType"/>
			<meta><m n=":enum"/></meta>
		</ADVANCED>
		<NORMAL public="1" set="null" static="1">
			<x path="flash.text.AntiAliasType"/>
			<meta><m n=":enum"/></meta>
		</NORMAL>
		<meta>
			<m n=":native"><e>"flash.text.AntiAliasType"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="flash.text.GridFitType" params="" file="C:\HaxeToolkit\haxe\std/flash/text/GridFitType.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.text.GridFitType"</e></m>
		</meta>
		<impl><class path="flash.text._GridFitType.GridFitType_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/text/GridFitType.hx" private="1" module="flash.text.GridFitType" extern="1" final="1">
	<NONE public="1" set="null" static="1">
		<x path="flash.text.GridFitType"/>
		<meta><m n=":enum"/></meta>
	</NONE>
	<PIXEL public="1" set="null" static="1">
		<x path="flash.text.GridFitType"/>
		<meta><m n=":enum"/></meta>
	</PIXEL>
	<SUBPIXEL public="1" set="null" static="1">
		<x path="flash.text.GridFitType"/>
		<meta><m n=":enum"/></meta>
	</SUBPIXEL>
	<meta>
		<m n=":native"><e>"flash.text.GridFitType"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.text._GridFitType.GridFitType_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/text/GridFitType.hx" private="1" module="flash.text.GridFitType" extern="1" final="1">
		<NONE public="1" set="null" static="1">
			<x path="flash.text.GridFitType"/>
			<meta><m n=":enum"/></meta>
		</NONE>
		<PIXEL public="1" set="null" static="1">
			<x path="flash.text.GridFitType"/>
			<meta><m n=":enum"/></meta>
		</PIXEL>
		<SUBPIXEL public="1" set="null" static="1">
			<x path="flash.text.GridFitType"/>
			<meta><m n=":enum"/></meta>
		</SUBPIXEL>
		<meta>
			<m n=":native"><e>"flash.text.GridFitType"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="flash.text.StyleSheet" params="" file="C:\HaxeToolkit\haxe\std/flash/text/StyleSheet.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<styleNames public="1" get="accessor" set="null">
			<c path="Array"><d/></c>
			<meta><m n=":flash.property"/></meta>
		</styleNames>
		<clear public="1" set="method"><f a=""><x path="Void"/></f></clear>
		<getStyle public="1" set="method"><f a="styleName">
	<c path="String"/>
	<x path="flash.utils.Object"/>
</f></getStyle>
		<get_styleNames set="method"><f a=""><c path="Array"><d/></c></f></get_styleNames>
		<parseCSS public="1" set="method"><f a="CSSText">
	<c path="String"/>
	<x path="Void"/>
</f></parseCSS>
		<setStyle public="1" set="method"><f a="styleName:styleObject">
	<c path="String"/>
	<x path="flash.utils.Object"/>
	<x path="Void"/>
</f></setStyle>
		<transform public="1" set="method"><f a="formatObject">
	<x path="flash.utils.Object"/>
	<c path="flash.text.TextFormat"/>
</f></transform>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.text.TextField" params="" file="C:\HaxeToolkit\haxe\std/flash/text/TextField.hx" extern="1">
		<extends path="flash.display.InteractiveObject"/>
		<isFontCompatible public="1" set="method" static="1">
			<f a="fontName:fontStyle">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</isFontCompatible>
		<alwaysShowSelection public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</alwaysShowSelection>
		<antiAliasType public="1" get="accessor" set="accessor">
			<x path="flash.text.AntiAliasType"/>
			<meta><m n=":flash.property"/></meta>
		</antiAliasType>
		<autoSize public="1" get="accessor" set="accessor">
			<x path="flash.text.TextFieldAutoSize"/>
			<meta><m n=":flash.property"/></meta>
		</autoSize>
		<background public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</background>
		<backgroundColor public="1" get="accessor" set="accessor">
			<x path="UInt"/>
			<meta><m n=":flash.property"/></meta>
		</backgroundColor>
		<border public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</border>
		<borderColor public="1" get="accessor" set="accessor">
			<x path="UInt"/>
			<meta><m n=":flash.property"/></meta>
		</borderColor>
		<bottomScrollV public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</bottomScrollV>
		<caretIndex public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</caretIndex>
		<condenseWhite public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</condenseWhite>
		<defaultTextFormat public="1" get="accessor" set="accessor">
			<c path="flash.text.TextFormat"/>
			<meta><m n=":flash.property"/></meta>
		</defaultTextFormat>
		<displayAsPassword public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</displayAsPassword>
		<embedFonts public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</embedFonts>
		<gridFitType public="1" get="accessor" set="accessor">
			<x path="flash.text.GridFitType"/>
			<meta><m n=":flash.property"/></meta>
		</gridFitType>
		<htmlText public="1" get="accessor" set="accessor">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</htmlText>
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</length>
		<maxChars public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</maxChars>
		<maxScrollH public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</maxScrollH>
		<maxScrollV public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</maxScrollV>
		<mouseWheelEnabled public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</mouseWheelEnabled>
		<multiline public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</multiline>
		<numLines public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</numLines>
		<restrict public="1" get="accessor" set="accessor">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</restrict>
		<scrollH public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</scrollH>
		<scrollV public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</scrollV>
		<selectable public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</selectable>
		<selectedText public="1" get="accessor" set="null">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</selectedText>
		<selectionBeginIndex public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</selectionBeginIndex>
		<selectionEndIndex public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</selectionEndIndex>
		<sharpness public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</sharpness>
		<styleSheet public="1" get="accessor" set="accessor">
			<c path="flash.text.StyleSheet"/>
			<meta><m n=":flash.property"/></meta>
		</styleSheet>
		<text public="1" get="accessor" set="accessor">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</text>
		<textColor public="1" get="accessor" set="accessor">
			<x path="UInt"/>
			<meta><m n=":flash.property"/></meta>
		</textColor>
		<textHeight public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</textHeight>
		<textInteractionMode public="1">
			<x path="flash.text.TextInteractionMode"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash11</e></m>
			</meta>
		</textInteractionMode>
		<textWidth public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</textWidth>
		<thickness public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</thickness>
		<type public="1" get="accessor" set="accessor">
			<x path="flash.text.TextFieldType"/>
			<meta><m n=":flash.property"/></meta>
		</type>
		<useRichTextClipboard public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</useRichTextClipboard>
		<wordWrap public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</wordWrap>
		<appendText public="1" set="method"><f a="newText">
	<c path="String"/>
	<x path="Void"/>
</f></appendText>
		<copyRichText public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":ns">
	<e>"flash.text"</e>
	<e>internal</e>
</m></meta>
		</copyRichText>
		<getCharBoundaries public="1" set="method"><f a="charIndex">
	<x path="Int"/>
	<c path="flash.geom.Rectangle"/>
</f></getCharBoundaries>
		<getCharIndexAtPoint public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></getCharIndexAtPoint>
		<getFirstCharInParagraph public="1" set="method"><f a="charIndex">
	<x path="Int"/>
	<x path="Int"/>
</f></getFirstCharInParagraph>
		<getImageReference public="1" set="method"><f a="id">
	<c path="String"/>
	<c path="flash.display.DisplayObject"/>
</f></getImageReference>
		<getLineIndexAtPoint public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></getLineIndexAtPoint>
		<getLineIndexOfChar public="1" set="method"><f a="charIndex">
	<x path="Int"/>
	<x path="Int"/>
</f></getLineIndexOfChar>
		<getLineLength public="1" set="method"><f a="lineIndex">
	<x path="Int"/>
	<x path="Int"/>
</f></getLineLength>
		<getLineMetrics public="1" set="method"><f a="lineIndex">
	<x path="Int"/>
	<c path="flash.text.TextLineMetrics"/>
</f></getLineMetrics>
		<getLineOffset public="1" set="method"><f a="lineIndex">
	<x path="Int"/>
	<x path="Int"/>
</f></getLineOffset>
		<getLineText public="1" set="method"><f a="lineIndex">
	<x path="Int"/>
	<c path="String"/>
</f></getLineText>
		<getParagraphLength public="1" set="method"><f a="charIndex">
	<x path="Int"/>
	<x path="Int"/>
</f></getParagraphLength>
		<getRawText public="1" set="method"><f a=""><c path="String"/></f></getRawText>
		<getTextFormat public="1" set="method">
			<f a="?beginIndex:?endIndex" v="-1:-1">
				<x path="Int"/>
				<x path="Int"/>
				<c path="flash.text.TextFormat"/>
			</f>
			<meta><m n=":value"><e>{ endIndex : -1, beginIndex : -1 }</e></m></meta>
		</getTextFormat>
		<getTextRuns public="1" set="method">
			<f a="?beginIndex:?endIndex" v="0:2147483647">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><d/></c>
			</f>
			<meta><m n=":value"><e>{ endIndex : 2147483647, beginIndex : 0 }</e></m></meta>
		</getTextRuns>
		<getXMLText public="1" set="method">
			<f a="?beginIndex:?endIndex" v="0:2147483647">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ endIndex : 2147483647, beginIndex : 0 }</e></m></meta>
		</getXMLText>
		<get_alwaysShowSelection set="method"><f a=""><x path="Bool"/></f></get_alwaysShowSelection>
		<get_antiAliasType set="method"><f a=""><x path="flash.text.AntiAliasType"/></f></get_antiAliasType>
		<get_autoSize set="method"><f a=""><x path="flash.text.TextFieldAutoSize"/></f></get_autoSize>
		<get_background set="method"><f a=""><x path="Bool"/></f></get_background>
		<get_backgroundColor set="method"><f a=""><x path="UInt"/></f></get_backgroundColor>
		<get_border set="method"><f a=""><x path="Bool"/></f></get_border>
		<get_borderColor set="method"><f a=""><x path="UInt"/></f></get_borderColor>
		<get_bottomScrollV set="method"><f a=""><x path="Int"/></f></get_bottomScrollV>
		<get_caretIndex set="method"><f a=""><x path="Int"/></f></get_caretIndex>
		<get_condenseWhite set="method"><f a=""><x path="Bool"/></f></get_condenseWhite>
		<get_defaultTextFormat set="method"><f a=""><c path="flash.text.TextFormat"/></f></get_defaultTextFormat>
		<get_displayAsPassword set="method"><f a=""><x path="Bool"/></f></get_displayAsPassword>
		<get_embedFonts set="method"><f a=""><x path="Bool"/></f></get_embedFonts>
		<get_gridFitType set="method"><f a=""><x path="flash.text.GridFitType"/></f></get_gridFitType>
		<get_htmlText set="method"><f a=""><c path="String"/></f></get_htmlText>
		<get_length set="method"><f a=""><x path="Int"/></f></get_length>
		<get_maxChars set="method"><f a=""><x path="Int"/></f></get_maxChars>
		<get_maxScrollH set="method"><f a=""><x path="Int"/></f></get_maxScrollH>
		<get_maxScrollV set="method"><f a=""><x path="Int"/></f></get_maxScrollV>
		<get_mouseWheelEnabled set="method"><f a=""><x path="Bool"/></f></get_mouseWheelEnabled>
		<get_multiline set="method"><f a=""><x path="Bool"/></f></get_multiline>
		<get_numLines set="method"><f a=""><x path="Int"/></f></get_numLines>
		<get_restrict set="method"><f a=""><c path="String"/></f></get_restrict>
		<get_scrollH set="method"><f a=""><x path="Int"/></f></get_scrollH>
		<get_scrollV set="method"><f a=""><x path="Int"/></f></get_scrollV>
		<get_selectable set="method"><f a=""><x path="Bool"/></f></get_selectable>
		<get_selectedText set="method"><f a=""><c path="String"/></f></get_selectedText>
		<get_selectionBeginIndex set="method"><f a=""><x path="Int"/></f></get_selectionBeginIndex>
		<get_selectionEndIndex set="method"><f a=""><x path="Int"/></f></get_selectionEndIndex>
		<get_sharpness set="method"><f a=""><x path="Float"/></f></get_sharpness>
		<get_styleSheet set="method"><f a=""><c path="flash.text.StyleSheet"/></f></get_styleSheet>
		<get_text set="method"><f a=""><c path="String"/></f></get_text>
		<get_textColor set="method"><f a=""><x path="UInt"/></f></get_textColor>
		<get_textHeight set="method"><f a=""><x path="Float"/></f></get_textHeight>
		<get_textInteractionMode set="method"><f a=""><x path="flash.text.TextInteractionMode"/></f></get_textInteractionMode>
		<get_textWidth set="method"><f a=""><x path="Float"/></f></get_textWidth>
		<get_thickness set="method"><f a=""><x path="Float"/></f></get_thickness>
		<get_type set="method"><f a=""><x path="flash.text.TextFieldType"/></f></get_type>
		<get_useRichTextClipboard set="method"><f a=""><x path="Bool"/></f></get_useRichTextClipboard>
		<get_wordWrap set="method"><f a=""><x path="Bool"/></f></get_wordWrap>
		<insertXMLText public="1" set="method">
			<f a="beginIndex:endIndex:richText:?pasting" v=":::false">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ pasting : false }</e></m></meta>
		</insertXMLText>
		<pasteRichText public="1" set="method">
			<f a="richText">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":ns">
	<e>"flash.text"</e>
	<e>internal</e>
</m></meta>
		</pasteRichText>
		<replaceSelectedText public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></replaceSelectedText>
		<replaceText public="1" set="method"><f a="beginIndex:endIndex:newText">
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></replaceText>
		<setSelection public="1" set="method"><f a="beginIndex:endIndex">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setSelection>
		<setTextFormat public="1" set="method">
			<f a="format:?beginIndex:?endIndex" v=":-1:-1">
				<c path="flash.text.TextFormat"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ endIndex : -1, beginIndex : -1 }</e></m></meta>
		</setTextFormat>
		<set_alwaysShowSelection set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_alwaysShowSelection>
		<set_antiAliasType set="method"><f a="value">
	<x path="flash.text.AntiAliasType"/>
	<x path="flash.text.AntiAliasType"/>
</f></set_antiAliasType>
		<set_autoSize set="method"><f a="value">
	<x path="flash.text.TextFieldAutoSize"/>
	<x path="flash.text.TextFieldAutoSize"/>
</f></set_autoSize>
		<set_background set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_background>
		<set_backgroundColor set="method"><f a="value">
	<x path="UInt"/>
	<x path="UInt"/>
</f></set_backgroundColor>
		<set_border set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_border>
		<set_borderColor set="method"><f a="value">
	<x path="UInt"/>
	<x path="UInt"/>
</f></set_borderColor>
		<set_condenseWhite set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_condenseWhite>
		<set_defaultTextFormat set="method"><f a="value">
	<c path="flash.text.TextFormat"/>
	<c path="flash.text.TextFormat"/>
</f></set_defaultTextFormat>
		<set_displayAsPassword set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_displayAsPassword>
		<set_embedFonts set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_embedFonts>
		<set_gridFitType set="method"><f a="value">
	<x path="flash.text.GridFitType"/>
	<x path="flash.text.GridFitType"/>
</f></set_gridFitType>
		<set_htmlText set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_htmlText>
		<set_maxChars set="method"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_maxChars>
		<set_mouseWheelEnabled set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_mouseWheelEnabled>
		<set_multiline set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_multiline>
		<set_restrict set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_restrict>
		<set_scrollH set="method"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_scrollH>
		<set_scrollV set="method"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_scrollV>
		<set_selectable set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_selectable>
		<set_sharpness set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_sharpness>
		<set_styleSheet set="method"><f a="value">
	<c path="flash.text.StyleSheet"/>
	<c path="flash.text.StyleSheet"/>
</f></set_styleSheet>
		<set_text set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_text>
		<set_textColor set="method"><f a="value">
	<x path="UInt"/>
	<x path="UInt"/>
</f></set_textColor>
		<set_thickness set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_thickness>
		<set_type set="method"><f a="value">
	<x path="flash.text.TextFieldType"/>
	<x path="flash.text.TextFieldType"/>
</f></set_type>
		<set_useRichTextClipboard set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_useRichTextClipboard>
		<set_wordWrap set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_wordWrap>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="flash.text.TextFieldAutoSize" params="" file="C:\HaxeToolkit\haxe\std/flash/text/TextFieldAutoSize.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.text.TextFieldAutoSize"</e></m>
		</meta>
		<impl><class path="flash.text._TextFieldAutoSize.TextFieldAutoSize_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/text/TextFieldAutoSize.hx" private="1" module="flash.text.TextFieldAutoSize" extern="1" final="1">
	<CENTER public="1" set="null" static="1">
		<x path="flash.text.TextFieldAutoSize"/>
		<meta><m n=":enum"/></meta>
	</CENTER>
	<LEFT public="1" set="null" static="1">
		<x path="flash.text.TextFieldAutoSize"/>
		<meta><m n=":enum"/></meta>
	</LEFT>
	<NONE public="1" set="null" static="1">
		<x path="flash.text.TextFieldAutoSize"/>
		<meta><m n=":enum"/></meta>
	</NONE>
	<RIGHT public="1" set="null" static="1">
		<x path="flash.text.TextFieldAutoSize"/>
		<meta><m n=":enum"/></meta>
	</RIGHT>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":native"><e>"flash.text.TextFieldAutoSize"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.text._TextFieldAutoSize.TextFieldAutoSize_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/text/TextFieldAutoSize.hx" private="1" module="flash.text.TextFieldAutoSize" extern="1" final="1">
		<CENTER public="1" set="null" static="1">
			<x path="flash.text.TextFieldAutoSize"/>
			<meta><m n=":enum"/></meta>
		</CENTER>
		<LEFT public="1" set="null" static="1">
			<x path="flash.text.TextFieldAutoSize"/>
			<meta><m n=":enum"/></meta>
		</LEFT>
		<NONE public="1" set="null" static="1">
			<x path="flash.text.TextFieldAutoSize"/>
			<meta><m n=":enum"/></meta>
		</NONE>
		<RIGHT public="1" set="null" static="1">
			<x path="flash.text.TextFieldAutoSize"/>
			<meta><m n=":enum"/></meta>
		</RIGHT>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"flash.text.TextFieldAutoSize"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="flash.text.TextFieldType" params="" file="C:\HaxeToolkit\haxe\std/flash/text/TextFieldType.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.text.TextFieldType"</e></m>
		</meta>
		<impl><class path="flash.text._TextFieldType.TextFieldType_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/text/TextFieldType.hx" private="1" module="flash.text.TextFieldType" extern="1" final="1">
	<DYNAMIC public="1" set="null" static="1">
		<x path="flash.text.TextFieldType"/>
		<meta><m n=":enum"/></meta>
	</DYNAMIC>
	<INPUT public="1" set="null" static="1">
		<x path="flash.text.TextFieldType"/>
		<meta><m n=":enum"/></meta>
	</INPUT>
	<meta>
		<m n=":native"><e>"flash.text.TextFieldType"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.text._TextFieldType.TextFieldType_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/text/TextFieldType.hx" private="1" module="flash.text.TextFieldType" extern="1" final="1">
		<DYNAMIC public="1" set="null" static="1">
			<x path="flash.text.TextFieldType"/>
			<meta><m n=":enum"/></meta>
		</DYNAMIC>
		<INPUT public="1" set="null" static="1">
			<x path="flash.text.TextFieldType"/>
			<meta><m n=":enum"/></meta>
		</INPUT>
		<meta>
			<m n=":native"><e>"flash.text.TextFieldType"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="flash.text.TextFormat" params="" file="C:\HaxeToolkit\haxe\std/flash/text/TextFormat.hx" extern="1">
		<align public="1" get="accessor" set="accessor">
			<x path="flash.text.TextFormatAlign"/>
			<meta><m n=":flash.property"/></meta>
		</align>
		<blockIndent public="1" get="accessor" set="accessor">
			<x path="Null"><x path="Float"/></x>
			<meta><m n=":flash.property"/></meta>
		</blockIndent>
		<bold public="1" get="accessor" set="accessor">
			<x path="Null"><x path="Bool"/></x>
			<meta><m n=":flash.property"/></meta>
		</bold>
		<bullet public="1" get="accessor" set="accessor">
			<x path="Null"><x path="Bool"/></x>
			<meta><m n=":flash.property"/></meta>
		</bullet>
		<color public="1" get="accessor" set="accessor">
			<x path="Null"><x path="UInt"/></x>
			<meta><m n=":flash.property"/></meta>
		</color>
		<display public="1" get="accessor" set="accessor">
			<x path="flash.text.TextFormatDisplay"/>
			<meta><m n=":flash.property"/></meta>
		</display>
		<font public="1" get="accessor" set="accessor">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</font>
		<indent public="1" get="accessor" set="accessor">
			<x path="Null"><x path="Float"/></x>
			<meta><m n=":flash.property"/></meta>
		</indent>
		<italic public="1" get="accessor" set="accessor">
			<x path="Null"><x path="Bool"/></x>
			<meta><m n=":flash.property"/></meta>
		</italic>
		<kerning public="1" get="accessor" set="accessor">
			<x path="Null"><x path="Bool"/></x>
			<meta><m n=":flash.property"/></meta>
		</kerning>
		<leading public="1" get="accessor" set="accessor">
			<x path="Null"><x path="Float"/></x>
			<meta><m n=":flash.property"/></meta>
		</leading>
		<leftMargin public="1" get="accessor" set="accessor">
			<x path="Null"><x path="Float"/></x>
			<meta><m n=":flash.property"/></meta>
		</leftMargin>
		<letterSpacing public="1" get="accessor" set="accessor">
			<x path="Null"><x path="Float"/></x>
			<meta><m n=":flash.property"/></meta>
		</letterSpacing>
		<rightMargin public="1" get="accessor" set="accessor">
			<x path="Null"><x path="Float"/></x>
			<meta><m n=":flash.property"/></meta>
		</rightMargin>
		<size public="1" get="accessor" set="accessor">
			<x path="Null"><x path="Float"/></x>
			<meta><m n=":flash.property"/></meta>
		</size>
		<tabStops public="1" get="accessor" set="accessor">
			<c path="Array"><x path="UInt"/></c>
			<meta><m n=":flash.property"/></meta>
		</tabStops>
		<target public="1" get="accessor" set="accessor">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</target>
		<underline public="1" get="accessor" set="accessor">
			<x path="Null"><x path="Bool"/></x>
			<meta><m n=":flash.property"/></meta>
		</underline>
		<url public="1" get="accessor" set="accessor">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</url>
		<get_align set="method"><f a=""><x path="flash.text.TextFormatAlign"/></f></get_align>
		<get_blockIndent set="method"><f a=""><x path="Null"><x path="Float"/></x></f></get_blockIndent>
		<get_bold set="method"><f a=""><x path="Null"><x path="Bool"/></x></f></get_bold>
		<get_bullet set="method"><f a=""><x path="Null"><x path="Bool"/></x></f></get_bullet>
		<get_color set="method"><f a=""><x path="Null"><x path="UInt"/></x></f></get_color>
		<get_display set="method"><f a=""><x path="flash.text.TextFormatDisplay"/></f></get_display>
		<get_font set="method"><f a=""><c path="String"/></f></get_font>
		<get_indent set="method"><f a=""><x path="Null"><x path="Float"/></x></f></get_indent>
		<get_italic set="method"><f a=""><x path="Null"><x path="Bool"/></x></f></get_italic>
		<get_kerning set="method"><f a=""><x path="Null"><x path="Bool"/></x></f></get_kerning>
		<get_leading set="method"><f a=""><x path="Null"><x path="Float"/></x></f></get_leading>
		<get_leftMargin set="method"><f a=""><x path="Null"><x path="Float"/></x></f></get_leftMargin>
		<get_letterSpacing set="method"><f a=""><x path="Null"><x path="Float"/></x></f></get_letterSpacing>
		<get_rightMargin set="method"><f a=""><x path="Null"><x path="Float"/></x></f></get_rightMargin>
		<get_size set="method"><f a=""><x path="Null"><x path="Float"/></x></f></get_size>
		<get_tabStops set="method"><f a=""><c path="Array"><x path="UInt"/></c></f></get_tabStops>
		<get_target set="method"><f a=""><c path="String"/></f></get_target>
		<get_underline set="method"><f a=""><x path="Null"><x path="Bool"/></x></f></get_underline>
		<get_url set="method"><f a=""><c path="String"/></f></get_url>
		<set_align set="method"><f a="value">
	<x path="flash.text.TextFormatAlign"/>
	<x path="flash.text.TextFormatAlign"/>
</f></set_align>
		<set_blockIndent set="method"><f a="value">
	<x path="Null"><x path="Float"/></x>
	<x path="Null"><x path="Float"/></x>
</f></set_blockIndent>
		<set_bold set="method"><f a="value">
	<x path="Null"><x path="Bool"/></x>
	<x path="Null"><x path="Bool"/></x>
</f></set_bold>
		<set_bullet set="method"><f a="value">
	<x path="Null"><x path="Bool"/></x>
	<x path="Null"><x path="Bool"/></x>
</f></set_bullet>
		<set_color set="method"><f a="value">
	<x path="Null"><x path="UInt"/></x>
	<x path="Null"><x path="UInt"/></x>
</f></set_color>
		<set_display set="method"><f a="value">
	<x path="flash.text.TextFormatDisplay"/>
	<x path="flash.text.TextFormatDisplay"/>
</f></set_display>
		<set_font set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_font>
		<set_indent set="method"><f a="value">
	<x path="Null"><x path="Float"/></x>
	<x path="Null"><x path="Float"/></x>
</f></set_indent>
		<set_italic set="method"><f a="value">
	<x path="Null"><x path="Bool"/></x>
	<x path="Null"><x path="Bool"/></x>
</f></set_italic>
		<set_kerning set="method"><f a="value">
	<x path="Null"><x path="Bool"/></x>
	<x path="Null"><x path="Bool"/></x>
</f></set_kerning>
		<set_leading set="method"><f a="value">
	<x path="Null"><x path="Float"/></x>
	<x path="Null"><x path="Float"/></x>
</f></set_leading>
		<set_leftMargin set="method"><f a="value">
	<x path="Null"><x path="Float"/></x>
	<x path="Null"><x path="Float"/></x>
</f></set_leftMargin>
		<set_letterSpacing set="method"><f a="value">
	<x path="Null"><x path="Float"/></x>
	<x path="Null"><x path="Float"/></x>
</f></set_letterSpacing>
		<set_rightMargin set="method"><f a="value">
	<x path="Null"><x path="Float"/></x>
	<x path="Null"><x path="Float"/></x>
</f></set_rightMargin>
		<set_size set="method"><f a="value">
	<x path="Null"><x path="Float"/></x>
	<x path="Null"><x path="Float"/></x>
</f></set_size>
		<set_tabStops set="method"><f a="value">
	<c path="Array"><x path="UInt"/></c>
	<c path="Array"><x path="UInt"/></c>
</f></set_tabStops>
		<set_target set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_target>
		<set_underline set="method"><f a="value">
	<x path="Null"><x path="Bool"/></x>
	<x path="Null"><x path="Bool"/></x>
</f></set_underline>
		<set_url set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_url>
		<new public="1" set="method">
			<f a="?font:?size:?color:?bold:?italic:?underline:?url:?target:?align:?leftMargin:?rightMargin:?indent:?leading" v=":0:0:false:false:false::::0:0:0:0">
				<c path="String"/>
				<x path="Float"/>
				<x path="UInt"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="String"/>
				<c path="String"/>
				<x path="flash.text.TextFormatAlign"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ leading : 0, indent : 0, rightMargin : 0, leftMargin : 0, underline : false, italic : false, bold : false, color : 0, size : 0 }</e></m></meta>
		</new>
	</class>
	<abstract path="flash.text.TextFormatAlign" params="" file="C:\HaxeToolkit\haxe\std/flash/text/TextFormatAlign.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.text.TextFormatAlign"</e></m>
		</meta>
		<impl><class path="flash.text._TextFormatAlign.TextFormatAlign_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/text/TextFormatAlign.hx" private="1" module="flash.text.TextFormatAlign" extern="1" final="1">
	<CENTER public="1" set="null" static="1">
		<x path="flash.text.TextFormatAlign"/>
		<meta><m n=":enum"/></meta>
	</CENTER>
	<END public="1" set="null" static="1">
		<x path="flash.text.TextFormatAlign"/>
		<meta><m n=":enum"/></meta>
	</END>
	<JUSTIFY public="1" set="null" static="1">
		<x path="flash.text.TextFormatAlign"/>
		<meta><m n=":enum"/></meta>
	</JUSTIFY>
	<LEFT public="1" set="null" static="1">
		<x path="flash.text.TextFormatAlign"/>
		<meta><m n=":enum"/></meta>
	</LEFT>
	<RIGHT public="1" set="null" static="1">
		<x path="flash.text.TextFormatAlign"/>
		<meta><m n=":enum"/></meta>
	</RIGHT>
	<START public="1" set="null" static="1">
		<x path="flash.text.TextFormatAlign"/>
		<meta><m n=":enum"/></meta>
	</START>
	<meta>
		<m n=":native"><e>"flash.text.TextFormatAlign"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.text._TextFormatAlign.TextFormatAlign_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/text/TextFormatAlign.hx" private="1" module="flash.text.TextFormatAlign" extern="1" final="1">
		<CENTER public="1" set="null" static="1">
			<x path="flash.text.TextFormatAlign"/>
			<meta><m n=":enum"/></meta>
		</CENTER>
		<END public="1" set="null" static="1">
			<x path="flash.text.TextFormatAlign"/>
			<meta><m n=":enum"/></meta>
		</END>
		<JUSTIFY public="1" set="null" static="1">
			<x path="flash.text.TextFormatAlign"/>
			<meta><m n=":enum"/></meta>
		</JUSTIFY>
		<LEFT public="1" set="null" static="1">
			<x path="flash.text.TextFormatAlign"/>
			<meta><m n=":enum"/></meta>
		</LEFT>
		<RIGHT public="1" set="null" static="1">
			<x path="flash.text.TextFormatAlign"/>
			<meta><m n=":enum"/></meta>
		</RIGHT>
		<START public="1" set="null" static="1">
			<x path="flash.text.TextFormatAlign"/>
			<meta><m n=":enum"/></meta>
		</START>
		<meta>
			<m n=":native"><e>"flash.text.TextFormatAlign"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="flash.text.TextFormatDisplay" params="" file="C:\HaxeToolkit\haxe\std/flash/text/TextFormatDisplay.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.text.TextFormatDisplay"</e></m>
		</meta>
		<impl><class path="flash.text._TextFormatDisplay.TextFormatDisplay_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/text/TextFormatDisplay.hx" private="1" module="flash.text.TextFormatDisplay" extern="1" final="1">
	<BLOCK public="1" set="null" static="1">
		<x path="flash.text.TextFormatDisplay"/>
		<meta><m n=":enum"/></meta>
	</BLOCK>
	<INLINE public="1" set="null" static="1">
		<x path="flash.text.TextFormatDisplay"/>
		<meta><m n=":enum"/></meta>
	</INLINE>
	<meta>
		<m n=":native"><e>"flash.text.TextFormatDisplay"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.text._TextFormatDisplay.TextFormatDisplay_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/text/TextFormatDisplay.hx" private="1" module="flash.text.TextFormatDisplay" extern="1" final="1">
		<BLOCK public="1" set="null" static="1">
			<x path="flash.text.TextFormatDisplay"/>
			<meta><m n=":enum"/></meta>
		</BLOCK>
		<INLINE public="1" set="null" static="1">
			<x path="flash.text.TextFormatDisplay"/>
			<meta><m n=":enum"/></meta>
		</INLINE>
		<meta>
			<m n=":native"><e>"flash.text.TextFormatDisplay"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="flash.text.TextInteractionMode" params="" file="C:\HaxeToolkit\haxe\std/flash/text/TextInteractionMode.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.text.TextInteractionMode"</e></m>
		</meta>
		<impl><class path="flash.text._TextInteractionMode.TextInteractionMode_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/text/TextInteractionMode.hx" private="1" module="flash.text.TextInteractionMode" extern="1" final="1">
	<NORMAL public="1" set="null" static="1">
		<x path="flash.text.TextInteractionMode"/>
		<meta><m n=":enum"/></meta>
	</NORMAL>
	<SELECTION public="1" set="null" static="1">
		<x path="flash.text.TextInteractionMode"/>
		<meta><m n=":enum"/></meta>
	</SELECTION>
	<meta>
		<m n=":native"><e>"flash.text.TextInteractionMode"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.text._TextInteractionMode.TextInteractionMode_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/text/TextInteractionMode.hx" private="1" module="flash.text.TextInteractionMode" extern="1" final="1">
		<NORMAL public="1" set="null" static="1">
			<x path="flash.text.TextInteractionMode"/>
			<meta><m n=":enum"/></meta>
		</NORMAL>
		<SELECTION public="1" set="null" static="1">
			<x path="flash.text.TextInteractionMode"/>
			<meta><m n=":enum"/></meta>
		</SELECTION>
		<meta>
			<m n=":native"><e>"flash.text.TextInteractionMode"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="flash.text.TextLineMetrics" params="" file="C:\HaxeToolkit\haxe\std/flash/text/TextLineMetrics.hx" extern="1">
		<ascent public="1"><x path="Float"/></ascent>
		<descent public="1"><x path="Float"/></descent>
		<height public="1"><x path="Float"/></height>
		<leading public="1"><x path="Float"/></leading>
		<width public="1"><x path="Float"/></width>
		<x public="1"><x path="Float"/></x>
		<new public="1" set="method"><f a="x:width:height:ascent:descent:leading">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.text.TextSnapshot" params="" file="C:\HaxeToolkit\haxe\std/flash/text/TextSnapshot.hx" extern="1">
		<charCount public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</charCount>
		<findText public="1" set="method"><f a="beginIndex:textToFind:caseSensitive">
	<x path="Int"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></findText>
		<getSelected public="1" set="method"><f a="beginIndex:endIndex">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></getSelected>
		<getSelectedText public="1" set="method">
			<f a="?includeLineEndings" v="false">
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ includeLineEndings : false }</e></m></meta>
		</getSelectedText>
		<getText public="1" set="method">
			<f a="beginIndex:endIndex:?includeLineEndings" v="::false">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ includeLineEndings : false }</e></m></meta>
		</getText>
		<getTextRunInfo public="1" set="method"><f a="beginIndex:endIndex">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><d/></c>
</f></getTextRunInfo>
		<get_charCount set="method"><f a=""><x path="Int"/></f></get_charCount>
		<hitTestTextNearPos public="1" set="method">
			<f a="x:y:?maxDistance" v="::0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ maxDistance : 0 }</e></m></meta>
		</hitTestTextNearPos>
		<setSelectColor public="1" set="method">
			<f a="?hexColor" v="16776960">
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ hexColor : 16776960 }</e></m></meta>
		</setSelectColor>
		<setSelected public="1" set="method"><f a="beginIndex:endIndex:select">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setSelected>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.ui.ContextMenu" params="" file="C:\HaxeToolkit\haxe\std/flash/ui/ContextMenu.hx" extern="1" final="1">
		<extends path="flash.display.NativeMenu"/>
		<isSupported public="1" static="1">
			<x path="Bool"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</isSupported>
		<get_isSupported set="method" static="1"><f a=""><x path="Bool"/></f></get_isSupported>
		<builtInItems public="1" get="accessor" set="accessor">
			<c path="flash.ui.ContextMenuBuiltInItems"/>
			<meta><m n=":flash.property"/></meta>
		</builtInItems>
		<clipboardItems public="1" get="accessor" set="accessor">
			<c path="flash.ui.ContextMenuClipboardItems"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</clipboardItems>
		<clipboardMenu public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</clipboardMenu>
		<customItems public="1" get="accessor" set="accessor">
			<c path="Array"><d/></c>
			<meta><m n=":flash.property"/></meta>
		</customItems>
		<link public="1" get="accessor" set="accessor">
			<c path="flash.net.URLRequest"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</link>
		<clone public="1" set="method"><f a=""><c path="flash.ui.ContextMenu"/></f></clone>
		<get_builtInItems set="method"><f a=""><c path="flash.ui.ContextMenuBuiltInItems"/></f></get_builtInItems>
		<get_clipboardItems set="method"><f a=""><c path="flash.ui.ContextMenuClipboardItems"/></f></get_clipboardItems>
		<get_clipboardMenu set="method"><f a=""><x path="Bool"/></f></get_clipboardMenu>
		<get_customItems set="method"><f a=""><c path="Array"><d/></c></f></get_customItems>
		<get_link set="method"><f a=""><c path="flash.net.URLRequest"/></f></get_link>
		<hideBuiltInItems public="1" set="method"><f a=""><x path="Void"/></f></hideBuiltInItems>
		<set_builtInItems set="method"><f a="value">
	<c path="flash.ui.ContextMenuBuiltInItems"/>
	<c path="flash.ui.ContextMenuBuiltInItems"/>
</f></set_builtInItems>
		<set_clipboardItems set="method"><f a="value">
	<c path="flash.ui.ContextMenuClipboardItems"/>
	<c path="flash.ui.ContextMenuClipboardItems"/>
</f></set_clipboardItems>
		<set_clipboardMenu set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_clipboardMenu>
		<set_customItems set="method"><f a="value">
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
</f></set_customItems>
		<set_link set="method"><f a="value">
	<c path="flash.net.URLRequest"/>
	<c path="flash.net.URLRequest"/>
</f></set_link>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.ui.ContextMenuBuiltInItems" params="" file="C:\HaxeToolkit\haxe\std/flash/ui/ContextMenuBuiltInItems.hx" extern="1" final="1">
		<forwardAndBack public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</forwardAndBack>
		<loop public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</loop>
		<play public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</play>
		<print public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</print>
		<quality public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</quality>
		<rewind public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</rewind>
		<save public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</save>
		<zoom public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</zoom>
		<clone public="1" set="method"><f a=""><c path="flash.ui.ContextMenuBuiltInItems"/></f></clone>
		<get_forwardAndBack set="method"><f a=""><x path="Bool"/></f></get_forwardAndBack>
		<get_loop set="method"><f a=""><x path="Bool"/></f></get_loop>
		<get_play set="method"><f a=""><x path="Bool"/></f></get_play>
		<get_print set="method"><f a=""><x path="Bool"/></f></get_print>
		<get_quality set="method"><f a=""><x path="Bool"/></f></get_quality>
		<get_rewind set="method"><f a=""><x path="Bool"/></f></get_rewind>
		<get_save set="method"><f a=""><x path="Bool"/></f></get_save>
		<get_zoom set="method"><f a=""><x path="Bool"/></f></get_zoom>
		<set_forwardAndBack set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_forwardAndBack>
		<set_loop set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_loop>
		<set_play set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_play>
		<set_print set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_print>
		<set_quality set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_quality>
		<set_rewind set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_rewind>
		<set_save set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_save>
		<set_zoom set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_zoom>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.ui.ContextMenuClipboardItems" params="" file="C:\HaxeToolkit\haxe\std/flash/ui/ContextMenuClipboardItems.hx" extern="1" final="1">
		<clear public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</clear>
		<copy public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</copy>
		<cut public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</cut>
		<paste public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</paste>
		<selectAll public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</selectAll>
		<clone public="1" set="method"><f a=""><c path="flash.ui.ContextMenuClipboardItems"/></f></clone>
		<get_clear set="method"><f a=""><x path="Bool"/></f></get_clear>
		<get_copy set="method"><f a=""><x path="Bool"/></f></get_copy>
		<get_cut set="method"><f a=""><x path="Bool"/></f></get_cut>
		<get_paste set="method"><f a=""><x path="Bool"/></f></get_paste>
		<get_selectAll set="method"><f a=""><x path="Bool"/></f></get_selectAll>
		<set_clear set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_clear>
		<set_copy set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_copy>
		<set_cut set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_cut>
		<set_paste set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_paste>
		<set_selectAll set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_selectAll>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.utils.IDataInput" params="" file="C:\HaxeToolkit\haxe\std/flash/utils/IDataInput.hx" extern="1" interface="1">
		<bytesAvailable public="1" get="accessor" set="null">
			<x path="UInt"/>
			<meta><m n=":flash.property"/></meta>
		</bytesAvailable>
		<endian public="1" get="accessor" set="accessor">
			<x path="flash.utils.Endian"/>
			<meta><m n=":flash.property"/></meta>
		</endian>
		<objectEncoding public="1" get="accessor" set="accessor">
			<x path="UInt"/>
			<meta><m n=":flash.property"/></meta>
		</objectEncoding>
		<get_bytesAvailable set="method"><f a=""><x path="UInt"/></f></get_bytesAvailable>
		<get_endian set="method"><f a=""><x path="flash.utils.Endian"/></f></get_endian>
		<get_objectEncoding set="method"><f a=""><x path="UInt"/></f></get_objectEncoding>
		<readBoolean public="1" set="method"><f a=""><x path="Bool"/></f></readBoolean>
		<readByte public="1" set="method"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method">
			<f a="bytes:?offset:?length" v=":0:0">
				<c path="flash.utils.ByteArray"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ length : 0, offset : 0 }</e></m></meta>
		</readBytes>
		<readDouble public="1" set="method"><f a=""><x path="Float"/></f></readDouble>
		<readFloat public="1" set="method"><f a=""><x path="Float"/></f></readFloat>
		<readInt public="1" set="method"><f a=""><x path="Int"/></f></readInt>
		<readMultiByte public="1" set="method"><f a="length:charSet">
	<x path="UInt"/>
	<c path="String"/>
	<c path="String"/>
</f></readMultiByte>
		<readObject public="1" set="method"><f a=""><d/></f></readObject>
		<readShort public="1" set="method"><f a=""><x path="Int"/></f></readShort>
		<readUTF public="1" set="method"><f a=""><c path="String"/></f></readUTF>
		<readUTFBytes public="1" set="method"><f a="length">
	<x path="UInt"/>
	<c path="String"/>
</f></readUTFBytes>
		<readUnsignedByte public="1" set="method"><f a=""><x path="UInt"/></f></readUnsignedByte>
		<readUnsignedInt public="1" set="method"><f a=""><x path="UInt"/></f></readUnsignedInt>
		<readUnsignedShort public="1" set="method"><f a=""><x path="UInt"/></f></readUnsignedShort>
		<set_endian set="method"><f a="value">
	<x path="flash.utils.Endian"/>
	<x path="flash.utils.Endian"/>
</f></set_endian>
		<set_objectEncoding set="method"><f a="value">
	<x path="UInt"/>
	<x path="UInt"/>
</f></set_objectEncoding>
	</class>
	<class path="flash.utils.IDataInput2" params="" file="C:\HaxeToolkit\haxe\std/flash/utils/IDataInput2.hx" extern="1" interface="1"><extends path="flash.utils.IDataInput"/></class>
	<class path="flash.utils.IDataOutput" params="" file="C:\HaxeToolkit\haxe\std/flash/utils/IDataOutput.hx" extern="1" interface="1">
		<endian public="1" get="accessor" set="accessor">
			<x path="flash.utils.Endian"/>
			<meta><m n=":flash.property"/></meta>
		</endian>
		<objectEncoding public="1" get="accessor" set="accessor">
			<x path="UInt"/>
			<meta><m n=":flash.property"/></meta>
		</objectEncoding>
		<get_endian set="method"><f a=""><x path="flash.utils.Endian"/></f></get_endian>
		<get_objectEncoding set="method"><f a=""><x path="UInt"/></f></get_objectEncoding>
		<set_endian set="method"><f a="value">
	<x path="flash.utils.Endian"/>
	<x path="flash.utils.Endian"/>
</f></set_endian>
		<set_objectEncoding set="method"><f a="value">
	<x path="UInt"/>
	<x path="UInt"/>
</f></set_objectEncoding>
		<writeBoolean public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Void"/>
</f></writeBoolean>
		<writeByte public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method">
			<f a="bytes:?offset:?length" v=":0:0">
				<c path="flash.utils.ByteArray"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ length : 0, offset : 0 }</e></m></meta>
		</writeBytes>
		<writeDouble public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></writeDouble>
		<writeFloat public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></writeFloat>
		<writeInt public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeInt>
		<writeMultiByte public="1" set="method"><f a="value:charSet">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></writeMultiByte>
		<writeObject public="1" set="method"><f a="object">
	<d/>
	<x path="Void"/>
</f></writeObject>
		<writeShort public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeShort>
		<writeUTF public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></writeUTF>
		<writeUTFBytes public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></writeUTFBytes>
		<writeUnsignedInt public="1" set="method"><f a="value">
	<x path="UInt"/>
	<x path="Void"/>
</f></writeUnsignedInt>
	</class>
	<class path="flash.utils.IDataOutput2" params="" file="C:\HaxeToolkit\haxe\std/flash/utils/IDataOutput2.hx" extern="1" interface="1"><extends path="flash.utils.IDataOutput"/></class>
	<class path="flash.utils.ByteArray" params="" file="C:\HaxeToolkit\haxe\std/flash/utils/ByteArray.hx" extern="1">
		<implements path="flash.utils.IDataInput2"/>
		<implements path="flash.utils.IDataOutput2"/>
		<defaultObjectEncoding public="1" get="accessor" set="accessor" static="1">
			<x path="UInt"/>
			<meta><m n=":flash.property"/></meta>
		</defaultObjectEncoding>
		<get_defaultObjectEncoding set="method" static="1"><f a=""><x path="UInt"/></f></get_defaultObjectEncoding>
		<set_defaultObjectEncoding set="method" static="1"><f a="value">
	<x path="UInt"/>
	<x path="UInt"/>
</f></set_defaultObjectEncoding>
		<bytesAvailable public="1" get="accessor" set="null">
			<x path="UInt"/>
			<meta><m n=":flash.property"/></meta>
		</bytesAvailable>
		<endian public="1" get="accessor" set="accessor">
			<x path="flash.utils.Endian"/>
			<meta><m n=":flash.property"/></meta>
		</endian>
		<length public="1" get="accessor" set="accessor">
			<x path="UInt"/>
			<meta><m n=":flash.property"/></meta>
		</length>
		<objectEncoding public="1" get="accessor" set="accessor">
			<x path="UInt"/>
			<meta><m n=":flash.property"/></meta>
		</objectEncoding>
		<position public="1" get="accessor" set="accessor">
			<x path="UInt"/>
			<meta><m n=":flash.property"/></meta>
		</position>
		<shareable public="1">
			<x path="Bool"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash11_4</e></m>
			</meta>
		</shareable>
		<atomicCompareAndSwapIntAt public="1">
			<f a="byteIndex:expectedValue:newValue">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":require"><e>flash11_4</e></m></meta>
		</atomicCompareAndSwapIntAt>
		<atomicCompareAndSwapLength public="1">
			<f a="expectedLength:newLength">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":require"><e>flash11_4</e></m></meta>
		</atomicCompareAndSwapLength>
		<clear public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</clear>
		<compress public="1" set="method"><f a="?algorithm">
	<x path="flash.utils.CompressionAlgorithm"/>
	<x path="Void"/>
</f></compress>
		<deflate public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</deflate>
		<get_bytesAvailable set="method"><f a=""><x path="UInt"/></f></get_bytesAvailable>
		<get_endian set="method"><f a=""><x path="flash.utils.Endian"/></f></get_endian>
		<get_length set="method"><f a=""><x path="UInt"/></f></get_length>
		<get_objectEncoding set="method"><f a=""><x path="UInt"/></f></get_objectEncoding>
		<get_position set="method"><f a=""><x path="UInt"/></f></get_position>
		<get_shareable set="method"><f a=""><x path="Bool"/></f></get_shareable>
		<inflate public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</inflate>
		<readBoolean public="1" set="method"><f a=""><x path="Bool"/></f></readBoolean>
		<readByte public="1" set="method"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method">
			<f a="bytes:?offset:?length" v=":0:0">
				<c path="flash.utils.ByteArray"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ length : 0, offset : 0 }</e></m></meta>
		</readBytes>
		<readDouble public="1" set="method"><f a=""><x path="Float"/></f></readDouble>
		<readFloat public="1" set="method"><f a=""><x path="Float"/></f></readFloat>
		<readInt public="1" set="method"><f a=""><x path="Int"/></f></readInt>
		<readMultiByte public="1" set="method"><f a="length:charSet">
	<x path="UInt"/>
	<c path="String"/>
	<c path="String"/>
</f></readMultiByte>
		<readObject public="1" set="method"><f a=""><d/></f></readObject>
		<readShort public="1" set="method"><f a=""><x path="Int"/></f></readShort>
		<readUTF public="1" set="method"><f a=""><c path="String"/></f></readUTF>
		<readUTFBytes public="1" set="method"><f a="length">
	<x path="UInt"/>
	<c path="String"/>
</f></readUTFBytes>
		<readUnsignedByte public="1" set="method"><f a=""><x path="UInt"/></f></readUnsignedByte>
		<readUnsignedInt public="1" set="method"><f a=""><x path="UInt"/></f></readUnsignedInt>
		<readUnsignedShort public="1" set="method"><f a=""><x path="UInt"/></f></readUnsignedShort>
		<set_endian set="method"><f a="value">
	<x path="flash.utils.Endian"/>
	<x path="flash.utils.Endian"/>
</f></set_endian>
		<set_length set="method"><f a="value">
	<x path="UInt"/>
	<x path="UInt"/>
</f></set_length>
		<set_objectEncoding set="method"><f a="value">
	<x path="UInt"/>
	<x path="UInt"/>
</f></set_objectEncoding>
		<set_position set="method"><f a="value">
	<x path="UInt"/>
	<x path="UInt"/>
</f></set_position>
		<set_shareable set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_shareable>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<uncompress public="1" set="method"><f a="?algorithm">
	<x path="flash.utils.CompressionAlgorithm"/>
	<x path="Void"/>
</f></uncompress>
		<writeBoolean public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Void"/>
</f></writeBoolean>
		<writeByte public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method">
			<f a="bytes:?offset:?length" v=":0:0">
				<c path="flash.utils.ByteArray"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ length : 0, offset : 0 }</e></m></meta>
		</writeBytes>
		<writeDouble public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></writeDouble>
		<writeFloat public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></writeFloat>
		<writeInt public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeInt>
		<writeMultiByte public="1" set="method"><f a="value:charSet">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></writeMultiByte>
		<writeObject public="1" set="method"><f a="object">
	<d/>
	<x path="Void"/>
</f></writeObject>
		<writeShort public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeShort>
		<writeUTF public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></writeUTF>
		<writeUTFBytes public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></writeUTFBytes>
		<writeUnsignedInt public="1" set="method"><f a="value">
	<x path="UInt"/>
	<x path="Void"/>
</f></writeUnsignedInt>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="flash.utils.CompressionAlgorithm" params="" file="C:\HaxeToolkit\haxe\std/flash/utils/CompressionAlgorithm.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.utils.CompressionAlgorithm"</e></m>
			<m n=":require"><e>flash11</e></m>
		</meta>
		<impl><class path="flash.utils._CompressionAlgorithm.CompressionAlgorithm_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/utils/CompressionAlgorithm.hx" private="1" module="flash.utils.CompressionAlgorithm" extern="1" final="1">
	<DEFLATE public="1" set="null" static="1">
		<x path="flash.utils.CompressionAlgorithm"/>
		<meta><m n=":enum"/></meta>
	</DEFLATE>
	<LZMA public="1" set="null" static="1">
		<x path="flash.utils.CompressionAlgorithm"/>
		<meta><m n=":enum"/></meta>
	</LZMA>
	<ZLIB public="1" set="null" static="1">
		<x path="flash.utils.CompressionAlgorithm"/>
		<meta><m n=":enum"/></meta>
	</ZLIB>
	<meta>
		<m n=":native"><e>"flash.utils.CompressionAlgorithm"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.utils._CompressionAlgorithm.CompressionAlgorithm_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/utils/CompressionAlgorithm.hx" private="1" module="flash.utils.CompressionAlgorithm" extern="1" final="1">
		<DEFLATE public="1" set="null" static="1">
			<x path="flash.utils.CompressionAlgorithm"/>
			<meta><m n=":enum"/></meta>
		</DEFLATE>
		<LZMA public="1" set="null" static="1">
			<x path="flash.utils.CompressionAlgorithm"/>
			<meta><m n=":enum"/></meta>
		</LZMA>
		<ZLIB public="1" set="null" static="1">
			<x path="flash.utils.CompressionAlgorithm"/>
			<meta><m n=":enum"/></meta>
		</ZLIB>
		<meta>
			<m n=":native"><e>"flash.utils.CompressionAlgorithm"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="flash.utils.Endian" params="" file="C:\HaxeToolkit\haxe\std/flash/utils/Endian.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.utils.Endian"</e></m>
		</meta>
		<impl><class path="flash.utils._Endian.Endian_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/utils/Endian.hx" private="1" module="flash.utils.Endian" extern="1" final="1">
	<BIG_ENDIAN public="1" set="null" static="1">
		<x path="flash.utils.Endian"/>
		<meta><m n=":enum"/></meta>
	</BIG_ENDIAN>
	<LITTLE_ENDIAN public="1" set="null" static="1">
		<x path="flash.utils.Endian"/>
		<meta><m n=":enum"/></meta>
	</LITTLE_ENDIAN>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":native"><e>"flash.utils.Endian"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.utils._Endian.Endian_Impl_" params="" file="C:\HaxeToolkit\haxe\std/flash/utils/Endian.hx" private="1" module="flash.utils.Endian" extern="1" final="1">
		<BIG_ENDIAN public="1" set="null" static="1">
			<x path="flash.utils.Endian"/>
			<meta><m n=":enum"/></meta>
		</BIG_ENDIAN>
		<LITTLE_ENDIAN public="1" set="null" static="1">
			<x path="flash.utils.Endian"/>
			<meta><m n=":enum"/></meta>
		</LITTLE_ENDIAN>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"flash.utils.Endian"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<typedef path="flash.utils.Function" params="" file="C:\HaxeToolkit\haxe\std/flash/utils/Function.hx"><d/></typedef>
	<class path="flash.utils.Namespace" params="" file="C:\HaxeToolkit\haxe\std/flash/utils/Namespace.hx" extern="1" final="1">
		<prefix public="1" get="accessor" set="null">
			<d/>
			<meta><m n=":flash.property"/></meta>
		</prefix>
		<uri public="1" get="accessor" set="null">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</uri>
		<get_prefix set="method"><f a=""><d/></f></get_prefix>
		<get_uri set="method"><f a=""><c path="String"/></f></get_uri>
		<new public="1" set="method"><f a="?prefix:?uri">
	<d/>
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<abstract path="flash.utils.Object" params="" file="C:\HaxeToolkit\haxe\std/flash/utils/Object.hx">
		<from><icast><d/></icast></from>
		<this><x path="flash.utils.Object"/></this>
		<to><icast><d/></icast></to>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<class path="flash.xml.XML" params="" file="C:\HaxeToolkit\haxe\std/flash/xml/XML.hx" extern="1" final="1">
		<ignoreComments public="1" get="accessor" set="accessor" static="1">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</ignoreComments>
		<ignoreProcessingInstructions public="1" get="accessor" set="accessor" static="1">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</ignoreProcessingInstructions>
		<ignoreWhitespace public="1" get="accessor" set="accessor" static="1">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</ignoreWhitespace>
		<prettyIndent public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</prettyIndent>
		<prettyPrinting public="1" get="accessor" set="accessor" static="1">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</prettyPrinting>
		<defaultSettings public="1" set="method" static="1"><f a=""><d/></f></defaultSettings>
		<get_ignoreComments set="method" static="1"><f a=""><x path="Bool"/></f></get_ignoreComments>
		<get_ignoreProcessingInstructions set="method" static="1"><f a=""><x path="Bool"/></f></get_ignoreProcessingInstructions>
		<get_ignoreWhitespace set="method" static="1"><f a=""><x path="Bool"/></f></get_ignoreWhitespace>
		<get_prettyIndent set="method" static="1"><f a=""><x path="Int"/></f></get_prettyIndent>
		<get_prettyPrinting set="method" static="1"><f a=""><x path="Bool"/></f></get_prettyPrinting>
		<setSettings public="1" set="method" static="1"><f a="?o">
	<d/>
	<x path="Void"/>
</f></setSettings>
		<set_ignoreComments set="method" static="1"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_ignoreComments>
		<set_ignoreProcessingInstructions set="method" static="1"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_ignoreProcessingInstructions>
		<set_ignoreWhitespace set="method" static="1"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_ignoreWhitespace>
		<set_prettyIndent set="method" static="1"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_prettyIndent>
		<set_prettyPrinting set="method" static="1"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_prettyPrinting>
		<settings public="1" set="method" static="1"><f a=""><d/></f></settings>
		<addNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></addNamespace>
		<appendChild public="1" set="method"><f a="child">
	<d/>
	<c path="flash.xml.XML"/>
</f></appendChild>
		<attribute public="1" set="method"><f a="arg">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></attribute>
		<attributes public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></attributes>
		<child public="1" set="method"><f a="propertyName">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></child>
		<childIndex public="1" set="method"><f a=""><x path="Int"/></f></childIndex>
		<children public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></children>
		<comments public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></comments>
		<contains public="1" set="method"><f a="value">
	<d/>
	<x path="Bool"/>
</f></contains>
		<copy public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></copy>
		<descendants public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></descendants>
		<elements public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></elements>
		<hasComplexContent public="1" set="method"><f a=""><x path="Bool"/></f></hasComplexContent>
		<hasSimpleContent public="1" set="method"><f a=""><x path="Bool"/></f></hasSimpleContent>
		<inScopeNamespaces public="1" set="method"><f a=""><c path="Array"><d/></c></f></inScopeNamespaces>
		<insertChildAfter public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildAfter>
		<insertChildBefore public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildBefore>
		<length public="1" set="method"><f a=""><x path="Int"/></f></length>
		<localName public="1" set="method"><f a=""><x path="flash.utils.Object"/></f></localName>
		<name public="1" set="method"><f a=""><x path="flash.utils.Object"/></f></name>
		<namespace public="1" set="method"><f a="?prefix">
	<d/>
	<c path="flash.utils.Namespace"/>
</f></namespace>
		<namespaceDeclarations public="1" set="method"><f a=""><c path="Array"><d/></c></f></namespaceDeclarations>
		<nodeKind public="1" set="method"><f a=""><c path="String"/></f></nodeKind>
		<normalize public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></normalize>
		<notification public="1" set="method"><f a=""><t path="flash.utils.Function"/></f></notification>
		<parent public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></parent>
		<prependChild public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></prependChild>
		<processingInstructions public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></processingInstructions>
		<removeNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></removeNamespace>
		<replace public="1" set="method"><f a="propertyName:value">
	<d/>
	<d/>
	<c path="flash.xml.XML"/>
</f></replace>
		<setChildren public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></setChildren>
		<setLocalName public="1" set="method"><f a="name">
	<d/>
	<x path="Void"/>
</f></setLocalName>
		<setName public="1" set="method"><f a="name">
	<d/>
	<x path="Void"/>
</f></setName>
		<setNamespace public="1" set="method"><f a="ns">
	<d/>
	<x path="Void"/>
</f></setNamespace>
		<setNotification public="1" set="method"><f a="f">
	<t path="flash.utils.Function"/>
	<d/>
</f></setNotification>
		<text public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></text>
		<toJSON public="1">
			<f a="k">
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</toJSON>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<toXMLString public="1" set="method"><f a=""><c path="String"/></f></toXMLString>
		<valueOf public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></valueOf>
		<new public="1" set="method"><f a="?value">
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.xml.XMLList" params="" file="C:\HaxeToolkit\haxe\std/flash/xml/XMLList.hx" extern="1" final="1">
		<addNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></addNamespace>
		<appendChild public="1" set="method"><f a="child">
	<d/>
	<c path="flash.xml.XML"/>
</f></appendChild>
		<attribute public="1" set="method"><f a="arg">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></attribute>
		<attributes public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></attributes>
		<child public="1" set="method"><f a="propertyName">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></child>
		<childIndex public="1" set="method"><f a=""><x path="Int"/></f></childIndex>
		<children public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></children>
		<comments public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></comments>
		<contains public="1" set="method"><f a="value">
	<d/>
	<x path="Bool"/>
</f></contains>
		<copy public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></copy>
		<descendants public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></descendants>
		<elements public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></elements>
		<hasComplexContent public="1" set="method"><f a=""><x path="Bool"/></f></hasComplexContent>
		<hasSimpleContent public="1" set="method"><f a=""><x path="Bool"/></f></hasSimpleContent>
		<inScopeNamespaces public="1" set="method"><f a=""><c path="Array"><d/></c></f></inScopeNamespaces>
		<insertChildAfter public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildAfter>
		<insertChildBefore public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildBefore>
		<length public="1" set="method"><f a=""><x path="Int"/></f></length>
		<localName public="1" set="method"><f a=""><x path="flash.utils.Object"/></f></localName>
		<name public="1" set="method"><f a=""><x path="flash.utils.Object"/></f></name>
		<namespace public="1" set="method"><f a="?prefix">
	<d/>
	<c path="flash.utils.Namespace"/>
</f></namespace>
		<namespaceDeclarations public="1" set="method"><f a=""><c path="Array"><d/></c></f></namespaceDeclarations>
		<nodeKind public="1" set="method"><f a=""><c path="String"/></f></nodeKind>
		<normalize public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></normalize>
		<parent public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></parent>
		<prependChild public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></prependChild>
		<processingInstructions public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></processingInstructions>
		<removeNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></removeNamespace>
		<replace public="1" set="method"><f a="propertyName:value">
	<d/>
	<d/>
	<c path="flash.xml.XML"/>
</f></replace>
		<setChildren public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></setChildren>
		<setLocalName public="1" set="method"><f a="name">
	<d/>
	<x path="Void"/>
</f></setLocalName>
		<setName public="1" set="method"><f a="name">
	<d/>
	<x path="Void"/>
</f></setName>
		<setNamespace public="1" set="method"><f a="ns">
	<d/>
	<x path="Void"/>
</f></setNamespace>
		<text public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></text>
		<toJSON public="1">
			<f a="k">
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</toJSON>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<toXMLString public="1" set="method"><f a=""><c path="String"/></f></toXMLString>
		<valueOf public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></valueOf>
		<new public="1" set="method"><f a="?value">
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<abstract path="haxe.CallStack" params="" file="C:\HaxeToolkit\haxe\std/haxe/CallStack.hx">
		<from><icast><c path="Array"><e path="haxe.StackItem"/></c></icast></from>
		<this><c path="Array"><e path="haxe.StackItem"/></c></this>
		<haxe_doc>Get information about the call stack.</haxe_doc>
		<meta>
			<m n=":allow"><e>haxe.Exception</e></m>
			<m n=":using"><e>haxe.CallStack</e></m>
		</meta>
		<impl><class path="haxe._CallStack.CallStack_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/CallStack.hx" private="1" module="haxe.CallStack" final="1"><meta>
	<m n=":keep"/>
	<m n=":using"><e>haxe.CallStack</e></m>
	<m n=":allow"><e>haxe.Exception</e></m>
</meta></class></impl>
	</abstract>
	<abstract path="haxe.Function" params="" file="C:\HaxeToolkit\haxe\std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with any function type.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<meta><m n=":callable"/></meta>
		<impl><class path="haxe._Constraints.Function_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/Constraints.hx" private="1" module="haxe.Constraints" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.FlatEnum" params="" file="C:\HaxeToolkit\haxe\std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with an enum instance if all constructors of the enum
	require no arguments.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<impl><class path="haxe._Constraints.FlatEnum_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/Constraints.hx" private="1" module="haxe.Constraints" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.NotVoid" params="" file="C:\HaxeToolkit\haxe\std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with anything but `Void`.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<impl><class path="haxe._Constraints.NotVoid_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/Constraints.hx" private="1" module="haxe.Constraints" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.Constructible" params="T" file="C:\HaxeToolkit\haxe\std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc><![CDATA[This type unifies with any instance of classes that have a constructor
	which

	  * is `public` and
	  * unifies with the type used for type parameter `T`.

	If a type parameter `A` is assigned to a type parameter `B` which is constrained
	to `Constructible<T>`, A must be explicitly constrained to
	`Constructible<T>` as well.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.]]></haxe_doc>
		<impl><class path="haxe._Constraints.Constructible_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/Constraints.hx" private="1" module="haxe.Constraints" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.EnumTools" params="" file="C:\HaxeToolkit\haxe\std/haxe/EnumTools.hx" extern="1">
		<getName public="1" params="T" get="inline" set="null" line="52" static="1">
			<f a="e">
				<x path="Enum"><c path="getName.T"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum `e`, including its path.

		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
		
			pack1.pack2.(...).packN.EnumName

		If `e` is a sub-type of a Haxe module, that module is not part of the
		package structure.

		If `e` has no package, the enum name is returned.

		If `e` is `null`, the result is unspecified.

		The enum name does not include any type parameters.</haxe_doc>
		</getName>
		<createByName public="1" params="T" get="inline" set="null" line="65" static="1">
			<f a="e:constr:?params">
				<x path="Enum"><c path="createByName.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createByName.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.

		If `e` or `constr` is `null`, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createByName>
		<createByIndex public="1" params="T" get="inline" set="null" line="81" static="1">
			<f a="e:index:?params">
				<x path="Enum"><c path="createByIndex.T"/></x>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<c path="createByIndex.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor number
		`index` with arguments `params`.

		The constructor indices are preserved from Haxe syntax, so the first
		declared is index 0, the next index 1 etc.

		If `e` or `index` is `null`, or if enum `e` has no constructor
		corresponding to index `index`, or if the number of elements in `params`
		does not match the expected number of constructor arguments, or if any
		argument has an invalid type, the result is unspecified.</haxe_doc>
		</createByIndex>
		<createAll public="1" params="T" get="inline" set="null" line="98" static="1">
			<f a="e">
				<x path="Enum"><c path="createAll.T"/></x>
				<c path="Array"><c path="createAll.T"/></c>
			</f>
			<haxe_doc>Returns a list of all constructors of enum `e` that require no
		arguments.

		This may return the empty Array `[]` if all constructors of `e` require
		arguments.

		Otherwise an instance of `e` constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</createAll>
		<getConstructors public="1" params="T" get="inline" set="null" line="110" static="1">
			<f a="e">
				<x path="Enum"><c path="getConstructors.T"/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.

		The order of the constructor names in the returned Array is preserved
		from the original syntax.

		If `c` is `null`, the result is unspecified.</haxe_doc>
		</getConstructors>
		<haxe_doc>This class provides advanced methods on enums. It is ideally used with
	`using EnumTools` and then acts as an
	  [extension](https://haxe.org/manual/lf-static-extension.html) to the
	  `enum` types.

	If the first argument to any of the methods is `null`, the result is
	unspecified.</haxe_doc>
	</class>
	<class path="haxe.EnumValueTools" params="" file="C:\HaxeToolkit\haxe\std/haxe/EnumTools.hx" module="haxe.EnumTools" extern="1">
		<equals public="1" params="T" get="inline" set="null" line="133" static="1">
			<f a="a:b">
				<c path="equals.T"/>
				<c path="equals.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.

		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors (if there are any).

		If `a` or `b` are `null`, the result is unspecified.</haxe_doc>
		</equals>
		<getName public="1" get="inline" set="null" line="144" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor name of enum instance `e`.

		The result String does not contain any constructor arguments.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getName>
		<getParameters public="1" get="inline" set="null" line="158" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.

		If `e` has no arguments, the result is `[]`.

		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getParameters>
		<getIndex public="1" get="inline" set="null" line="170" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of enum instance `e`.

		This corresponds to the original syntactic position of `e`. The index of
		the first declared constructor is 0, the next one is 1 etc.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getIndex>
		<haxe_doc>This class provides advanced methods on enum values. It is ideally used with
	`using EnumValueTools` and then acts as an
	  [extension](https://haxe.org/manual/lf-static-extension.html) to the
	  `EnumValue` types.

	If the first argument to any of the methods is `null`, the result is
	unspecified.</haxe_doc>
	</class>
	<class path="haxe.NativeException" params="" file="C:\HaxeToolkit\haxe\std/flash/_std/haxe/Exception.hx" module="haxe.Exception" extern="1">
		<errorID get="accessor" set="null">
			<x path="Int"/>
			<meta>
				<m n=":noCompletion"/>
				<m n=":flash.property"/>
			</meta>
		</errorID>
		<name>
			<d/>
			<meta><m n=":noCompletion"/></meta>
		</name>
		<getStackTrace set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":noCompletion"/></meta>
		</getStackTrace>
		<get_errorID set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_errorID>
		<new set="method">
			<f a="?message:?id" v=":0">
				<d/>
				<d/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ id : 0 }</e></m>
				<m n=":noCompletion"/>
			</meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":native"><e>"flash.errors.Error"</e></m>
		</meta>
	</class>
	<class path="haxe.Exception" params="" file="C:\HaxeToolkit\haxe\std/flash/_std/haxe/Exception.hx">
		<extends path="haxe.NativeException"/>
		<thrown set="method" line="28" static="1"><f a="value">
	<x path="Any"/>
	<x path="Any"/>
</f></thrown>
		<native public="1" get="accessor" set="null">
			<x path="Any"/>
			<haxe_doc>Native exception, which caused this exception.</haxe_doc>
		</native>
		<__nativeStack>
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</__nativeStack>
		<__skipStack>
			<x path="Int"/>
			<meta>
				<m n=":noCompletion"/>
				<m n=":ifFeature"><e>"haxe.Exception.get_stack"</e></m>
			</meta>
		</__skipStack>
		<__nativeException>
			<c path="flash.errors.Error"/>
			<meta><m n=":noCompletion"/></meta>
		</__nativeException>
		<__previousException>
			<x path="Null"><c path="haxe.Exception"/></x>
			<meta><m n=":noCompletion"/></meta>
		</__previousException>
		<get_native final="1" set="method" line="78"><f a=""><x path="Any"/></f></get_native>
		<new public="1" set="method" line="40">
			<f a="message:?previous:?native">
				<c path="String"/>
				<c path="haxe.Exception"/>
				<x path="Any"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Create a new Exception instance.

		The `previous` argument could be used for exception chaining.

		The `native` argument is for internal usage only.
		There is no need to provide `native` argument manually and no need to keep it
		upon extending `haxe.Exception` unless you know what you're doing.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[Base class for exceptions.

	If this class (or derivatives) is used to catch an exception, then
	`haxe.CallStack.exceptionStack()` will not return a stack for the exception
	caught. Use `haxe.Exception.stack` property instead:
	```haxe
	try {
		throwSomething();
	} catch(e:Exception) {
		trace(e.stack);
	}
	```

	Custom exceptions should extend this class:
	```haxe
	class MyException extends haxe.Exception {}
	//...
	throw new MyException('terrible exception');
	```

	`haxe.Exception` is also a wildcard type to catch any exception:
	```haxe
	try {
		throw 'Catch me!';
	} catch(e:haxe.Exception) {
		trace(e.message); // Output: Catch me!
	}
	```

	To rethrow an exception just throw it again.
	Haxe will try to rethrow an original native exception whenever possible.
	```haxe
	try {
		var a:Array<Int> = null;
		a.push(1); // generates target-specific null-pointer exception
	} catch(e:haxe.Exception) {
		throw e; // rethrows native exception instead of haxe.Exception
	}
	```]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="haxe.NativeStackTrace" params="" file="C:\HaxeToolkit\haxe\std/flash/_std/haxe/NativeStackTrace.hx">
		<normalize set="method" line="53" static="1">
			<f a="stack:?skipItems" v=":0">
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ skipItems : 0 }</e></m></meta>
		</normalize>
		<skipLines set="method" line="61" static="1">
			<f a="stack:skip:?pos" v="::0">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ pos : 0 }</e></m></meta>
		</skipLines>
		<haxe_doc>Do not use manually.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":allow"><e>haxe.Exception</e></m>
		</meta>
	</class>
	<typedef path="haxe.PosInfos" params="" file="C:\HaxeToolkit\haxe\std/haxe/PosInfos.hx">
		<a>
			<methodName><c path="String"/></methodName>
			<lineNumber><x path="Int"/></lineNumber>
			<fileName><c path="String"/></fileName>
			<customParams>
				<x path="Null"><c path="Array"><d/></c></x>
				<meta><m n=":optional"/></meta>
			</customParams>
			<className><c path="String"/></className>
		</a>
		<haxe_doc>`PosInfos` is a magic type which can be used to generate position information
	into the output for debugging use.

	If a function has a final optional argument of this type, i.e.
	`(..., ?pos:haxe.PosInfos)`, each call to that function which does not assign
	a value to that argument has its position added as call argument.

	This can be used to track positions of calls in e.g. a unit testing
	framework.</haxe_doc>
	</typedef>
	<typedef path="haxe._Rest.NativeRest" params="T" file="C:\HaxeToolkit\haxe\std/haxe/Rest.hx" private="1" module="haxe.Rest"><c path="Array"><c path="haxe._Rest.NativeRest.T"/></c></typedef>
	<abstract path="haxe.Rest" params="T" file="C:\HaxeToolkit\haxe\std/haxe/Rest.hx">
		<from><icast field="of"><c path="Array"><c path="of.T"/></c></icast></from>
		<this><t path="haxe._Rest.NativeRest"><c path="haxe.Rest.T"/></t></this>
		<to><icast field="toArray"><c path="Array"><c path="haxe.Rest.T"/></c></icast></to>
		<haxe_doc><![CDATA[A special type that represents a "rest" function argument.
	
	The special `...` syntax can be used for convenience and improved readability:

	```haxe
	function f(...rest:Int) {
		$type(rest); // haxe.Rest<Int>
	}

	f(1, 2, 3);

	final array = [1, 2, 3];
	f(...array);
	```

	Should be used as a type for the last argument of a method, indicating that
	an arbitrary number of arguments of the given type can be passed to that method.

	Allows to use array access by index to get values of rest arguments.
	If the index exceeds the amount of rest arguments passed, the result is unspecified.]]></haxe_doc>
		<meta><m n=":coreApi"/></meta>
		<impl><class path="haxe._Rest.Rest_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/Rest.hx" private="1" module="haxe.Rest" final="1"><meta>
	<m n=":keep"/>
	<m n=":coreApi"/>
</meta></class></impl>
	</abstract>
	<class path="haxe.ValueException" params="" file="C:\HaxeToolkit\haxe\std/haxe/ValueException.hx">
		<extends path="haxe.Exception"/>
		<value public="1" set="null">
			<x path="Any"/>
			<haxe_doc>Thrown value.</haxe_doc>
		</value>
		<new public="1" set="method" line="23"><f a="value:?previous:?native">
	<x path="Any"/>
	<c path="haxe.Exception"/>
	<x path="Any"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>An exception containing arbitrary value.

	This class is automatically used for throwing values, which don't extend `haxe.Exception`
	or native exception type.
	For example:
	```haxe
	throw "Terrible error";
	```
	will be compiled to
	```haxe
	throw new ValueException("Terrible error");
	```</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<typedef path="haxe.extern.Rest" params="T" file="C:\HaxeToolkit\haxe\std/haxe/extern/Rest.hx">
		<x path="haxe.Rest"><c path="haxe.extern.Rest.T"/></x>
		<haxe_doc><![CDATA[DEPRECATED: use haxe.Rest instead.
	
	A special type that represents "rest" function argument.
	Should be used as a type for the last argument of an extern method,
	representing that arbitrary number of arguments of given type can be
	passed to that method.
	@see <https://haxe.org/manual/lf-externs.html>]]></haxe_doc>
	</typedef>
</haxe>